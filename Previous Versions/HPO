{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "e425e634",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-13T13:56:48.336994Z",
     "iopub.status.busy": "2025-05-13T13:56:48.336613Z",
     "iopub.status.idle": "2025-05-13T13:56:55.003823Z",
     "shell.execute_reply": "2025-05-13T13:56:55.002840Z"
    },
    "papermill": {
     "duration": 6.675269,
     "end_time": "2025-05-13T13:56:55.005554",
     "exception": false,
     "start_time": "2025-05-13T13:56:48.330285",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Cloning into 'PIE'...\r\n",
      "remote: Enumerating objects: 178, done.\u001b[K\r\n",
      "remote: Counting objects: 100% (93/93), done.\u001b[K\r\n",
      "remote: Compressing objects: 100% (74/74), done.\u001b[K\r\n",
      "remote: Total 178 (delta 32), reused 75 (delta 17), pack-reused 85 (from 1)\u001b[K\r\n",
      "Receiving objects: 100% (178/178), 144.63 MiB | 36.37 MiB/s, done.\r\n",
      "Resolving deltas: 100% (73/73), done.\r\n",
      "Updating files: 100% (41/41), done.\r\n",
      "unzip:  cannot find or open /content/PIE/annotations/annotations.zip, /content/PIE/annotations/annotations.zip.zip or /content/PIE/annotations/annotations.zip.ZIP.\r\n",
      "unzip:  cannot find or open /content/PIE/annotations/annotations_vehicle.zip, /content/PIE/annotations/annotations_vehicle.zip.zip or /content/PIE/annotations/annotations_vehicle.zip.ZIP.\r\n"
     ]
    }
   ],
   "source": [
    "!git clone https://github.com/aras62/PIE.git\n",
    "!unzip /content/PIE/annotations/annotations.zip -d /content/PIE\n",
    "!unzip /content/PIE/annotations/annotations_vehicle.zip -d /content/PIE\n",
    "# !git clone https://github.com/hustvl/YOLOP.git\n",
    "!mkdir /kaggle/working/PIE/content"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "0b021057",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-13T13:56:55.018276Z",
     "iopub.status.busy": "2025-05-13T13:56:55.017978Z",
     "iopub.status.idle": "2025-05-13T13:57:00.598351Z",
     "shell.execute_reply": "2025-05-13T13:57:00.597424Z"
    },
    "papermill": {
     "duration": 5.588204,
     "end_time": "2025-05-13T13:57:00.599998",
     "exception": false,
     "start_time": "2025-05-13T13:56:55.011794",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m1.0/1.0 MB\u001b[0m \u001b[31m16.2 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\r\n",
      "\u001b[?25h"
     ]
    }
   ],
   "source": [
    "!pip install -q ultralytics opencv-python-headless "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "700d325b",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-13T13:57:00.612876Z",
     "iopub.status.busy": "2025-05-13T13:57:00.612560Z",
     "iopub.status.idle": "2025-05-13T13:57:06.748624Z",
     "shell.execute_reply": "2025-05-13T13:57:06.747922Z"
    },
    "papermill": {
     "duration": 6.144105,
     "end_time": "2025-05-13T13:57:06.750316",
     "exception": false,
     "start_time": "2025-05-13T13:57:00.606211",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Creating new Ultralytics Settings v0.0.6 file ✅ \n",
      "View Ultralytics Settings with 'yolo settings' or at '/root/.config/Ultralytics/settings.json'\n",
      "Update Settings with 'yolo settings key=value', i.e. 'yolo settings runs_dir=path/to/dir'. For help see https://docs.ultralytics.com/quickstart/#ultralytics-settings.\n"
     ]
    }
   ],
   "source": [
    "import torch\n",
    "import torch.nn as nn\n",
    "import torch.optim as optim\n",
    "from torch.utils.data import Dataset, DataLoader\n",
    "import xml.etree.ElementTree as ET\n",
    "import os\n",
    "import numpy as np\n",
    "from sklearn.metrics import accuracy_score, precision_recall_fscore_support, roc_auc_score, confusion_matrix, ConfusionMatrixDisplay\n",
    "from tqdm.notebook import tqdm\n",
    "import random\n",
    "import math\n",
    "import zipfile\n",
    "import cv2\n",
    "from ultralytics import YOLO\n",
    "import pandas as pd \n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import time"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "cd252e6e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-13T13:57:06.762714Z",
     "iopub.status.busy": "2025-05-13T13:57:06.762362Z",
     "iopub.status.idle": "2025-05-13T13:57:08.284198Z",
     "shell.execute_reply": "2025-05-13T13:57:08.283177Z"
    },
    "papermill": {
     "duration": 1.529266,
     "end_time": "2025-05-13T13:57:08.285550",
     "exception": false,
     "start_time": "2025-05-13T13:57:06.756284",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Unzipped successfully.\n"
     ]
    }
   ],
   "source": [
    "zip_path = \"/kaggle/working/PIE/annotations/annotations.zip\"\n",
    "extract_to = \"/kaggle/working/PIE/annotations/\"\n",
    "\n",
    "if os.path.exists(extract_to + 'annotations'):\n",
    "    print(\"Exists already. Not unzipping.\")\n",
    "else:\n",
    "    with zipfile.ZipFile(zip_path, 'r') as zip_ref:\n",
    "        zip_ref.extractall(extract_to)\n",
    "    print(\"Unzipped successfully.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "e46be5c6",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-13T13:57:08.298260Z",
     "iopub.status.busy": "2025-05-13T13:57:08.298009Z",
     "iopub.status.idle": "2025-05-13T13:57:09.017041Z",
     "shell.execute_reply": "2025-05-13T13:57:09.015999Z"
    },
    "papermill": {
     "duration": 0.726797,
     "end_time": "2025-05-13T13:57:09.018562",
     "exception": false,
     "start_time": "2025-05-13T13:57:08.291765",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Unzipped successfully.\n"
     ]
    }
   ],
   "source": [
    "zip_path = \"/kaggle/working/PIE/annotations/annotations_vehicle.zip\"\n",
    "extract_to = \"/kaggle/working/PIE/annotations/\"\n",
    "\n",
    "if os.path.exists(extract_to + 'annotations_vehicle'):\n",
    "    print(\"Exists already. Not unzipping.\")\n",
    "else:\n",
    "    with zipfile.ZipFile(zip_path, 'r') as zip_ref:\n",
    "        zip_ref.extractall(extract_to)\n",
    "    print(\"Unzipped successfully.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "b1e27300",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-13T13:57:09.030953Z",
     "iopub.status.busy": "2025-05-13T13:57:09.030653Z",
     "iopub.status.idle": "2025-05-13T13:57:09.043344Z",
     "shell.execute_reply": "2025-05-13T13:57:09.042510Z"
    },
    "papermill": {
     "duration": 0.020259,
     "end_time": "2025-05-13T13:57:09.044615",
     "exception": false,
     "start_time": "2025-05-13T13:57:09.024356",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Unzipped successfully.\n"
     ]
    }
   ],
   "source": [
    "zip_path = \"/kaggle/working/PIE/annotations/annotations_attributes.zip\"\n",
    "extract_to = \"/kaggle/working/PIE/annotations/\"\n",
    "\n",
    "if os.path.exists(extract_to + \"annotations_attributes\"):\n",
    "    print(\"Exists already. Not unzipping.\")\n",
    "else:\n",
    "    with zipfile.ZipFile(zip_path, 'r') as zip_ref:\n",
    "        zip_ref.extractall(extract_to)\n",
    "    print(\"Unzipped successfully.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "7f2499d6",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-13T13:57:09.057399Z",
     "iopub.status.busy": "2025-05-13T13:57:09.057169Z",
     "iopub.status.idle": "2025-05-13T14:10:46.614670Z",
     "shell.execute_reply": "2025-05-13T14:10:46.613805Z"
    },
    "papermill": {
     "duration": 817.571159,
     "end_time": "2025-05-13T14:10:46.621596",
     "exception": false,
     "start_time": "2025-05-13T13:57:09.050437",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- CELL 1: DATA PREPARATION ---\n",
      "Loading PIE database cache …\n",
      "✓ PIE DB loaded.\n",
      "\n",
      "Computing scalers …\n",
      "Scalers: {'ego_speed_mean': 13.428368358531902, 'ego_speed_std': 13.306451814881573, 'accX_mean': -0.028068299916188515, 'accX_std': 0.07827638994593288, 'accY_mean': -0.5235171297788667, 'accY_std': 0.8514409917161664, 'gyroZ_mean': -0.037905654051963104, 'gyroZ_std': 4.475510697376237}\n",
      "\n",
      "Extracting training sequences (all streams) …\n",
      "Loading pose PKLs …\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "27c527f397854b9ab0b8072c3ac0987d",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "0it [00:00, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "4f2265fe6e654755a07f5fca0878ad0e",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "0it [00:00, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "610e1d52c7b14d96a94bdc217eec7558",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "0it [00:00, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Enumerating sequences …\n",
      "Total sequences: 333454\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "c1b99da5fc7b4fffb57ca6a3a527e009",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "seq:   0%|          | 0/333454 [00:00<?, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Raw training samples: 333454\n",
      "Balanced: 1s=54967 | 0s=54967\n",
      "\n",
      "Saving balanced data …\n",
      "✓ /kaggle/working/balanced_train_data.pkl\n",
      "Saving scalers …\n",
      "✓ /kaggle/working/scalers.pkl\n",
      "\n",
      "--- CELL 1: DATA PREPARATION COMPLETE ---\n"
     ]
    }
   ],
   "source": [
    "# -----------------------------------------------------------------------------\n",
    "# CELL 1: DATA PREPARATION & BALANCING  (run once before training)\n",
    "# -----------------------------------------------------------------------------\n",
    "#  This cell:\n",
    "#    1. Loads (or regenerates) the PIE database\n",
    "#    2. Computes per-signal standardisation scalers\n",
    "#    3. Extracts ALL training sequences for every stream\n",
    "#    4. Balances the dataset 50 / 50 on the crossing label\n",
    "#    5. Writes two pickles:\n",
    "#         - /kaggle/working/balanced_train_data.pkl\n",
    "#         - /kaggle/working/scalers.pkl\n",
    "# -----------------------------------------------------------------------------\n",
    "\n",
    "import os\n",
    "import sys\n",
    "import time\n",
    "import pickle\n",
    "import gc\n",
    "from pathlib import Path\n",
    "\n",
    "import cv2                               # used internally by PIE utilities\n",
    "import numpy as np\n",
    "import torch\n",
    "from torch.utils.data import Dataset\n",
    "from tqdm.notebook import tqdm\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                                PIE utilities                                 #\n",
    "# -----------------------------------------------------------------------------#\n",
    "pie_utilities_path = \"/kaggle/working/PIE/utilities\"\n",
    "if pie_utilities_path not in sys.path:\n",
    "    sys.path.insert(0, pie_utilities_path)\n",
    "\n",
    "try:\n",
    "    from pie_data import PIE\n",
    "except ImportError as e:\n",
    "    print(\n",
    "        f\"[WARN] Could not import PIE from {pie_utilities_path}. \"\n",
    "        f\"If the DB cache already exists this is fine.\\n→ {e}\"\n",
    "    )\n",
    "    PIE = None\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                              configuration                                   #\n",
    "# -----------------------------------------------------------------------------#\n",
    "PIE_ROOT_PATH           = \"/kaggle/working/PIE\"\n",
    "POSE_DATA_DIR           = \"/kaggle/input/pose-data/extracted_poses2\"\n",
    "PIE_DATABASE_CACHE_PATH = \"/kaggle/input/pie-database/pie_database.pkl\"\n",
    "\n",
    "TRAIN_SETS_STR = [\"set01\", \"set02\", \"set04\"]\n",
    "\n",
    "BALANCED_DATA_PKL_PATH  = \"/kaggle/working/balanced_train_data.pkl\"\n",
    "SCALERS_PKL_PATH        = \"/kaggle/working/scalers.pkl\"\n",
    "\n",
    "# Streams used throughout the project ----------------------------------------\n",
    "ALL_POSSIBLE_STREAMS = [\n",
    "    \"bbox\",\n",
    "    \"pose\",\n",
    "    \"ego_speed\",\n",
    "    \"ego_acc\",\n",
    "    \"ego_gyro\",\n",
    "    \"ped_action\",\n",
    "    \"ped_look\",\n",
    "    \"ped_occlusion\",\n",
    "    \"traffic_light\",\n",
    "    \"static_context\",\n",
    "]\n",
    "\n",
    "# Feature sizes & categorical constants --------------------------------------\n",
    "SEQ_LEN, PRED_LEN = 30, 1\n",
    "\n",
    "INPUT_SIZE_BBOX       = 4\n",
    "INPUT_SIZE_POSE       = 34\n",
    "INPUT_SIZE_EGO_SPEED  = 1\n",
    "INPUT_SIZE_EGO_ACC    = 2\n",
    "INPUT_SIZE_EGO_GYRO   = 1\n",
    "INPUT_SIZE_PED_ACTION = 1\n",
    "INPUT_SIZE_PED_LOOK   = 1\n",
    "INPUT_SIZE_PED_OCC    = 1\n",
    "INPUT_SIZE_TL_STATE   = 4\n",
    "\n",
    "NUM_SIGNALIZED_CATS   = 4\n",
    "NUM_INTERSECTION_CATS = 5\n",
    "NUM_AGE_CATS          = 4\n",
    "NUM_GENDER_CATS       = 3\n",
    "NUM_TRAFFIC_DIR_CATS  = 2\n",
    "\n",
    "LANE_CATEGORIES = {1: 0, 2: 1, 3: 2, 4: 3, 5: 4, 6: 4, 7: 4, 8: 4}\n",
    "NUM_LANE_CATS   = len(set(LANE_CATEGORIES.values()))\n",
    "\n",
    "INPUT_SIZE_STATIC = (\n",
    "    NUM_SIGNALIZED_CATS\n",
    "    + NUM_INTERSECTION_CATS\n",
    "    + NUM_AGE_CATS\n",
    "    + NUM_GENDER_CATS\n",
    "    + NUM_TRAFFIC_DIR_CATS\n",
    "    + NUM_LANE_CATS\n",
    ")  # → 23\n",
    "\n",
    "TL_STATE_MAP = {\"__undefined__\": 0, \"red\": 1, \"yellow\": 2, \"green\": 3}\n",
    "NUM_TL_STATES = len(TL_STATE_MAP)\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                               helper utils                                   #\n",
    "# -----------------------------------------------------------------------------#\n",
    "\n",
    "\n",
    "def to_one_hot(index: int, num_classes: int) -> np.ndarray:\n",
    "    vec = np.zeros(num_classes, dtype=np.float32)\n",
    "    vec[int(np.clip(index, 0, num_classes - 1))] = 1.0\n",
    "    return vec\n",
    "\n",
    "\n",
    "def balance_samples_count(seq_data: dict, label_key: str, seed: int = 42) -> dict:\n",
    "    \"\"\"Undersample majority class so positive and negative labels are equal.\"\"\"\n",
    "    labels = [lbl[0] for lbl in seq_data[label_key]]\n",
    "    n_pos  = int(np.sum(labels))\n",
    "    n_neg  = len(labels) - n_pos\n",
    "\n",
    "    if n_pos == n_neg:\n",
    "        print(\"Dataset already balanced.\")\n",
    "        return seq_data.copy()\n",
    "\n",
    "    majority_label    = 0 if n_neg > n_pos else 1\n",
    "    minority_count    = min(n_pos, n_neg)\n",
    "    majority_indices  = np.where(np.array(labels) == majority_label)[0]\n",
    "    minority_indices  = np.where(np.array(labels) != majority_label)[0]\n",
    "\n",
    "    rng = np.random.default_rng(seed)\n",
    "    keep_majority = rng.choice(majority_indices, size=minority_count, replace=False)\n",
    "    final_indices = np.concatenate([minority_indices, keep_majority])\n",
    "    rng.shuffle(final_indices)\n",
    "\n",
    "    balanced = {}\n",
    "    for k, v in seq_data.items():\n",
    "        balanced[k] = [v[i] for i in final_indices]\n",
    "\n",
    "    print(f\"Balanced: 1s={minority_count} | 0s={minority_count}\")\n",
    "    return balanced\n",
    "\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                                PIEDataset                                    #\n",
    "# -----------------------------------------------------------------------------#\n",
    "class PIEDataset(Dataset):\n",
    "    \"\"\"\n",
    "    Lightweight dataset that can generate any subset of the PIE feature streams.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(\n",
    "        self,\n",
    "        pie_db: dict,\n",
    "        set_names: list[str],\n",
    "        pose_dir: str,\n",
    "        seq_len: int,\n",
    "        pred_len: int,\n",
    "        scalers: dict,\n",
    "        streams_to_generate: list[str],\n",
    "    ):\n",
    "        self.pie_db            = pie_db\n",
    "        self.set_names         = set_names\n",
    "        self.pose_dir          = pose_dir\n",
    "        self.seq_len           = seq_len\n",
    "        self.pred_len          = pred_len\n",
    "        self.scalers           = scalers\n",
    "        self.streams           = streams_to_generate\n",
    "        self._input_sizes      = self._build_input_size_map()\n",
    "        self.all_pose_data     = {}\n",
    "        self.sequences         = []\n",
    "\n",
    "        if \"pose\" in self.streams:\n",
    "            self._load_pose_pkls()\n",
    "        self._enumerate_sequences()\n",
    "\n",
    "    # ------------------------ internal helpers -------------------------------\n",
    "    def _build_input_size_map(self) -> dict:\n",
    "        special = {\n",
    "            \"TRAFFIC_LIGHT\": \"TL_STATE\",\n",
    "            \"STATIC_CONTEXT\": \"STATIC\",\n",
    "            \"EGO_SPEED\": \"EGO_SPEED\",\n",
    "            \"EGO_ACC\": \"EGO_ACC\",\n",
    "            \"EGO_GYRO\": \"EGO_GYRO\",\n",
    "            \"PED_ACTION\": \"PED_ACTION\",\n",
    "            \"PED_LOOK\": \"PED_LOOK\",\n",
    "            \"PED_OCCLUSION\": \"PED_OCC\",\n",
    "        }\n",
    "        sizes = {}\n",
    "        for s in ALL_POSSIBLE_STREAMS:\n",
    "            const = f\"INPUT_SIZE_{special.get(s.upper(), s.upper())}\"\n",
    "            if s == \"bbox\":\n",
    "                const = \"INPUT_SIZE_BBOX\"\n",
    "            elif s == \"pose\":\n",
    "                const = \"INPUT_SIZE_POSE\"\n",
    "            sizes[s] = globals().get(const, 1)\n",
    "        return sizes\n",
    "\n",
    "    def _load_pose_pkls(self):\n",
    "        print(\"Loading pose PKLs …\")\n",
    "        for set_id in self.set_names:\n",
    "            set_dir = Path(self.pose_dir) / set_id\n",
    "            if not set_dir.is_dir():\n",
    "                continue\n",
    "            self.all_pose_data[set_id] = {}\n",
    "            for pkl_path in tqdm(set_dir.glob(f\"{set_id}_*_poses.pkl\"), leave=False):\n",
    "                try:\n",
    "                    with open(pkl_path, \"rb\") as fp:\n",
    "                        loaded = pickle.load(fp)\n",
    "                except Exception as e:\n",
    "                    print(f\"[pose load] {pkl_path}: {e}\")\n",
    "                    continue\n",
    "\n",
    "                if len(loaded) != 1:\n",
    "                    continue\n",
    "                (key, data), *_ = loaded.items()\n",
    "                vid = \"_\".join(key.split(\"_\")[1:])\n",
    "                if vid in self.pie_db.get(set_id, {}):\n",
    "                    self.all_pose_data[set_id][vid] = data\n",
    "\n",
    "    def _enumerate_sequences(self):\n",
    "        print(\"Enumerating sequences …\")\n",
    "        for set_id in self.set_names:\n",
    "            for vid, vdb in self.pie_db.get(set_id, {}).items():\n",
    "                for pid, pdb in vdb.get(\"ped_annotations\", {}).items():\n",
    "                    frames = pdb.get(\"frames\", [])\n",
    "                    if len(frames) < self.seq_len + self.pred_len:\n",
    "                        continue\n",
    "                    frames = sorted(frames)\n",
    "                    for i in range(len(frames) - self.seq_len - self.pred_len + 1):\n",
    "                        start = frames[i]\n",
    "                        obs_end = frames[i + self.seq_len - 1]\n",
    "                        if obs_end - start != self.seq_len - 1:\n",
    "                            continue\n",
    "                        target = frames[i + self.seq_len + self.pred_len - 1]\n",
    "                        if target - obs_end != self.pred_len:\n",
    "                            continue\n",
    "                        self.sequences.append((set_id, vid, pid, start))\n",
    "        print(f\"Total sequences: {len(self.sequences)}\")\n",
    "\n",
    "    # ------------------ Dataset API ------------------------------------------\n",
    "    def __len__(self):\n",
    "        return len(self.sequences)\n",
    "\n",
    "    def __getitem__(self, idx: int):\n",
    "        set_id, vid, pid, start = self.sequences[idx]\n",
    "        vdb  = self.pie_db[set_id][vid]\n",
    "        pdb  = vdb[\"ped_annotations\"][pid]\n",
    "        ego  = vdb.get(\"vehicle_annotations\", {})\n",
    "        tldb = vdb.get(\"traffic_annotations\", {})\n",
    "\n",
    "        frame_nums = list(range(start, start + self.seq_len))\n",
    "        target_f   = start + self.seq_len + self.pred_len - 1\n",
    "\n",
    "        # label ---------------------------------------------------------------\n",
    "        label = 0\n",
    "        if (\n",
    "            \"frames\" in pdb\n",
    "            and \"behavior\" in pdb\n",
    "            and \"cross\" in pdb[\"behavior\"]\n",
    "            and target_f in pdb[\"frames\"]\n",
    "        ):\n",
    "            try:\n",
    "                j = pdb[\"frames\"].index(target_f)\n",
    "                label = pdb[\"behavior\"][\"cross\"][j]\n",
    "                if label == -1:\n",
    "                    label = 0\n",
    "            except (ValueError, IndexError):\n",
    "                pass\n",
    "\n",
    "        # static context ------------------------------------------------------\n",
    "        static_vec = np.zeros(INPUT_SIZE_STATIC, np.float32)\n",
    "        if \"static_context\" in self.streams:\n",
    "            attr  = pdb.get(\"attributes\", {})\n",
    "            sig   = attr.get(\"signalized\", 0)\n",
    "            intr  = attr.get(\"intersection\", 0)\n",
    "            age   = attr.get(\"age\", 2)\n",
    "            gen   = attr.get(\"gender\", 0)\n",
    "            tdir  = int(attr.get(\"traffic_direction\", 0))\n",
    "            ln    = attr.get(\"num_lanes\", 2)\n",
    "            lncat = LANE_CATEGORIES.get(ln, LANE_CATEGORIES[max(LANE_CATEGORIES)])\n",
    "            static_vec = np.concatenate(\n",
    "                [\n",
    "                    to_one_hot(sig,  NUM_SIGNALIZED_CATS),\n",
    "                    to_one_hot(intr, NUM_INTERSECTION_CATS),\n",
    "                    to_one_hot(age,  NUM_AGE_CATS),\n",
    "                    to_one_hot(gen,  NUM_GENDER_CATS),\n",
    "                    to_one_hot(tdir, NUM_TRAFFIC_DIR_CATS),\n",
    "                    to_one_hot(lncat, NUM_LANE_CATS),\n",
    "                ]\n",
    "            ).astype(np.float32)\n",
    "\n",
    "        # per-frame feature assembly -----------------------------------------\n",
    "        feats = {s: [] for s in self.streams}\n",
    "\n",
    "        for fn in frame_nums:\n",
    "            fidx = -1\n",
    "            if \"frames\" in pdb:\n",
    "                try:\n",
    "                    fidx = pdb[\"frames\"].index(fn)\n",
    "                except ValueError:\n",
    "                    pass\n",
    "\n",
    "            ego_f = ego.get(fn, {})\n",
    "\n",
    "            # bbox ----------------------------------------------------------\n",
    "            if \"bbox\" in self.streams:\n",
    "                bb = np.zeros(INPUT_SIZE_BBOX, np.float32)\n",
    "                if (\n",
    "                    fidx != -1\n",
    "                    and \"bbox\" in pdb\n",
    "                    and len(pdb[\"bbox\"]) > fidx\n",
    "                ):\n",
    "                    try:\n",
    "                        x1, y1, x2, y2 = pdb[\"bbox\"][fidx]\n",
    "                        w_img = vdb.get(\"width\", 1920)\n",
    "                        h_img = vdb.get(\"height\", 1080)\n",
    "                        if w_img > 0 and h_img > 0:\n",
    "                            cx = ((x1 + x2) / 2) / w_img\n",
    "                            cy = ((y1 + y2) / 2) / h_img\n",
    "                            w  = (x2 - x1) / w_img\n",
    "                            h  = (y2 - y1) / h_img\n",
    "                            if 0 < w and 0 < h and 0 <= cx <= 1 and 0 <= cy <= 1:\n",
    "                                bb = np.array([cx, cy, w, h], np.float32)\n",
    "                    except Exception:\n",
    "                        pass\n",
    "                feats[\"bbox\"].append(bb)\n",
    "\n",
    "            # pose ----------------------------------------------------------\n",
    "            if \"pose\" in self.streams:\n",
    "                pvec = np.zeros(INPUT_SIZE_POSE, np.float32)\n",
    "                pose_set = self.all_pose_data.get(set_id, {}).get(vid, {})\n",
    "                p_loaded = pose_set.get(fn, {}).get(pid)\n",
    "                if (\n",
    "                    isinstance(p_loaded, np.ndarray)\n",
    "                    and p_loaded.shape == (INPUT_SIZE_POSE,)\n",
    "                ):\n",
    "                    pvec = p_loaded\n",
    "                feats[\"pose\"].append(pvec)\n",
    "\n",
    "            # ego signals ---------------------------------------------------\n",
    "            if \"ego_speed\" in self.streams:\n",
    "                s = ego_f.get(\"OBD_speed\", 0.0) or ego_f.get(\"GPS_speed\", 0.0)\n",
    "                s = (s - self.scalers.get(\"ego_speed_mean\", 0.0)) / self.scalers.get(\n",
    "                    \"ego_speed_std\", 1.0\n",
    "                )\n",
    "                feats[\"ego_speed\"].append([s])\n",
    "\n",
    "            if \"ego_acc\" in self.streams:\n",
    "                ax = ego_f.get(\"accX\", 0.0)\n",
    "                ay = ego_f.get(\"accY\", 0.0)\n",
    "                ax = (ax - self.scalers.get(\"accX_mean\", 0.0)) / self.scalers.get(\n",
    "                    \"accX_std\", 1.0\n",
    "                )\n",
    "                ay = (ay - self.scalers.get(\"accY_mean\", 0.0)) / self.scalers.get(\n",
    "                    \"accY_std\", 1.0\n",
    "                )\n",
    "                feats[\"ego_acc\"].append([ax, ay])\n",
    "\n",
    "            if \"ego_gyro\" in self.streams:\n",
    "                gz = ego_f.get(\"gyroZ\", 0.0)\n",
    "                gz = (gz - self.scalers.get(\"gyroZ_mean\", 0.0)) / self.scalers.get(\n",
    "                    \"gyroZ_std\", 1.0\n",
    "                )\n",
    "                feats[\"ego_gyro\"].append([gz])\n",
    "\n",
    "            # pedestrian behaviour -----------------------------------------\n",
    "            if \"ped_action\" in self.streams:\n",
    "                action = (\n",
    "                    pdb[\"behavior\"][\"action\"][fidx]\n",
    "                    if fidx != -1\n",
    "                    and \"behavior\" in pdb\n",
    "                    and \"action\" in pdb[\"behavior\"]\n",
    "                    and len(pdb[\"behavior\"][\"action\"]) > fidx\n",
    "                    else 0\n",
    "                )\n",
    "                feats[\"ped_action\"].append([float(action)])\n",
    "\n",
    "            if \"ped_look\" in self.streams:\n",
    "                look = (\n",
    "                    pdb[\"behavior\"][\"look\"][fidx]\n",
    "                    if fidx != -1\n",
    "                    and \"behavior\" in pdb\n",
    "                    and \"look\" in pdb[\"behavior\"]\n",
    "                    and len(pdb[\"behavior\"][\"look\"]) > fidx\n",
    "                    else 0\n",
    "                )\n",
    "                feats[\"ped_look\"].append([float(look)])\n",
    "\n",
    "            if \"ped_occlusion\" in self.streams:\n",
    "                occ = (\n",
    "                    float(pdb[\"occlusion\"][fidx]) / 2.0\n",
    "                    if fidx != -1\n",
    "                    and \"occlusion\" in pdb\n",
    "                    and len(pdb[\"occlusion\"]) > fidx\n",
    "                    else 0.0\n",
    "                )\n",
    "                feats[\"ped_occlusion\"].append([occ])\n",
    "\n",
    "            # traffic light -------------------------------------------------\n",
    "            if \"traffic_light\" in self.streams:\n",
    "                tl_state = 0\n",
    "                for obj in tldb.values():\n",
    "                    if obj.get(\"obj_class\") != \"traffic_light\":\n",
    "                        continue\n",
    "                    if \"frames\" not in obj or \"state\" not in obj:\n",
    "                        continue\n",
    "                    try:\n",
    "                        j = obj[\"frames\"].index(fn)\n",
    "                        if obj[\"state\"][j] != 0:\n",
    "                            tl_state = obj[\"state\"][j]\n",
    "                            break\n",
    "                    except (ValueError, IndexError):\n",
    "                        continue\n",
    "                feats[\"traffic_light\"].append(to_one_hot(tl_state, NUM_TL_STATES))\n",
    "\n",
    "            # static context -----------------------------------------------\n",
    "            if \"static_context\" in self.streams:\n",
    "                feats[\"static_context\"].append(static_vec)\n",
    "\n",
    "        # numpy → torch ------------------------------------------------------\n",
    "        out = {\n",
    "            s: torch.tensor(np.asarray(feats[s], np.float32), dtype=torch.float32)\n",
    "            for s in self.streams\n",
    "        }\n",
    "        return out, torch.tensor(label, dtype=torch.long)\n",
    "\n",
    "\n",
    "# =============================================================================\n",
    "#                       MAIN: build balanced training set\n",
    "# =============================================================================\n",
    "if __name__ == \"__main__\" and '__file__' not in globals(): # Avoid running this if imported\n",
    "    print(\"\\n--- CELL 1: DATA PREPARATION ---\")\n",
    "\n",
    "    # 1) load / regenerate PIE DB -------------------------------------------\n",
    "    cache = Path(PIE_DATABASE_CACHE_PATH)\n",
    "    if cache.is_file():\n",
    "        print(\"Loading PIE database cache …\")\n",
    "        with cache.open(\"rb\") as fp:\n",
    "            pie_db = pickle.load(fp)\n",
    "        print(\"✓ PIE DB loaded.\")\n",
    "    else:\n",
    "        if PIE is None:\n",
    "            raise RuntimeError(\"PIE class unavailable: cannot rebuild database.\")\n",
    "        print(\"Cache not found – regenerating PIE DB …\")\n",
    "        pie_db = PIE(data_path=PIE_ROOT_PATH, regen_database=True).generate_database()\n",
    "        if not pie_db:\n",
    "            raise RuntimeError(\"PIE DB generation failed.\")\n",
    "        print(\"✓ PIE DB generated.\")\n",
    "\n",
    "    # 2) compute scalers -----------------------------------------------------\n",
    "    print(\"\\nComputing scalers …\")\n",
    "    spd, accx, accy, gyz = [], [], [], []\n",
    "    for sid in TRAIN_SETS_STR:\n",
    "        for vid, vdb in pie_db.get(sid, {}).items():\n",
    "            for frame, e in vdb.get(\"vehicle_annotations\", {}).items():\n",
    "                s  = e.get(\"OBD_speed\", 0.0) or e.get(\"GPS_speed\", 0.0)\n",
    "                spd.append(s)\n",
    "                accx.append(e.get(\"accX\", 0.0))\n",
    "                accy.append(e.get(\"accY\", 0.0))\n",
    "                gyz.append(e.get(\"gyroZ\", 0.0))\n",
    "\n",
    "    scalers = {}\n",
    "    if spd:\n",
    "        scalers[\"ego_speed_mean\"] = float(np.mean(spd))\n",
    "        scalers[\"ego_speed_std\"]  = float(max(np.std(spd), 1e-6))\n",
    "    if accx:\n",
    "        scalers[\"accX_mean\"] = float(np.mean(accx))\n",
    "        scalers[\"accX_std\"]  = float(max(np.std(accx), 1e-6))\n",
    "        scalers[\"accY_mean\"] = float(np.mean(accy))\n",
    "        scalers[\"accY_std\"]  = float(max(np.std(accy), 1e-6))\n",
    "    if gyz:\n",
    "        scalers[\"gyroZ_mean\"] = float(np.mean(gyz))\n",
    "        scalers[\"gyroZ_std\"]  = float(max(np.std(gyz), 1e-6))\n",
    "\n",
    "    print(\"Scalers:\", scalers)\n",
    "\n",
    "    # 3) extract full training dataset --------------------------------------\n",
    "    print(\"\\nExtracting training sequences (all streams) …\")\n",
    "    full_ds = PIEDataset(\n",
    "        pie_db,\n",
    "        TRAIN_SETS_STR,\n",
    "        POSE_DATA_DIR,\n",
    "        SEQ_LEN,\n",
    "        PRED_LEN,\n",
    "        scalers,\n",
    "        ALL_POSSIBLE_STREAMS,\n",
    "    )\n",
    "\n",
    "    train_dict = {s: [] for s in ALL_POSSIBLE_STREAMS}\n",
    "    train_dict[\"label\"] = []\n",
    "\n",
    "    for i in tqdm(range(len(full_ds)), desc=\"seq\"):\n",
    "        feat, lbl = full_ds[i]\n",
    "        for s in ALL_POSSIBLE_STREAMS:\n",
    "            train_dict[s].append(feat[s].numpy())\n",
    "        train_dict[\"label\"].append([lbl.item()])\n",
    "\n",
    "    print(f\"Raw training samples: {len(train_dict['label'])}\")\n",
    "\n",
    "    # 4) balance -------------------------------------------------------------\n",
    "    balanced = balance_samples_count(train_dict, \"label\")\n",
    "    del train_dict, full_ds\n",
    "    gc.collect()\n",
    "\n",
    "    # 5) write pickles -------------------------------------------------------\n",
    "    print(\"\\nSaving balanced data …\")\n",
    "    with open(BALANCED_DATA_PKL_PATH, \"wb\") as fp:\n",
    "        pickle.dump(balanced, fp, pickle.HIGHEST_PROTOCOL)\n",
    "    print(f\"✓ {BALANCED_DATA_PKL_PATH}\")\n",
    "\n",
    "    print(\"Saving scalers …\")\n",
    "    with open(SCALERS_PKL_PATH, \"wb\") as fp:\n",
    "        pickle.dump(scalers, fp, pickle.HIGHEST_PROTOCOL)\n",
    "    print(f\"✓ {SCALERS_PKL_PATH}\")\n",
    "\n",
    "    del pie_db\n",
    "    gc.collect()\n",
    "\n",
    "    print(\"\\n--- CELL 1: DATA PREPARATION COMPLETE ---\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "0664383f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-13T14:10:46.642579Z",
     "iopub.status.busy": "2025-05-13T14:10:46.642310Z",
     "iopub.status.idle": "2025-05-13T17:03:36.782595Z",
     "shell.execute_reply": "2025-05-13T17:03:36.781371Z"
    },
    "papermill": {
     "duration": 10370.156211,
     "end_time": "2025-05-13T17:03:36.784615",
     "exception": false,
     "start_time": "2025-05-13T14:10:46.628404",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- CELL 1: Skipping data preparation, balanced data and scalers found. ---\n",
      "--- Running Weighted Average Fusion With Active Streams: ['bbox', 'ped_action', 'ped_look', 'ego_speed', 'ego_acc', 'static_context'] ---\n",
      "Using device: cuda\n",
      "--- CELL 2: Model Training, HPO, and Evaluation on Set03 ---\n",
      "Active Streams: ['bbox', 'ped_action', 'ped_look', 'ego_speed', 'ego_acc', 'static_context']\n",
      "\n",
      "Loading balanced training data, scalers, and PIE database …\n",
      "   ✓ Pre-processed data and PIE database loaded.\n",
      "\n",
      "Creating Datasets and DataLoaders …\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[I 2025-05-13 14:10:59,046] A new study created in memory with name: no-name-4c4a781e-1b1a-4d1f-98cd-cef9ab7efbdb\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "   ✓ Train DataLoader ready (109934 samples).\n",
      "   ✓ HPO Validation DataLoader ready (77288 samples for ['set05', 'set06']).\n",
      "\n",
      "--- Starting Hyperparameter Optimization (15 trials, 3 epochs/trial) ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "7b5f582d22754cd8af03d198b3a0d003",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "  0%|          | 0/15 [00:00<?, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[I 2025-05-13 14:22:42,162] Trial 0 finished with value: 0.7974195518570829 and parameters: {'lstm_hidden_size': 256, 'num_lstm_layers': 2, 'dropout_rate': 0.2, 'learning_rate': 7.160849144555769e-05, 'attention_dim': 128}. Best is trial 0 with value: 0.7974195518570829.\n",
      "[I 2025-05-13 14:34:26,035] Trial 1 finished with value: 0.788747433264887 and parameters: {'lstm_hidden_size': 256, 'num_lstm_layers': 2, 'dropout_rate': 0.5, 'learning_rate': 8.152843673110742e-05, 'attention_dim': 128}. Best is trial 0 with value: 0.7974195518570829.\n",
      "[I 2025-05-13 14:40:39,103] Trial 2 finished with value: 0.8193734152735398 and parameters: {'lstm_hidden_size': 256, 'num_lstm_layers': 1, 'dropout_rate': 0.4, 'learning_rate': 6.893882309676892e-05, 'attention_dim': 128}. Best is trial 2 with value: 0.8193734152735398.\n",
      "[I 2025-05-13 14:52:18,348] Trial 3 finished with value: 0.8126899858714732 and parameters: {'lstm_hidden_size': 256, 'num_lstm_layers': 2, 'dropout_rate': 0.4, 'learning_rate': 5.564426587452873e-05, 'attention_dim': 64}. Best is trial 2 with value: 0.8193734152735398.\n",
      "[I 2025-05-13 15:09:06,271] Trial 4 finished with value: 0.8001954476973819 and parameters: {'lstm_hidden_size': 384, 'num_lstm_layers': 2, 'dropout_rate': 0.30000000000000004, 'learning_rate': 6.260977143530197e-05, 'attention_dim': 64}. Best is trial 2 with value: 0.8193734152735398.\n",
      "[I 2025-05-13 15:20:54,198] Trial 5 pruned. \n",
      "[I 2025-05-13 15:38:09,690] Trial 6 finished with value: 0.820928283513589 and parameters: {'lstm_hidden_size': 384, 'num_lstm_layers': 2, 'dropout_rate': 0.5, 'learning_rate': 0.00039246176690796805, 'attention_dim': 128}. Best is trial 6 with value: 0.820928283513589.\n",
      "[I 2025-05-13 15:44:54,940] Trial 7 pruned. \n",
      "[I 2025-05-13 15:56:45,250] Trial 8 pruned. \n",
      "[I 2025-05-13 16:08:35,771] Trial 9 pruned. \n",
      "[I 2025-05-13 16:16:20,100] Trial 10 finished with value: 0.8065560335996722 and parameters: {'lstm_hidden_size': 384, 'num_lstm_layers': 1, 'dropout_rate': 0.5, 'learning_rate': 0.0004505569439185639, 'attention_dim': 128}. Best is trial 6 with value: 0.820928283513589.\n",
      "[I 2025-05-13 16:21:56,732] Trial 11 finished with value: 0.8247539589324046 and parameters: {'lstm_hidden_size': 128, 'num_lstm_layers': 1, 'dropout_rate': 0.4, 'learning_rate': 0.00015617600371455447, 'attention_dim': 128}. Best is trial 11 with value: 0.8247539589324046.\n",
      "[I 2025-05-13 16:27:21,624] Trial 12 pruned. \n",
      "[I 2025-05-13 16:32:50,249] Trial 13 pruned. \n",
      "[I 2025-05-13 16:40:25,672] Trial 14 pruned. \n",
      "\n",
      "--- Hyperparameter Optimization Finished (8966.63s) ---\n",
      "Best HPO F1 score on validation set (['set05', 'set06']): 0.8248\n",
      "Best hyperparameters found:\n",
      "  lstm_hidden_size: 128\n",
      "  num_lstm_layers: 1\n",
      "  dropout_rate: 0.4\n",
      "  learning_rate: 0.00015617600371455447\n",
      "  attention_dim: 128\n",
      "\n",
      "--- Training Final Model with Best Hyperparameters ---\n",
      "\n",
      "--- Final Model Architecture ---\n",
      "Trainable parameters in final model: 1,062,798\n",
      "\n",
      "Training final model for 5 epochs with LR=1.56e-04...\n",
      "  Epoch 01/5 – 184.4s | Train Loss: 0.3019 | Val HPO Loss: 0.2293 | Val HPO F1@0.5: 0.7550\n",
      "  Epoch 02/5 – 183.9s | Train Loss: 0.2262 | Val HPO Loss: 0.2530 | Val HPO F1@0.5: 0.7507\n",
      "  Epoch 03/5 – 177.3s | Train Loss: 0.2044 | Val HPO Loss: 0.2580 | Val HPO F1@0.5: 0.7398\n",
      "  Epoch 04/5 – 169.6s | Train Loss: 0.1935 | Val HPO Loss: 0.2248 | Val HPO F1@0.5: 0.7672\n",
      "  Epoch 05/5 – 168.2s | Train Loss: 0.1864 | Val HPO Loss: 0.1789 | Val HPO F1@0.5: 0.8011\n",
      "\n",
      "--- Final Evaluation on Test Set (['set03']) ---\n",
      "   ✓ Test DataLoader ready (271078 samples for ['set03']).\n",
      "\n",
      "--- Final Metrics on Test Set (set03) with Tuned Threshold ---\n",
      "Optimal Threshold on Set03    : 0.7600\n",
      "F1-score (Maximized on Set03) : 0.7166\n",
      "Accuracy                      : 0.8962\n",
      "Precision                     : 0.7217\n",
      "Recall                        : 0.7115\n",
      "AUC                           : 0.9332\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 640x480 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Learned Fusion Weights (Final Model) ---\n",
      "bbox                : 0.1774\n",
      "ped_action          : 0.1699\n",
      "ped_look            : 0.1539\n",
      "ego_speed           : 0.1623\n",
      "ego_acc             : 0.1659\n",
      "static_context      : 0.1706\n",
      "------------------------------\n"
     ]
    },
    {
     "data": {
      "image/png": "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d275Bn4ZLifXxx9/3KhRo4bh5uZmhIaGGjfddJOxfv368g/+Eg0bNsyIiooy3NzcjKpVqxqdO3cummQYhuNcU8O49Fwr6zU9l79PNBzpuv7dhXKtrNe1X79+RrVq1Qw3NzejevXqRr9+/Yw9e/YUve/I19TZOMscylnmT4ahOZQjzqE0f3KO+ZNhOM8cylHnT4ZReeZQFsMwjNJffyUiIiIiIiIiInJ+6iklIiIiIiIiIiLlTkUpEREREREREREpdypKiYiIiIiIiIhIuVNRSkREREREREREyp2KUiIiIiIiIiIiUu5UlBIRERERERERkXKnopSIiIiIiIiIiJQ7FaVERERERERERKTcqSglIlLKLBYL3377rdlhiIiIiFQamj+JOCcVpUTEodx9991YLJYSXz169DA7NBEREZEKSfMnETGLi9kBiIiUth49ejBlypRix9zd3U2KRkRERKTi0/xJRMyglVIi4nDc3d0JCwsr9lWlShXAvjR8woQJ3HjjjXh6elKrVi2++uqrYp/fsmULN9xwA56engQFBXH//feTlZVV7JzJkyfTqFEj3N3dqVatGiNGjCj2/pEjR7j99tvx8vKiTp06fP/992WbtIiIiMgV0PxJRMygopSIOJ3nn3+ePn36sGnTJgYOHEj//v3Zvn07ANnZ2XTv3p0qVaqwdu1aZs+ezaJFi4pNmiZMmMDDDz/M/fffz5YtW/j++++JiYkp9nu89NJL9O3bl82bN3PTTTcxcOBAjh07Vq55ioiIiJQWzZ9EpEwYIiIOZOjQoYbNZjO8vb2Lfb322muGYRgGYPzrX/8q9pm2bdsaDz74oGEYhvHxxx8bVapUMbKysorenzt3rmG1Wo3k5GTDMAwjPDzceO65584bA2D897//LXqdlZVlAMbPP/9canmKiIiIlBbNn0TELOopJSIO5/rrr2fChAnFjgUGBhb9un379sXea9++PRs3bgRg+/btNGvWDG9v76L3O3bsSGFhITt37sRisXDo0CE6d+78jzE0bdq06Nfe3t74+fmRmpp6uSmJiIiIlCnNn0TEDCpKiYjD8fb2LrEcvLR4enpe1Hmurq7FXlssFgoLC8siJBEREZErpvmTiJhBPaVExOmsWrWqxOsGDRoA0KBBAzZt2kR2dnbR+8uXL8dqtVKvXj18fX2Jjo5m8eLF5RqziIiIiJk0fxKRsqCVUiLicPLy8khOTi52zMXFheDgYABmz55Nq1atuPrqq5kxYwZr1qwhNjYWgIEDBzJ69GiGDh3Kiy++yOHDh3nkkUcYPHgwoaGhALz44ov861//IiQkhBtvvJHMzEyWL1/OI488Ur6JioiIiJQSzZ9ExAwqSomIw5k3bx7VqlUrdqxevXrs2LEDsO/sMmvWLB566CGqVavG559/TsOGDQHw8vJi/vz5PPbYY7Ru3RovLy/69OnDW2+9VTTW0KFDyc3N5e233+bf//43wcHB3HHHHeWXoIiIiEgp0/xJRMxgMQzDMDsIEZHyYrFY+Oabb+jVq5fZoYiIiIhUCpo/iUhZUU8pEREREREREREpdypKiYiIiIiIiIhIudPjeyIiIiIiIiIiUu60UkpERERERERERMqdilIiIiIiIiIiIlLuVJQSEREREREREZFyp6KUiIiIiIiIiIiUOxWlRERERERERESk3KkoJSIiIiIiIiIi5U5FKRERERERERERKXcqSomIiIiIiIiISLlTUUpERERERERERMrd/wN6S50HedSUzwAAAABJRU5ErkJggg==\n",
      "text/plain": [
       "<Figure size 1200x400 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- CELL 2: Script complete ---\n"
     ]
    }
   ],
   "source": [
    "# -----------------------------------------------------------------------------\n",
    "# CELL 1: DATA PREPARATION & BALANCING  (run once before training)\n",
    "# -----------------------------------------------------------------------------\n",
    "#  This cell:\n",
    "#    1. Loads (or regenerates) the PIE database\n",
    "#    2. Computes per-signal standardisation scalers\n",
    "#    3. Extracts ALL training sequences for every stream\n",
    "#    4. Balances the dataset 50 / 50 on the crossing label\n",
    "#    5. Writes two pickles:\n",
    "#         - /kaggle/working/balanced_train_data.pkl\n",
    "#         - /kaggle/working/scalers.pkl\n",
    "# -----------------------------------------------------------------------------\n",
    "\n",
    "import os\n",
    "import sys\n",
    "import time\n",
    "import pickle\n",
    "import gc\n",
    "from pathlib import Path\n",
    "\n",
    "import cv2                               # used internally by PIE utilities\n",
    "import numpy as np\n",
    "import torch\n",
    "from torch.utils.data import Dataset\n",
    "from tqdm.notebook import tqdm\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                                PIE utilities                                 #\n",
    "# -----------------------------------------------------------------------------#\n",
    "pie_utilities_path = \"/kaggle/working/PIE/utilities\"\n",
    "if pie_utilities_path not in sys.path:\n",
    "    sys.path.insert(0, pie_utilities_path)\n",
    "\n",
    "try:\n",
    "    from pie_data import PIE\n",
    "except ImportError as e:\n",
    "    print(\n",
    "        f\"[WARN] Could not import PIE from {pie_utilities_path}. \"\n",
    "        f\"If the DB cache already exists this is fine.\\n→ {e}\"\n",
    "    )\n",
    "    PIE = None\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                              configuration                                   #\n",
    "# -----------------------------------------------------------------------------#\n",
    "PIE_ROOT_PATH           = \"/kaggle/working/PIE\"\n",
    "POSE_DATA_DIR           = \"/kaggle/input/pose-data/extracted_poses2\"\n",
    "PIE_DATABASE_CACHE_PATH = \"/kaggle/input/pie-database/pie_database.pkl\"\n",
    "\n",
    "TRAIN_SETS_STR = [\"set01\", \"set02\", \"set04\"] # Used for generating training data and scalers\n",
    "\n",
    "BALANCED_DATA_PKL_PATH  = \"/kaggle/working/balanced_train_data.pkl\"\n",
    "SCALERS_PKL_PATH        = \"/kaggle/working/scalers.pkl\"\n",
    "\n",
    "# Streams used throughout the project ----------------------------------------\n",
    "ALL_POSSIBLE_STREAMS = [\n",
    "    \"bbox\",\n",
    "    \"pose\",\n",
    "    \"ego_speed\",\n",
    "    \"ego_acc\",\n",
    "    \"ego_gyro\",\n",
    "    \"ped_action\",\n",
    "    \"ped_look\",\n",
    "    \"ped_occlusion\",\n",
    "    \"traffic_light\",\n",
    "    \"static_context\",\n",
    "]\n",
    "\n",
    "# Feature sizes & categorical constants --------------------------------------\n",
    "SEQ_LEN, PRED_LEN = 30, 1\n",
    "\n",
    "INPUT_SIZE_BBOX       = 4\n",
    "INPUT_SIZE_POSE       = 34\n",
    "INPUT_SIZE_EGO_SPEED  = 1\n",
    "INPUT_SIZE_EGO_ACC    = 2\n",
    "INPUT_SIZE_EGO_GYRO   = 1\n",
    "INPUT_SIZE_PED_ACTION = 1\n",
    "INPUT_SIZE_PED_LOOK   = 1\n",
    "INPUT_SIZE_PED_OCC    = 1\n",
    "INPUT_SIZE_TL_STATE   = 4\n",
    "\n",
    "NUM_SIGNALIZED_CATS   = 4\n",
    "NUM_INTERSECTION_CATS = 5\n",
    "NUM_AGE_CATS          = 4\n",
    "NUM_GENDER_CATS       = 3\n",
    "NUM_TRAFFIC_DIR_CATS  = 2\n",
    "\n",
    "LANE_CATEGORIES = {1: 0, 2: 1, 3: 2, 4: 3, 5: 4, 6: 4, 7: 4, 8: 4}\n",
    "NUM_LANE_CATS   = len(set(LANE_CATEGORIES.values()))\n",
    "\n",
    "INPUT_SIZE_STATIC = (\n",
    "    NUM_SIGNALIZED_CATS\n",
    "    + NUM_INTERSECTION_CATS\n",
    "    + NUM_AGE_CATS\n",
    "    + NUM_GENDER_CATS\n",
    "    + NUM_TRAFFIC_DIR_CATS\n",
    "    + NUM_LANE_CATS\n",
    ")  # → 23\n",
    "\n",
    "TL_STATE_MAP = {\"__undefined__\": 0, \"red\": 1, \"yellow\": 2, \"green\": 3}\n",
    "NUM_TL_STATES = len(TL_STATE_MAP)\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                               helper utils                                   #\n",
    "# -----------------------------------------------------------------------------#\n",
    "\n",
    "\n",
    "def to_one_hot(index: int, num_classes: int) -> np.ndarray:\n",
    "    vec = np.zeros(num_classes, dtype=np.float32)\n",
    "    vec[int(np.clip(index, 0, num_classes - 1))] = 1.0\n",
    "    return vec\n",
    "\n",
    "\n",
    "def balance_samples_count(seq_data: dict, label_key: str, seed: int = 42) -> dict:\n",
    "    \"\"\"Undersample majority class so positive and negative labels are equal.\"\"\"\n",
    "    labels = [lbl[0] for lbl in seq_data[label_key]]\n",
    "    n_pos  = int(np.sum(labels))\n",
    "    n_neg  = len(labels) - n_pos\n",
    "\n",
    "    if n_pos == n_neg:\n",
    "        print(\"Dataset already balanced.\")\n",
    "        return seq_data.copy()\n",
    "\n",
    "    majority_label    = 0 if n_neg > n_pos else 1\n",
    "    minority_count    = min(n_pos, n_neg)\n",
    "    majority_indices  = np.where(np.array(labels) == majority_label)[0]\n",
    "    minority_indices  = np.where(np.array(labels) != majority_label)[0]\n",
    "\n",
    "    rng = np.random.default_rng(seed)\n",
    "    keep_majority = rng.choice(majority_indices, size=minority_count, replace=False)\n",
    "    final_indices = np.concatenate([minority_indices, keep_majority])\n",
    "    rng.shuffle(final_indices)\n",
    "\n",
    "    balanced = {}\n",
    "    for k, v in seq_data.items():\n",
    "        balanced[k] = [v[i] for i in final_indices]\n",
    "\n",
    "    print(f\"Balanced: 1s={minority_count} | 0s={minority_count}\")\n",
    "    return balanced\n",
    "\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                                PIEDataset                                    #\n",
    "# -----------------------------------------------------------------------------#\n",
    "class PIEDataset(Dataset):\n",
    "    \"\"\"\n",
    "    Lightweight dataset that can generate any subset of the PIE feature streams.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(\n",
    "        self,\n",
    "        pie_db: dict,\n",
    "        set_names: list[str],\n",
    "        pose_dir: str,\n",
    "        seq_len: int,\n",
    "        pred_len: int,\n",
    "        scalers: dict,\n",
    "        streams_to_generate: list[str],\n",
    "    ):\n",
    "        self.pie_db            = pie_db\n",
    "        self.set_names         = set_names\n",
    "        self.pose_dir          = pose_dir\n",
    "        self.seq_len           = seq_len\n",
    "        self.pred_len          = pred_len\n",
    "        self.scalers           = scalers\n",
    "        self.streams           = streams_to_generate\n",
    "        self._input_sizes      = self._build_input_size_map()\n",
    "        self.all_pose_data     = {}\n",
    "        self.sequences         = []\n",
    "\n",
    "        if \"pose\" in self.streams:\n",
    "            self._load_pose_pkls()\n",
    "        self._enumerate_sequences()\n",
    "\n",
    "    # ------------------------ internal helpers -------------------------------\n",
    "    def _build_input_size_map(self) -> dict:\n",
    "        special = {\n",
    "            \"TRAFFIC_LIGHT\": \"TL_STATE\",\n",
    "            \"STATIC_CONTEXT\": \"STATIC\",\n",
    "            \"EGO_SPEED\": \"EGO_SPEED\",\n",
    "            \"EGO_ACC\": \"EGO_ACC\",\n",
    "            \"EGO_GYRO\": \"EGO_GYRO\",\n",
    "            \"PED_ACTION\": \"PED_ACTION\",\n",
    "            \"PED_LOOK\": \"PED_LOOK\",\n",
    "            \"PED_OCCLUSION\": \"PED_OCC\",\n",
    "        }\n",
    "        sizes = {}\n",
    "        for s in ALL_POSSIBLE_STREAMS:\n",
    "            const = f\"INPUT_SIZE_{special.get(s.upper(), s.upper())}\"\n",
    "            if s == \"bbox\":\n",
    "                const = \"INPUT_SIZE_BBOX\"\n",
    "            elif s == \"pose\":\n",
    "                const = \"INPUT_SIZE_POSE\"\n",
    "            sizes[s] = globals().get(const, 1)\n",
    "        return sizes\n",
    "\n",
    "    def _load_pose_pkls(self):\n",
    "        print(f\"Loading pose PKLs for sets {self.set_names} (streams: {self.streams})…\")\n",
    "        for set_id in self.set_names:\n",
    "            set_dir = Path(self.pose_dir) / set_id\n",
    "            if not set_dir.is_dir():\n",
    "                print(f\"Warning: Pose directory not found for set {set_id}: {set_dir}\")\n",
    "                continue\n",
    "            self.all_pose_data[set_id] = {}\n",
    "            # Use tqdm only if there are files to process\n",
    "            pkl_files = list(set_dir.glob(f\"{set_id}_*_poses.pkl\"))\n",
    "            if not pkl_files:\n",
    "                print(f\"No pose PKL files found in {set_dir} matching pattern.\")\n",
    "                continue\n",
    "\n",
    "            for pkl_path in tqdm(pkl_files, desc=f\"Loading poses {set_id}\", leave=False):\n",
    "                try:\n",
    "                    with open(pkl_path, \"rb\") as fp:\n",
    "                        loaded = pickle.load(fp)\n",
    "                except Exception as e:\n",
    "                    print(f\"[pose load] {pkl_path}: {e}\")\n",
    "                    continue\n",
    "\n",
    "                if len(loaded) != 1:\n",
    "                    continue\n",
    "                (key, data), *_ = loaded.items()\n",
    "                vid = \"_\".join(key.split(\"_\")[1:])\n",
    "                if vid in self.pie_db.get(set_id, {}):\n",
    "                    self.all_pose_data[set_id][vid] = data\n",
    "\n",
    "    def _enumerate_sequences(self):\n",
    "        print(f\"Enumerating sequences for sets {self.set_names}…\")\n",
    "        for set_id in self.set_names:\n",
    "            for vid, vdb in self.pie_db.get(set_id, {}).items():\n",
    "                for pid, pdb in vdb.get(\"ped_annotations\", {}).items():\n",
    "                    frames = pdb.get(\"frames\", [])\n",
    "                    if len(frames) < self.seq_len + self.pred_len:\n",
    "                        continue\n",
    "                    frames = sorted(frames)\n",
    "                    for i in range(len(frames) - self.seq_len - self.pred_len + 1):\n",
    "                        start = frames[i]\n",
    "                        obs_end = frames[i + self.seq_len - 1]\n",
    "                        if obs_end - start != self.seq_len - 1:\n",
    "                            continue\n",
    "                        target = frames[i + self.seq_len + self.pred_len - 1]\n",
    "                        if target - obs_end != self.pred_len:\n",
    "                            continue\n",
    "                        self.sequences.append((set_id, vid, pid, start))\n",
    "        print(f\"Total sequences for {self.set_names}: {len(self.sequences)}\")\n",
    "\n",
    "    # ------------------ Dataset API ------------------------------------------\n",
    "    def __len__(self):\n",
    "        return len(self.sequences)\n",
    "\n",
    "    def __getitem__(self, idx: int):\n",
    "        set_id, vid, pid, start = self.sequences[idx]\n",
    "        vdb  = self.pie_db[set_id][vid]\n",
    "        pdb  = vdb[\"ped_annotations\"][pid]\n",
    "        ego  = vdb.get(\"vehicle_annotations\", {})\n",
    "        tldb = vdb.get(\"traffic_annotations\", {})\n",
    "\n",
    "        frame_nums = list(range(start, start + self.seq_len))\n",
    "        target_f   = start + self.seq_len + self.pred_len - 1\n",
    "\n",
    "        # label ---------------------------------------------------------------\n",
    "        label = 0\n",
    "        if (\n",
    "            \"frames\" in pdb\n",
    "            and \"behavior\" in pdb\n",
    "            and \"cross\" in pdb[\"behavior\"]\n",
    "            and target_f in pdb[\"frames\"]\n",
    "        ):\n",
    "            try:\n",
    "                j = pdb[\"frames\"].index(target_f)\n",
    "                label = pdb[\"behavior\"][\"cross\"][j]\n",
    "                if label == -1:\n",
    "                    label = 0\n",
    "            except (ValueError, IndexError):\n",
    "                pass\n",
    "\n",
    "        # static context ------------------------------------------------------\n",
    "        static_vec = np.zeros(INPUT_SIZE_STATIC, np.float32)\n",
    "        if \"static_context\" in self.streams:\n",
    "            attr  = pdb.get(\"attributes\", {})\n",
    "            sig   = attr.get(\"signalized\", 0)\n",
    "            intr  = attr.get(\"intersection\", 0)\n",
    "            age   = attr.get(\"age\", 2)\n",
    "            gen   = attr.get(\"gender\", 0)\n",
    "            tdir  = int(attr.get(\"traffic_direction\", 0))\n",
    "            ln    = attr.get(\"num_lanes\", 2)\n",
    "            lncat = LANE_CATEGORIES.get(ln, LANE_CATEGORIES[max(LANE_CATEGORIES)])\n",
    "            static_vec = np.concatenate(\n",
    "                [\n",
    "                    to_one_hot(sig,  NUM_SIGNALIZED_CATS),\n",
    "                    to_one_hot(intr, NUM_INTERSECTION_CATS),\n",
    "                    to_one_hot(age,  NUM_AGE_CATS),\n",
    "                    to_one_hot(gen,  NUM_GENDER_CATS),\n",
    "                    to_one_hot(tdir, NUM_TRAFFIC_DIR_CATS),\n",
    "                    to_one_hot(lncat, NUM_LANE_CATS),\n",
    "                ]\n",
    "            ).astype(np.float32)\n",
    "\n",
    "        # per-frame feature assembly -----------------------------------------\n",
    "        feats = {s: [] for s in self.streams}\n",
    "\n",
    "        for fn in frame_nums:\n",
    "            fidx = -1\n",
    "            if \"frames\" in pdb:\n",
    "                try:\n",
    "                    fidx = pdb[\"frames\"].index(fn)\n",
    "                except ValueError:\n",
    "                    pass\n",
    "\n",
    "            ego_f = ego.get(fn, {})\n",
    "\n",
    "            # bbox ----------------------------------------------------------\n",
    "            if \"bbox\" in self.streams:\n",
    "                bb = np.zeros(INPUT_SIZE_BBOX, np.float32)\n",
    "                if (\n",
    "                    fidx != -1\n",
    "                    and \"bbox\" in pdb\n",
    "                    and len(pdb[\"bbox\"]) > fidx\n",
    "                ):\n",
    "                    try:\n",
    "                        x1, y1, x2, y2 = pdb[\"bbox\"][fidx]\n",
    "                        w_img = vdb.get(\"width\", 1920)\n",
    "                        h_img = vdb.get(\"height\", 1080)\n",
    "                        if w_img > 0 and h_img > 0:\n",
    "                            cx = ((x1 + x2) / 2) / w_img\n",
    "                            cy = ((y1 + y2) / 2) / h_img\n",
    "                            w  = (x2 - x1) / w_img\n",
    "                            h  = (y2 - y1) / h_img\n",
    "                            if 0 < w and 0 < h and 0 <= cx <= 1 and 0 <= cy <= 1:\n",
    "                                bb = np.array([cx, cy, w, h], np.float32)\n",
    "                    except Exception:\n",
    "                        pass\n",
    "                feats[\"bbox\"].append(bb)\n",
    "\n",
    "            # pose ----------------------------------------------------------\n",
    "            if \"pose\" in self.streams:\n",
    "                pvec = np.zeros(INPUT_SIZE_POSE, np.float32)\n",
    "                pose_set = self.all_pose_data.get(set_id, {}).get(vid, {})\n",
    "                p_loaded = pose_set.get(fn, {}).get(pid)\n",
    "                if (\n",
    "                    isinstance(p_loaded, np.ndarray)\n",
    "                    and p_loaded.shape == (INPUT_SIZE_POSE,)\n",
    "                ):\n",
    "                    pvec = p_loaded\n",
    "                feats[\"pose\"].append(pvec)\n",
    "\n",
    "            # ego signals ---------------------------------------------------\n",
    "            if \"ego_speed\" in self.streams:\n",
    "                s = ego_f.get(\"OBD_speed\", 0.0) or ego_f.get(\"GPS_speed\", 0.0)\n",
    "                s = (s - self.scalers.get(\"ego_speed_mean\", 0.0)) / self.scalers.get(\n",
    "                    \"ego_speed_std\", 1.0\n",
    "                )\n",
    "                feats[\"ego_speed\"].append([s])\n",
    "\n",
    "            if \"ego_acc\" in self.streams:\n",
    "                ax = ego_f.get(\"accX\", 0.0)\n",
    "                ay = ego_f.get(\"accY\", 0.0)\n",
    "                ax = (ax - self.scalers.get(\"accX_mean\", 0.0)) / self.scalers.get(\n",
    "                    \"accX_std\", 1.0\n",
    "                )\n",
    "                ay = (ay - self.scalers.get(\"accY_mean\", 0.0)) / self.scalers.get(\n",
    "                    \"accY_std\", 1.0\n",
    "                )\n",
    "                feats[\"ego_acc\"].append([ax, ay])\n",
    "\n",
    "            if \"ego_gyro\" in self.streams:\n",
    "                gz = ego_f.get(\"gyroZ\", 0.0)\n",
    "                gz = (gz - self.scalers.get(\"gyroZ_mean\", 0.0)) / self.scalers.get(\n",
    "                    \"gyroZ_std\", 1.0\n",
    "                )\n",
    "                feats[\"ego_gyro\"].append([gz])\n",
    "\n",
    "            # pedestrian behaviour -----------------------------------------\n",
    "            if \"ped_action\" in self.streams:\n",
    "                action = (\n",
    "                    pdb[\"behavior\"][\"action\"][fidx]\n",
    "                    if fidx != -1\n",
    "                    and \"behavior\" in pdb\n",
    "                    and \"action\" in pdb[\"behavior\"]\n",
    "                    and len(pdb[\"behavior\"][\"action\"]) > fidx\n",
    "                    else 0\n",
    "                )\n",
    "                feats[\"ped_action\"].append([float(action)])\n",
    "\n",
    "            if \"ped_look\" in self.streams:\n",
    "                look = (\n",
    "                    pdb[\"behavior\"][\"look\"][fidx]\n",
    "                    if fidx != -1\n",
    "                    and \"behavior\" in pdb\n",
    "                    and \"look\" in pdb[\"behavior\"]\n",
    "                    and len(pdb[\"behavior\"][\"look\"]) > fidx\n",
    "                    else 0\n",
    "                )\n",
    "                feats[\"ped_look\"].append([float(look)])\n",
    "\n",
    "            if \"ped_occlusion\" in self.streams:\n",
    "                occ = (\n",
    "                    float(pdb[\"occlusion\"][fidx]) / 2.0\n",
    "                    if fidx != -1\n",
    "                    and \"occlusion\" in pdb\n",
    "                    and len(pdb[\"occlusion\"]) > fidx\n",
    "                    else 0.0\n",
    "                )\n",
    "                feats[\"ped_occlusion\"].append([occ])\n",
    "\n",
    "            # traffic light -------------------------------------------------\n",
    "            if \"traffic_light\" in self.streams:\n",
    "                tl_state = 0\n",
    "                for obj in tldb.values():\n",
    "                    if obj.get(\"obj_class\") != \"traffic_light\":\n",
    "                        continue\n",
    "                    if \"frames\" not in obj or \"state\" not in obj:\n",
    "                        continue\n",
    "                    try:\n",
    "                        j = obj[\"frames\"].index(fn)\n",
    "                        if obj[\"state\"][j] != 0:\n",
    "                            tl_state = obj[\"state\"][j]\n",
    "                            break\n",
    "                    except (ValueError, IndexError):\n",
    "                        continue\n",
    "                feats[\"traffic_light\"].append(to_one_hot(tl_state, NUM_TL_STATES))\n",
    "\n",
    "            # static context -----------------------------------------------\n",
    "            if \"static_context\" in self.streams:\n",
    "                feats[\"static_context\"].append(static_vec)\n",
    "\n",
    "        # numpy → torch ------------------------------------------------------\n",
    "        out = {\n",
    "            s: torch.tensor(np.asarray(feats[s], np.float32), dtype=torch.float32)\n",
    "            for s in self.streams\n",
    "        }\n",
    "        return out, torch.tensor(label, dtype=torch.long)\n",
    "\n",
    "\n",
    "# =============================================================================\n",
    "#                       MAIN: build balanced training set (Cell 1)\n",
    "# =============================================================================\n",
    "if __name__ == \"__main__\" and '__file__' not in globals() and not Path(BALANCED_DATA_PKL_PATH).exists(): # Avoid re-running if files exist\n",
    "    print(\"\\n--- CELL 1: DATA PREPARATION (Running because balanced data not found) ---\")\n",
    "\n",
    "    # 1) load / regenerate PIE DB -------------------------------------------\n",
    "    cache = Path(PIE_DATABASE_CACHE_PATH)\n",
    "    if cache.is_file():\n",
    "        print(\"Loading PIE database cache …\")\n",
    "        with cache.open(\"rb\") as fp:\n",
    "            pie_db_cell1 = pickle.load(fp) # Use a different variable name\n",
    "        print(\"✓ PIE DB loaded.\")\n",
    "    else:\n",
    "        if PIE is None:\n",
    "            raise RuntimeError(\"PIE class unavailable: cannot rebuild database.\")\n",
    "        print(\"Cache not found – regenerating PIE DB …\")\n",
    "        pie_db_cell1 = PIE(data_path=PIE_ROOT_PATH, regen_database=True).generate_database()\n",
    "        if not pie_db_cell1:\n",
    "            raise RuntimeError(\"PIE DB generation failed.\")\n",
    "        print(\"✓ PIE DB generated.\")\n",
    "\n",
    "    # 2) compute scalers -----------------------------------------------------\n",
    "    print(\"\\nComputing scalers …\")\n",
    "    spd, accx, accy, gyz = [], [], [], []\n",
    "    for sid in TRAIN_SETS_STR: # Use TRAIN_SETS_STR for scalers\n",
    "        for vid, vdb in pie_db_cell1.get(sid, {}).items():\n",
    "            for frame, e in vdb.get(\"vehicle_annotations\", {}).items():\n",
    "                s  = e.get(\"OBD_speed\", 0.0) or e.get(\"GPS_speed\", 0.0)\n",
    "                spd.append(s)\n",
    "                accx.append(e.get(\"accX\", 0.0))\n",
    "                accy.append(e.get(\"accY\", 0.0))\n",
    "                gyz.append(e.get(\"gyroZ\", 0.0))\n",
    "\n",
    "    scalers_cell1 = {} # Use a different variable name\n",
    "    if spd:\n",
    "        scalers_cell1[\"ego_speed_mean\"] = float(np.mean(spd))\n",
    "        scalers_cell1[\"ego_speed_std\"]  = float(max(np.std(spd), 1e-6))\n",
    "    if accx:\n",
    "        scalers_cell1[\"accX_mean\"] = float(np.mean(accx))\n",
    "        scalers_cell1[\"accX_std\"]  = float(max(np.std(accx), 1e-6))\n",
    "        scalers_cell1[\"accY_mean\"] = float(np.mean(accy))\n",
    "        scalers_cell1[\"accY_std\"]  = float(max(np.std(accy), 1e-6))\n",
    "    if gyz:\n",
    "        scalers_cell1[\"gyroZ_mean\"] = float(np.mean(gyz))\n",
    "        scalers_cell1[\"gyroZ_std\"]  = float(max(np.std(gyz), 1e-6))\n",
    "\n",
    "    print(\"Scalers:\", scalers_cell1)\n",
    "\n",
    "    # 3) extract full training dataset --------------------------------------\n",
    "    print(\"\\nExtracting training sequences (all streams) …\")\n",
    "    full_ds = PIEDataset(\n",
    "        pie_db_cell1,\n",
    "        TRAIN_SETS_STR, # Use TRAIN_SETS_STR for training data extraction\n",
    "        POSE_DATA_DIR,\n",
    "        SEQ_LEN,\n",
    "        PRED_LEN,\n",
    "        scalers_cell1,\n",
    "        ALL_POSSIBLE_STREAMS,\n",
    "    )\n",
    "\n",
    "    train_dict = {s: [] for s in ALL_POSSIBLE_STREAMS}\n",
    "    train_dict[\"label\"] = []\n",
    "\n",
    "    for i in tqdm(range(len(full_ds)), desc=\"seq\"):\n",
    "        feat, lbl = full_ds[i]\n",
    "        for s in ALL_POSSIBLE_STREAMS:\n",
    "            train_dict[s].append(feat[s].numpy())\n",
    "        train_dict[\"label\"].append([lbl.item()])\n",
    "\n",
    "    print(f\"Raw training samples: {len(train_dict['label'])}\")\n",
    "\n",
    "    # 4) balance -------------------------------------------------------------\n",
    "    balanced = balance_samples_count(train_dict, \"label\")\n",
    "    del train_dict, full_ds\n",
    "    gc.collect()\n",
    "\n",
    "    # 5) write pickles -------------------------------------------------------\n",
    "    print(\"\\nSaving balanced data …\")\n",
    "    with open(BALANCED_DATA_PKL_PATH, \"wb\") as fp:\n",
    "        pickle.dump(balanced, fp, pickle.HIGHEST_PROTOCOL)\n",
    "    print(f\"✓ {BALANCED_DATA_PKL_PATH}\")\n",
    "\n",
    "    print(\"Saving scalers …\")\n",
    "    with open(SCALERS_PKL_PATH, \"wb\") as fp:\n",
    "        pickle.dump(scalers_cell1, fp, pickle.HIGHEST_PROTOCOL)\n",
    "    print(f\"✓ {SCALERS_PKL_PATH}\")\n",
    "\n",
    "    del pie_db_cell1, scalers_cell1 # Clean up cell1 specific vars\n",
    "    gc.collect()\n",
    "\n",
    "    print(\"\\n--- CELL 1: DATA PREPARATION COMPLETE ---\")\n",
    "else:\n",
    "    if Path(BALANCED_DATA_PKL_PATH).exists() and Path(SCALERS_PKL_PATH).exists():\n",
    "        print(\"\\n--- CELL 1: Skipping data preparation, balanced data and scalers found. ---\")\n",
    "    else:\n",
    "        print(\"\\n--- CELL 1: ERROR - Balanced data or scalers missing, but not regenerating. Please check paths or remove existing files to force regeneration. ---\")\n",
    "\n",
    "\n",
    "# --- CELL 2: ABLATION STUDY – MODEL TRAINING AND EVALUATION (with Weighted Average Fusion, Hyperparameter Tuning, and Test on Set03) ---\n",
    "\n",
    "import os\n",
    "import sys\n",
    "import gc\n",
    "import time\n",
    "import math\n",
    "import random\n",
    "import pickle\n",
    "import torch\n",
    "import numpy as np\n",
    "import pandas as pd                      # results-summary table\n",
    "import torch.nn as nn\n",
    "import torch.optim as optim\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from tqdm.notebook import tqdm\n",
    "from torch.utils.data import Dataset, DataLoader\n",
    "from sklearn.metrics import (\n",
    "    accuracy_score,\n",
    "    precision_recall_fscore_support,\n",
    "    roc_auc_score,\n",
    "    confusion_matrix,\n",
    "    ConfusionMatrixDisplay,\n",
    "    f1_score # Explicitly import\n",
    ")\n",
    "import optuna # For hyperparameter tuning\n",
    "\n",
    "# --- Add PIE utilities path if necessary (adjust path) ------------------------\n",
    "pie_utilities_path = \"/kaggle/working/PIE/utilities\"\n",
    "if pie_utilities_path not in sys.path:\n",
    "    sys.path.insert(0, pie_utilities_path)\n",
    "\n",
    "try:\n",
    "    from pie_data import PIE as PIE_imported_cell2 # Rename to avoid conflict with PIE from cell1\n",
    "except ImportError as e:\n",
    "    print(f\"Warn: Could not import PIE class for Cell 2: {e}\")\n",
    "    PIE_imported_cell2 = None\n",
    "\n",
    "# --- Configuration ------------------------------------------------------------\n",
    "PIE_ROOT_PATH_CELL2 = \"/kaggle/working/PIE\" # Renamed for clarity\n",
    "POSE_DATA_DIR_CELL2 = \"/kaggle/input/pose-data/extracted_poses2\"\n",
    "PIE_DATABASE_CACHE_PATH_CELL2 = \"/kaggle/input/pie-database/pie_database.pkl\"\n",
    "\n",
    "# --- Define ALL possible streams (used by Dataset class) ----------------------\n",
    "ALL_POSSIBLE_STREAMS_CELL2 = [ # Renamed to avoid conflict if cell1 not run\n",
    "    \"bbox\",\n",
    "    \"pose\",\n",
    "    \"ego_speed\",\n",
    "    \"ego_acc\",\n",
    "    \"ego_gyro\",\n",
    "    \"ped_action\",\n",
    "    \"ped_look\",\n",
    "    \"ped_occlusion\",\n",
    "    \"traffic_light\",\n",
    "    \"static_context\",\n",
    "]\n",
    "\n",
    "# --- *** CHOOSE ACTIVE STREAMS FOR THIS EXPERIMENT *** ------------------------\n",
    "ACTIVE_STREAMS = [\n",
    "    \"bbox\",\n",
    "    \"ped_action\",\n",
    "    \"ped_look\",\n",
    "    \"ego_speed\",\n",
    "    \"ego_acc\",\n",
    "    \"static_context\",\n",
    "]\n",
    "# ------------------------------------------------------------------------------\n",
    "\n",
    "print(f\"--- Running Weighted Average Fusion With Active Streams: {ACTIVE_STREAMS} ---\")\n",
    "\n",
    "# --- Model Hyper-parameters (default, will be tuned) --------------------------\n",
    "# SEQ_LEN, PRED_LEN already defined in Cell 1, assuming they are globally accessible\n",
    "# INPUT_SIZE_* constants also from Cell 1\n",
    "\n",
    "# Default values, Optuna will override these during tuning\n",
    "DEFAULT_LSTM_HIDDEN_SIZE = 256\n",
    "DEFAULT_NUM_LSTM_LAYERS = 2\n",
    "DEFAULT_DROPOUT_RATE = 0.3\n",
    "DEFAULT_ATTENTION_DIM = 128\n",
    "NUM_CLASSES = 2 # Fixed\n",
    "\n",
    "# --- Training Hyper-parameters (default, LR will be tuned) --------------------\n",
    "DEFAULT_LEARNING_RATE = 1e-4\n",
    "BATCH_SIZE = 32 # Fixed for this example, can also be tuned\n",
    "DEVICE = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "print(f\"Using device: {DEVICE}\")\n",
    "\n",
    "# --- Optuna & Training Epochs Configuration ---\n",
    "N_OPTUNA_TRIALS = 15  # Number of hyperparameter tuning trials (adjust as needed)\n",
    "NUM_EPOCHS_TUNING = 3 # Epochs for each Optuna trial (short for speed)\n",
    "NUM_EPOCHS_FINAL_TRAINING = 5 # Epochs for training the best model (can be same as original NUM_EPOCHS)\n",
    "SEED = 42 # For reproducibility\n",
    "\n",
    "# --- Dataset splits -----------------------------------------------------------\n",
    "# VAL_SETS_STR: Used for validating models during Optuna hyperparameter search\n",
    "VAL_SETS_STR = [\"set05\", \"set06\"]\n",
    "# TEST_SET_STR: Used for final testing of the *best* model from Optuna\n",
    "TEST_SET_STR = [\"set03\"]\n",
    "\n",
    "# --- Paths for pre-processed data (from Cell 1) -------------------------------\n",
    "# BALANCED_DATA_PKL_PATH and SCALERS_PKL_PATH already defined in Cell 1\n",
    "\n",
    "# --- Set random seeds for reproducibility ---\n",
    "random.seed(SEED)\n",
    "np.random.seed(SEED)\n",
    "torch.manual_seed(SEED)\n",
    "if torch.cuda.is_available():\n",
    "    torch.cuda.manual_seed_all(SEED)\n",
    "torch.backends.cudnn.deterministic = True\n",
    "torch.backends.cudnn.benchmark = False\n",
    "\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                               Helper classes (Dataset)                       #\n",
    "# -----------------------------------------------------------------------------\n",
    "\n",
    "# Using to_one_hot from Cell 1. If Cell 1 is not run, define it here:\n",
    "if 'to_one_hot' not in globals():\n",
    "    def to_one_hot(index, num_classes):\n",
    "        vec = np.zeros(num_classes, dtype=np.float32)\n",
    "        safe_index = int(np.clip(index, 0, num_classes - 1))\n",
    "        vec[safe_index] = 1.0\n",
    "        return vec\n",
    "\n",
    "class PIEDataset_Cell2(Dataset): # Renamed to avoid conflict if Cell 1 is run in same notebook\n",
    "    \"\"\"\n",
    "    Dataset that can dynamically enable/disable streams. (Copied from original cell 2)\n",
    "    \"\"\"\n",
    "    def __init__(\n",
    "        self,\n",
    "        pie_database,\n",
    "        set_names,\n",
    "        pose_data_dir,\n",
    "        seq_len,\n",
    "        pred_len,\n",
    "        scalers=None,\n",
    "        streams_to_extract=None, # These are the streams this instance will actually load\n",
    "    ):\n",
    "        self.pie_db = pie_database\n",
    "        self.set_names = set_names\n",
    "        self.pose_data_dir = pose_data_dir\n",
    "        self.seq_len = seq_len\n",
    "        self.pred_len = pred_len\n",
    "        self.scalers = scalers or {}\n",
    "        self.streams_to_extract = streams_to_extract or ALL_POSSIBLE_STREAMS_CELL2 # Default to all if not specified\n",
    "        \n",
    "        self.sequences = []\n",
    "        self.all_pose_data = {}\n",
    "\n",
    "        self._input_sizes_for_error = self._get_input_sizes_dict() # For error handling\n",
    "\n",
    "        if \"pose\" in self.streams_to_extract:\n",
    "            self._load_pose_data()\n",
    "\n",
    "        self._generate_sequence_list()\n",
    "        if not self.sequences:\n",
    "            print(f\"Warning: PIEDataset_Cell2 init: No sequences found for sets {self.set_names} with current config.\")\n",
    "\n",
    "\n",
    "    def _get_input_sizes_dict(self): # Uses global INPUT_SIZE_* constants\n",
    "        input_sizes = {}\n",
    "        special_cases = {\n",
    "            \"TRAFFIC_LIGHT\": \"TL_STATE\", \"STATIC_CONTEXT\": \"STATIC\",\n",
    "            \"EGO_SPEED\": \"EGO_SPEED\", \"EGO_ACC\": \"EGO_ACC\", \"EGO_GYRO\": \"EGO_GYRO\",\n",
    "            \"PED_ACTION\": \"PED_ACTION\", \"PED_LOOK\": \"PED_LOOK\", \"PED_OCCLUSION\": \"PED_OCC\",\n",
    "        }\n",
    "        for stream in ALL_POSSIBLE_STREAMS_CELL2: # Check against all possible for safety\n",
    "            size_constant_name = f\"INPUT_SIZE_{stream.upper()}\"\n",
    "            suffix = special_cases.get(stream.upper())\n",
    "            if suffix: size_constant_name = f\"INPUT_SIZE_{suffix}\"\n",
    "            elif stream == \"bbox\": size_constant_name = \"INPUT_SIZE_BBOX\"\n",
    "            elif stream == \"pose\": size_constant_name = \"INPUT_SIZE_POSE\"\n",
    "            input_sizes[stream] = globals().get(size_constant_name, 1) # globals() is from Cell 1 scope\n",
    "        return input_sizes\n",
    "\n",
    "    def _load_pose_data(self):\n",
    "        # print(f\"PIEDataset_Cell2: Loading pose PKLs for sets {self.set_names} (streams_to_extract: {self.streams_to_extract})…\")\n",
    "        for set_id in self.set_names:\n",
    "            self.all_pose_data[set_id] = {}\n",
    "            pose_set_path = os.path.join(self.pose_data_dir, set_id)\n",
    "            if not os.path.isdir(pose_set_path): \n",
    "                # print(f\"PIEDataset_Cell2: Pose directory not found for set {set_id}: {pose_set_path}\")\n",
    "                continue\n",
    "            \n",
    "            pkl_files_in_set = [f for f in os.listdir(pose_set_path) if f.startswith(f\"{set_id}_\") and f.endswith(\"_poses.pkl\")]\n",
    "            if not pkl_files_in_set: \n",
    "                # print(f\"PIEDataset_Cell2: No pose PKL files found in {pose_set_path}\")\n",
    "                continue\n",
    "\n",
    "            for pkl_filename in pkl_files_in_set: # Not using tqdm here to reduce noise during HPO\n",
    "                pkl_file_path = os.path.join(pose_set_path, pkl_filename)\n",
    "                try:\n",
    "                    with open(pkl_file_path, \"rb\") as f: loaded_pkl_content = pickle.load(f)\n",
    "                except FileNotFoundError: continue\n",
    "                except Exception as e: print(f\"PIEDataset_Cell2: Error loading pose PKL {pkl_file_path}: {e}\"); continue\n",
    "                \n",
    "                if len(loaded_pkl_content) != 1: continue\n",
    "                unique_video_key, video_data = list(loaded_pkl_content.items())[0]\n",
    "                video_id = \"_\".join(unique_video_key.split(\"_\")[1:])\n",
    "                \n",
    "                if self.pie_db and set_id in self.pie_db and video_id in self.pie_db.get(set_id, {}):\n",
    "                    self.all_pose_data[set_id][video_id] = video_data\n",
    "\n",
    "    def _generate_sequence_list(self):\n",
    "        # print(f\"PIEDataset_Cell2: Enumerating sequences for sets {self.set_names}…\")\n",
    "        sequence_count = 0\n",
    "        if not self.pie_db:\n",
    "            print(f\"PIEDataset_Cell2: PIE database not available for {self.set_names}.\")\n",
    "            return\n",
    "\n",
    "        for set_id in self.set_names:\n",
    "            if set_id not in self.pie_db: continue\n",
    "            for video_id, video_data in self.pie_db[set_id].items():\n",
    "                if \"ped_annotations\" not in video_data: continue\n",
    "                for ped_id, ped_data in video_data[\"ped_annotations\"].items():\n",
    "                    frames = ped_data.get(\"frames\", [])\n",
    "                    if len(frames) < self.seq_len + self.pred_len: continue\n",
    "                    frames_sorted = sorted(frames)\n",
    "                    for i in range(len(frames_sorted) - self.seq_len - self.pred_len + 1):\n",
    "                        start_f, obs_end_f = frames_sorted[i], frames_sorted[i + self.seq_len - 1]\n",
    "                        if obs_end_f - start_f != self.seq_len - 1: continue\n",
    "                        \n",
    "                        target_idx_in_frames_sorted = i + self.seq_len + self.pred_len - 1\n",
    "                        if target_idx_in_frames_sorted >= len(frames_sorted): continue # Boundary check\n",
    "                        target_f = frames_sorted[target_idx_in_frames_sorted]\n",
    "\n",
    "                        if target_f - obs_end_f != self.pred_len: continue\n",
    "                        self.sequences.append((set_id, video_id, ped_id, start_f))\n",
    "                        sequence_count += 1\n",
    "        # print(f\"PIEDataset_Cell2: Total sequences for {self.set_names}: {sequence_count}\")\n",
    "\n",
    "\n",
    "    def __len__(self): return len(self.sequences)\n",
    "\n",
    "    def __getitem__(self, idx):\n",
    "        set_id, video_id, ped_id, start_frame = self.sequences[idx]\n",
    "        frame_nums = list(range(start_frame, start_frame + self.seq_len))\n",
    "        target_frame_num = start_frame + self.seq_len + self.pred_len - 1\n",
    "        \n",
    "        video_db, ped_db = {}, {}\n",
    "        if self.pie_db and set_id in self.pie_db and video_id in self.pie_db[set_id]:\n",
    "            video_db = self.pie_db[set_id][video_id]\n",
    "            ped_db = video_db.get(\"ped_annotations\", {}).get(ped_id, {})\n",
    "        \n",
    "        ego_db = video_db.get(\"vehicle_annotations\", {}) if video_db else {}\n",
    "        traffic_db = video_db.get(\"traffic_annotations\", {}) if video_db else {}\n",
    "        ped_attributes = ped_db.get(\"attributes\", {}) if ped_db else {}\n",
    "\n",
    "        feature_sequences = {s: [] for s in self.streams_to_extract}\n",
    "        label = 0\n",
    "        if ped_db and \"frames\" in ped_db and \"behavior\" in ped_db and \"cross\" in ped_db[\"behavior\"]:\n",
    "            try:\n",
    "                target_idx_in_pdb_frames = ped_db[\"frames\"].index(target_frame_num)\n",
    "                label = ped_db[\"behavior\"][\"cross\"][target_idx_in_pdb_frames]\n",
    "                if label == -1: label = 0\n",
    "            except (ValueError, IndexError): pass\n",
    "\n",
    "        static_vec = np.zeros(INPUT_SIZE_STATIC, dtype=np.float32) # From Cell 1\n",
    "        if \"static_context\" in self.streams_to_extract:\n",
    "            sig_idx = ped_attributes.get(\"signalized\", 0)\n",
    "            int_idx = ped_attributes.get(\"intersection\", 0)\n",
    "            age_idx = ped_attributes.get(\"age\", 2) # Default to adult if missing\n",
    "            gen_idx = ped_attributes.get(\"gender\", 0) # Default to male/unknown\n",
    "            td_idx = int(ped_attributes.get(\"traffic_direction\", 0))\n",
    "            nl_val = ped_attributes.get(\"num_lanes\", 2) # Default to 2 lanes\n",
    "            nl_cat_idx = LANE_CATEGORIES.get(nl_val, LANE_CATEGORIES[max(LANE_CATEGORIES.keys())]) # Cell 1\n",
    "            \n",
    "            static_vec = np.concatenate([\n",
    "                to_one_hot(sig_idx, NUM_SIGNALIZED_CATS), to_one_hot(int_idx, NUM_INTERSECTION_CATS),\n",
    "                to_one_hot(age_idx, NUM_AGE_CATS), to_one_hot(gen_idx, NUM_GENDER_CATS),\n",
    "                to_one_hot(td_idx, NUM_TRAFFIC_DIR_CATS), to_one_hot(nl_cat_idx, NUM_LANE_CATS),\n",
    "            ]).astype(np.float32)\n",
    "            if static_vec.shape[0] != INPUT_SIZE_STATIC: # Should not happen with globals\n",
    "                static_vec = np.zeros(INPUT_SIZE_STATIC, dtype=np.float32)\n",
    "\n",
    "\n",
    "        for frame_num in frame_nums:\n",
    "            frame_db_idx = -1 # Index within ped_db['frames']\n",
    "            if ped_db and \"frames\" in ped_db:\n",
    "                try: frame_db_idx = ped_db[\"frames\"].index(frame_num)\n",
    "                except ValueError: pass\n",
    "            \n",
    "            ego_frame_data = ego_db.get(frame_num, {})\n",
    "\n",
    "            if \"bbox\" in self.streams_to_extract:\n",
    "                bbox_norm = np.zeros(INPUT_SIZE_BBOX, dtype=np.float32) # Cell 1\n",
    "                if ped_db and frame_db_idx!=-1 and \"bbox\" in ped_db and len(ped_db[\"bbox\"]) > frame_db_idx:\n",
    "                    try:\n",
    "                        x1,y1,x2,y2 = ped_db[\"bbox\"][frame_db_idx]\n",
    "                        img_w = video_db.get(\"width\",1920) if video_db else 1920\n",
    "                        img_h = video_db.get(\"height\",1080) if video_db else 1080\n",
    "                        if img_w > 0 and img_h > 0:\n",
    "                            cx,cy,w,h = ((x1+x2)/2)/img_w, ((y1+y2)/2)/img_h, (x2-x1)/img_w, (y2-y1)/img_h\n",
    "                            if 0<w and 0<h and 0<=cx<=1 and 0<=cy<=1: \n",
    "                                bbox_norm=np.array([cx,cy,w,h],dtype=np.float32)\n",
    "                    except Exception: pass\n",
    "                feature_sequences[\"bbox\"].append(bbox_norm)\n",
    "\n",
    "            if \"pose\" in self.streams_to_extract:\n",
    "                pose_vector = np.zeros(INPUT_SIZE_POSE, dtype=np.float32) # Cell 1\n",
    "                # Ensure all_pose_data and its nested dicts are accessed safely\n",
    "                vid_pose_data = self.all_pose_data.get(set_id, {}).get(video_id, {})\n",
    "                ped_pose_at_frame = vid_pose_data.get(frame_num, {}).get(ped_id)\n",
    "                if isinstance(ped_pose_at_frame, np.ndarray) and ped_pose_at_frame.shape == (INPUT_SIZE_POSE,):\n",
    "                    pose_vector = ped_pose_at_frame\n",
    "                feature_sequences[\"pose\"].append(pose_vector)\n",
    "\n",
    "            if \"ego_speed\" in self.streams_to_extract:\n",
    "                speed = ego_frame_data.get(\"OBD_speed\",0.0) or ego_frame_data.get(\"GPS_speed\",0.0)\n",
    "                speed_scaled = (speed - self.scalers.get(\"ego_speed_mean\",0.0)) / self.scalers.get(\"ego_speed_std\",1.0)\n",
    "                feature_sequences[\"ego_speed\"].append([speed_scaled])\n",
    "\n",
    "            if \"ego_acc\" in self.streams_to_extract:\n",
    "                ax,ay = ego_frame_data.get(\"accX\",0.0), ego_frame_data.get(\"accY\",0.0)\n",
    "                ax_s = (ax - self.scalers.get(\"accX_mean\",0.0))/self.scalers.get(\"accX_std\",1.0)\n",
    "                ay_s = (ay - self.scalers.get(\"accY_mean\",0.0))/self.scalers.get(\"accY_std\",1.0)\n",
    "                feature_sequences[\"ego_acc\"].append([ax_s, ay_s])\n",
    "\n",
    "            if \"ego_gyro\" in self.streams_to_extract:\n",
    "                gz = ego_frame_data.get(\"gyroZ\",0.0)\n",
    "                gz_s = (gz - self.scalers.get(\"gyroZ_mean\",0.0))/self.scalers.get(\"gyroZ_std\",1.0)\n",
    "                feature_sequences[\"ego_gyro\"].append([gz_s])\n",
    "\n",
    "            if \"ped_action\" in self.streams_to_extract:\n",
    "                action=0.0 # Default if not found\n",
    "                if ped_db and frame_db_idx!=-1 and \"behavior\" in ped_db and \\\n",
    "                   \"action\" in ped_db[\"behavior\"] and len(ped_db[\"behavior\"][\"action\"]) > frame_db_idx:\n",
    "                    action = float(ped_db[\"behavior\"][\"action\"][frame_db_idx])\n",
    "                feature_sequences[\"ped_action\"].append([action])\n",
    "\n",
    "            if \"ped_look\" in self.streams_to_extract:\n",
    "                look=0.0 # Default\n",
    "                if ped_db and frame_db_idx!=-1 and \"behavior\" in ped_db and \\\n",
    "                   \"look\" in ped_db[\"behavior\"] and len(ped_db[\"behavior\"][\"look\"]) > frame_db_idx:\n",
    "                    look = float(ped_db[\"behavior\"][\"look\"][frame_db_idx])\n",
    "                feature_sequences[\"ped_look\"].append([look])\n",
    "\n",
    "            if \"ped_occlusion\" in self.streams_to_extract:\n",
    "                occ=0.0 # Default\n",
    "                if ped_db and frame_db_idx!=-1 and \"occlusion\" in ped_db and \\\n",
    "                   len(ped_db[\"occlusion\"]) > frame_db_idx:\n",
    "                    occ = float(ped_db[\"occlusion\"][frame_db_idx])/2.0 # Normalize 0-2 to 0-1\n",
    "                feature_sequences[\"ped_occlusion\"].append([occ])\n",
    "            \n",
    "            if \"traffic_light\" in self.streams_to_extract:\n",
    "                state_int=0 # Default: undefined/no relevant TL\n",
    "                for _,obj_data in traffic_db.items(): # Iterate through traffic objects\n",
    "                    if obj_data.get(\"obj_class\")==\"traffic_light\" and \"frames\" in obj_data and \"state\" in obj_data:\n",
    "                        try:\n",
    "                            tl_idx_in_obj_frames = obj_data[\"frames\"].index(frame_num)\n",
    "                            if obj_data[\"state\"][tl_idx_in_obj_frames]!=0: # 0 is often undefined/irrelevant\n",
    "                                state_int=obj_data[\"state\"][tl_idx_in_obj_frames]\n",
    "                                break # Assume first relevant TL is the one\n",
    "                        except (ValueError,IndexError): continue\n",
    "                feature_sequences[\"traffic_light\"].append(to_one_hot(state_int,INPUT_SIZE_TL_STATE)) # Cell 1\n",
    "\n",
    "            if \"static_context\" in self.streams_to_extract:\n",
    "                feature_sequences[\"static_context\"].append(static_vec) # Already computed per sequence\n",
    "\n",
    "        # Convert lists of features to tensors\n",
    "        final_features = {}\n",
    "        try:\n",
    "            for stream_name in self.streams_to_extract:\n",
    "                # Ensure all sub-lists in feature_sequences[stream_name] have consistent shape before asarray\n",
    "                np_array = np.asarray(feature_sequences[stream_name], dtype=np.float32)\n",
    "                if np_array.ndim == 1 and self._input_sizes_for_error.get(stream_name,1) > 1: # handles case where list of lists might become 1D\n",
    "                     np_array = np_array.reshape(self.seq_len, -1)\n",
    "\n",
    "                expected_shape_dim1 = self._input_sizes_for_error.get(stream_name,1)\n",
    "                if np_array.shape != (self.seq_len, expected_shape_dim1):\n",
    "                     # Fallback if shapes are inconsistent, e.g. due to missing data for a frame\n",
    "                     # print(f\"Warning: Shape mismatch for stream {stream_name}. Expected {(self.seq_len, expected_shape_dim1)}, got {np_array.shape}. Using zeros.\")\n",
    "                     np_array = np.zeros((self.seq_len, expected_shape_dim1), dtype=np.float32)\n",
    "\n",
    "                final_features[stream_name] = torch.tensor(np_array, dtype=torch.float32)\n",
    "\n",
    "        except Exception as e: # Catch-all for unexpected errors during tensor conversion\n",
    "            print(f\"PIEDataset_Cell2: Error converting features for idx {idx} ({set_id},{video_id},{ped_id},{start_frame}): {e}. Returning zero tensors.\")\n",
    "            final_features = {\n",
    "                name: torch.zeros((self.seq_len, self._input_sizes_for_error.get(name, 1)), dtype=torch.float32)\n",
    "                for name in self.streams_to_extract\n",
    "            }\n",
    "            \n",
    "        return final_features, torch.tensor(label,dtype=torch.long)\n",
    "\n",
    "\n",
    "class BalancedDataset(Dataset): # For using pre-loaded balanced data\n",
    "    def __init__(self, data_dict, active_streams_list, label_key=\"label\"):\n",
    "        self.active_streams = active_streams_list # The streams the model will actually use\n",
    "        self.label_key = label_key\n",
    "        \n",
    "        if self.label_key not in data_dict or not data_dict[self.label_key]:\n",
    "            raise ValueError(f\"Label key '{self.label_key}' missing or empty in data_dict.\")\n",
    "        \n",
    "        self.num_samples = len(data_dict[self.label_key])\n",
    "        if self.num_samples == 0: \n",
    "            print(\"Warning: BalancedDataset initialized with zero samples.\")\n",
    "        \n",
    "        self.features_from_dict = {} # Stores tensors for active_streams\n",
    "        for stream in self.active_streams:\n",
    "            if stream in data_dict and data_dict[stream]:\n",
    "                try: \n",
    "                    # Data from pickle is already numpy array, convert to tensor\n",
    "                    self.features_from_dict[stream] = torch.tensor(np.asarray(data_dict[stream]),dtype=torch.float32)\n",
    "                except ValueError as e: \n",
    "                    raise ValueError(f\"Error converting stream '{stream}' from data_dict: {e}\")\n",
    "            else:\n",
    "                # This should not happen if Cell 1 ran correctly and ACTIVE_STREAMS are subset of ALL_POSSIBLE_STREAMS\n",
    "                raise KeyError(f\"Stream '{stream}' (active) missing or empty in provided data_dict.\")\n",
    "\n",
    "        try: \n",
    "            self.labels = torch.tensor([lbl[0] for lbl in data_dict[self.label_key]],dtype=torch.long)\n",
    "        except (IndexError, TypeError) as e: \n",
    "            raise ValueError(f\"Error converting labels from data_dict: {e}\")\n",
    "\n",
    "        # Sanity check lengths\n",
    "        for stream in self.active_streams:\n",
    "            if len(self.features_from_dict[stream]) != self.num_samples:\n",
    "                raise ValueError(f\"Length mismatch: Stream '{stream}' has {len(self.features_from_dict[stream])} samples, but labels have {self.num_samples}.\")\n",
    "\n",
    "    def __len__(self): return self.num_samples\n",
    "    \n",
    "    def __getitem__(self, idx):\n",
    "        # Return a dictionary of features, only for the active_streams\n",
    "        feature_dict_for_model = {s: self.features_from_dict[s][idx] for s in self.active_streams}\n",
    "        label = self.labels[idx]\n",
    "        return feature_dict_for_model, label\n",
    "\n",
    "\n",
    "class Attention(nn.Module):\n",
    "    def __init__(self, hidden_dim, attention_dim):\n",
    "        super().__init__()\n",
    "        self.attention_net = nn.Sequential(\n",
    "            nn.Linear(hidden_dim, attention_dim), nn.Tanh(), nn.Linear(attention_dim, 1),\n",
    "        )\n",
    "    def forward(self, lstm_output): # (batch, seq_len, hidden_dim*2)\n",
    "        att_scores = self.attention_net(lstm_output).squeeze(2) # (batch, seq_len)\n",
    "        att_weights = torch.softmax(att_scores, dim=1) # (batch, seq_len)\n",
    "        context_vector = torch.sum(lstm_output * att_weights.unsqueeze(2), dim=1) # (batch, hidden_dim*2)\n",
    "        return context_vector, att_weights\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                  ***  MODEL WITH WEIGHTED AVERAGE FUSION  ***                #\n",
    "# -----------------------------------------------------------------------------\n",
    "class MultiStreamWeightedAvgLSTM(nn.Module):\n",
    "    def __init__(\n",
    "        self, input_sizes_dict, lstm_hidden_size, num_lstm_layers,\n",
    "        num_classes, attention_dim, dropout_rate, active_stream_names_list=None,\n",
    "    ):\n",
    "        super().__init__()\n",
    "        if not active_stream_names_list: raise ValueError(\"active_stream_names_list cannot be empty.\")\n",
    "        \n",
    "        self.active_stream_names = active_stream_names_list\n",
    "        self.num_active_streams = len(active_stream_names_list)\n",
    "        self.lstm_output_dim = lstm_hidden_size * 2 # Bidirectional\n",
    "        \n",
    "        self.lstms, self.attentions = nn.ModuleDict(), nn.ModuleDict()\n",
    "        \n",
    "        # print(f\"Initializing Weighted-Avg model with streams: {self.active_stream_names}\")\n",
    "        for name in self.active_stream_names:\n",
    "            if name not in input_sizes_dict: \n",
    "                raise KeyError(f\"Input size for stream '{name}' not provided in input_sizes_dict.\")\n",
    "            in_size = input_sizes_dict[name]\n",
    "            # print(f\"  – Adding stream '{name}' (input size: {in_size}, LSTM hidden: {lstm_hidden_size})\")\n",
    "            self.lstms[name] = nn.LSTM(\n",
    "                in_size, lstm_hidden_size, num_lstm_layers, batch_first=True,\n",
    "                dropout=dropout_rate if num_lstm_layers > 1 else 0, bidirectional=True,\n",
    "            )\n",
    "            self.attentions[name] = Attention(self.lstm_output_dim, attention_dim)\n",
    "            \n",
    "        self.fusion_weights = nn.Parameter(torch.ones(self.num_active_streams))\n",
    "        \n",
    "        fused_representation_dim = self.lstm_output_dim # Since we average same-sized context vectors\n",
    "        \n",
    "        self.dropout_layer = nn.Dropout(dropout_rate)\n",
    "        \n",
    "        # Intermediate FC layer dimension (heuristic)\n",
    "        intermediate_fc_dim = max(num_classes * 4, fused_representation_dim // 2)\n",
    "        \n",
    "        self.fc1 = nn.Linear(fused_representation_dim, intermediate_fc_dim)\n",
    "        self.relu_activation = nn.ReLU()\n",
    "        self.fc2_final_classifier = nn.Linear(intermediate_fc_dim, num_classes)\n",
    "\n",
    "    def forward(self, x_input_dict): # x_input_dict contains {stream_name: tensor}\n",
    "        context_vectors_list = []\n",
    "        \n",
    "        for stream_name in self.active_stream_names:\n",
    "            if stream_name not in x_input_dict:\n",
    "                # This case should ideally be handled by the DataLoader ensuring all active streams are present.\n",
    "                # If a stream is truly optional and might be missing, this needs robust handling.\n",
    "                # For now, assume all active_stream_names are keys in x_input_dict.\n",
    "                # print(f\"Warning: Stream '{stream_name}' not in input dict x. Using zeros.\")\n",
    "                # Fallback: create a zero tensor. This might affect training if happens often.\n",
    "                batch_size_est = x_input_dict[next(iter(x_input_dict))].shape[0] # Get batch size from another stream\n",
    "                zero_ctx = torch.zeros(batch_size_est, self.lstm_output_dim, device=DEVICE)\n",
    "                context_vectors_list.append(zero_ctx)\n",
    "                continue\n",
    "\n",
    "            lstm_out, _ = self.lstms[stream_name](x_input_dict[stream_name])\n",
    "            context_vector, _ = self.attentions[stream_name](lstm_out)\n",
    "            context_vectors_list.append(context_vector)\n",
    "            \n",
    "        if len(context_vectors_list) != self.num_active_streams:\n",
    "            raise RuntimeError(f\"Mismatch: collected {len(context_vectors_list)} context vectors, expected {self.num_active_streams} for streams {self.active_stream_names}\")\n",
    "\n",
    "        # Stack context vectors for weighted sum: (batch, num_streams, lstm_output_dim)\n",
    "        stacked_context_vectors = torch.stack(context_vectors_list, dim=1)\n",
    "        \n",
    "        # Apply softmax to fusion_weights to make them sum to 1: (num_streams) -> (1, num_streams, 1) for broadcasting\n",
    "        normalized_fusion_weights = torch.softmax(self.fusion_weights, dim=0).view(1, -1, 1)\n",
    "        \n",
    "        # Weighted sum: (batch, num_streams, lstm_output_dim) * (1, num_streams, 1) -> sum over dim=1\n",
    "        fused_representation = torch.sum(stacked_context_vectors * normalized_fusion_weights, dim=1) # (batch, lstm_output_dim)\n",
    "        \n",
    "        # Pass through final classification layers\n",
    "        out = self.dropout_layer(fused_representation)\n",
    "        out = self.relu_activation(self.fc1(out))\n",
    "        out = self.dropout_layer(out)\n",
    "        logits = self.fc2_final_classifier(out)\n",
    "        \n",
    "        return logits\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#         Training / evaluation / Threshold Tuning helpers                     #\n",
    "# -----------------------------------------------------------------------------\n",
    "\n",
    "def get_all_probabilities_and_labels(model, dataloader, device):\n",
    "    model.eval()\n",
    "    all_true_labels, all_positive_class_probs = [], []\n",
    "    # active_streams_for_model = model.active_stream_names # Get from model instance\n",
    "\n",
    "    with torch.no_grad():\n",
    "        for features_dict, true_labels in dataloader: # tqdm removed for less noise in HPO\n",
    "            # Ensure only active streams are passed, and they are on the correct device\n",
    "            inputs_for_model = {\n",
    "                name: features_dict[name].to(device) \n",
    "                for name in model.active_stream_names # Use model's configured streams\n",
    "                if name in features_dict # Data loader provides these\n",
    "            }\n",
    "            \n",
    "            logits = model(inputs_for_model)\n",
    "            probabilities = torch.softmax(logits, dim=1)\n",
    "\n",
    "            all_true_labels.extend(true_labels.cpu().numpy())\n",
    "            all_positive_class_probs.extend(probabilities[:, 1].cpu().numpy()) # Prob for class 1\n",
    "\n",
    "    return np.asarray(all_true_labels), np.asarray(all_positive_class_probs)\n",
    "\n",
    "\n",
    "def find_optimal_threshold(y_true, y_probs_positive_class, metric_to_optimize='f1', num_steps=100):\n",
    "    best_threshold_val = 0.5\n",
    "    best_metric_score = -1.0\n",
    "\n",
    "    if metric_to_optimize == 'f1':\n",
    "        # precision_recall_fscore_support returns (precision, recall, f1, support)\n",
    "        # We need the f1_score for the positive class (binary classification)\n",
    "        metric_function = lambda true_y, pred_y: f1_score(true_y, pred_y, pos_label=1, zero_division=0)\n",
    "    else:\n",
    "        raise ValueError(f\"Unsupported metric for threshold tuning: {metric_to_optimize}\")\n",
    "\n",
    "    # Iterate over potential thresholds\n",
    "    threshold_candidates = np.linspace(0.0, 1.0, num_steps + 1)\n",
    "\n",
    "    for current_threshold in threshold_candidates: # tqdm removed\n",
    "        # Apply current threshold to get binary predictions\n",
    "        y_pred_at_threshold = (y_probs_positive_class >= current_threshold).astype(int)\n",
    "        current_metric_score = metric_function(y_true, y_pred_at_threshold)\n",
    "\n",
    "        if current_metric_score > best_metric_score:\n",
    "            best_metric_score = current_metric_score\n",
    "            best_threshold_val = current_threshold\n",
    "        elif current_metric_score == best_metric_score: # Tie-breaking: prefer threshold closer to 0.5\n",
    "            if abs(current_threshold - 0.5) < abs(best_threshold_val - 0.5):\n",
    "                best_threshold_val = current_threshold\n",
    "    \n",
    "    # print(f\"Optimal threshold for {metric_to_optimize.upper()}: {best_threshold_val:.4f} (Max value: {best_metric_score:.4f})\")\n",
    "    return best_threshold_val, best_metric_score\n",
    "\n",
    "\n",
    "def train_epoch(model, dataloader, optimizer, criterion, device):\n",
    "    model.train()\n",
    "    current_epoch_loss = 0.0\n",
    "    # active_streams_for_model = model.active_stream_names\n",
    "\n",
    "    for features_dict, true_labels in dataloader: # tqdm removed for HPO\n",
    "        inputs_for_model = {\n",
    "            name: features_dict[name].to(device) \n",
    "            for name in model.active_stream_names if name in features_dict\n",
    "        }\n",
    "        true_labels = true_labels.to(device)\n",
    "        \n",
    "        optimizer.zero_grad()\n",
    "        logits = model(inputs_for_model)\n",
    "        loss = criterion(logits, true_labels)\n",
    "        loss.backward()\n",
    "        optimizer.step()\n",
    "        current_epoch_loss += loss.item()\n",
    "        \n",
    "    avg_epoch_loss = current_epoch_loss / max(1, len(dataloader))\n",
    "    return avg_epoch_loss # Accuracy calculation removed to speed up HPO, F1 is the target\n",
    "\n",
    "\n",
    "def evaluate_model_performance(model, dataloader, criterion, device, threshold_to_apply=0.5, tune_threshold_on_this_data=False):\n",
    "    \"\"\"Evaluates model, returns metrics. Can optionally tune threshold.\"\"\"\n",
    "    model.eval()\n",
    "    total_eval_loss = 0.0\n",
    "    all_true_labels_list, all_predicted_probs_list = [], []\n",
    "    # active_streams_for_model = model.active_stream_names\n",
    "\n",
    "    with torch.no_grad():\n",
    "        for features_dict, true_labels in dataloader: # tqdm removed for HPO\n",
    "            inputs_for_model = {\n",
    "                name: features_dict[name].to(device) \n",
    "                for name in model.active_stream_names if name in features_dict\n",
    "            }\n",
    "            labels_on_gpu = true_labels.to(device)\n",
    "            \n",
    "            logits = model(inputs_for_model)\n",
    "            loss = criterion(logits, labels_on_gpu)\n",
    "            total_eval_loss += loss.item()\n",
    "            \n",
    "            probabilities = torch.softmax(logits, 1)\n",
    "            all_true_labels_list.extend(true_labels.cpu().numpy())\n",
    "            all_predicted_probs_list.extend(probabilities.cpu().numpy())\n",
    "\n",
    "    avg_eval_loss = total_eval_loss / max(1, len(dataloader))\n",
    "    \n",
    "    y_true_np = np.asarray(all_true_labels_list)\n",
    "    y_probs_all_classes_np = np.asarray(all_predicted_probs_list)\n",
    "    y_probs_positive_class_np = y_probs_all_classes_np[:, 1] # Probabilities for class 1\n",
    "\n",
    "    current_f1_score = 0.0\n",
    "    final_threshold_used = threshold_to_apply\n",
    "\n",
    "    if tune_threshold_on_this_data:\n",
    "        if len(y_true_np) > 0:\n",
    "            optimal_eval_threshold, f1_at_optimal = find_optimal_threshold(y_true_np, y_probs_positive_class_np, metric_to_optimize='f1')\n",
    "            final_threshold_used = optimal_eval_threshold\n",
    "            current_f1_score = f1_at_optimal\n",
    "            # print(f\"  (Threshold tuned on this data: {final_threshold_used:.4f} -> F1: {current_f1_score:.4f})\")\n",
    "        else: # Should not happen with proper dataset handling\n",
    "            # print(\"  (Cannot tune threshold on empty data)\")\n",
    "            current_f1_score = 0.0 # Or NaN\n",
    "    \n",
    "    # Calculate all metrics using the final_threshold_used (either fixed 0.5 or tuned)\n",
    "    y_pred_final = (y_probs_positive_class_np >= final_threshold_used).astype(int)\n",
    "    \n",
    "    acc = accuracy_score(y_true_np, y_pred_final) if len(y_true_np) > 0 else 0.0\n",
    "    prec, rec, f1_final_official, _ = precision_recall_fscore_support(\n",
    "        y_true_np, y_pred_final, average=\"binary\", pos_label=1, zero_division=0\n",
    "    ) if len(y_true_np) > 0 else (0.0,0.0,0.0,None)\n",
    "    \n",
    "    # AUC is independent of threshold\n",
    "    auc = roc_auc_score(y_true_np, y_probs_positive_class_np) if len(np.unique(y_true_np)) > 1 else float(\"nan\")\n",
    "    \n",
    "    return {\n",
    "        \"loss\": avg_eval_loss, \"accuracy\": acc, \"precision\": prec, \n",
    "        \"recall\": rec, \"f1\": f1_final_official, \"auc\": auc,\n",
    "        \"tuned_threshold_if_any\": final_threshold_used if tune_threshold_on_this_data else None,\n",
    "        \"f1_after_tuning_if_any\": current_f1_score if tune_threshold_on_this_data else None,\n",
    "        \"true_labels\": y_true_np, # For external CM plotting or further analysis\n",
    "        \"positive_class_probs\": y_probs_positive_class_np # For external threshold tuning\n",
    "    }\n",
    "\n",
    "\n",
    "# --- Global variables for Optuna objective function ---\n",
    "# These are set before calling Optuna study.\n",
    "# pie_database_global, scalers_global, balanced_train_data_global\n",
    "# train_loader_global, val_loader_for_hpo_global\n",
    "# current_input_sizes_global (derived from ACTIVE_STREAMS)\n",
    "\n",
    "pie_database_global = None\n",
    "scalers_global = None\n",
    "balanced_train_data_global = None\n",
    "train_loader_global = None\n",
    "val_loader_for_hpo_global = None\n",
    "current_input_sizes_global = None\n",
    "\n",
    "\n",
    "def objective_for_optuna(trial: optuna.Trial):\n",
    "    # Hyperparameters to tune\n",
    "    lstm_hidden_s = trial.suggest_categorical('lstm_hidden_size', [128, 256, 384]) # Adjusted choices\n",
    "    num_lstm_l = trial.suggest_int('num_lstm_layers', 1, 2) # Max 2 to keep model smaller\n",
    "    dropout_r = trial.suggest_float('dropout_rate', 0.2, 0.5, step=0.1)\n",
    "    learning_r = trial.suggest_float('learning_rate', 5e-5, 5e-4, log=True) # Adjusted range\n",
    "    attention_d = trial.suggest_categorical('attention_dim', [64, 128]) # Adjusted choices\n",
    "\n",
    "    # Create model with suggested HPs\n",
    "    model_trial = MultiStreamWeightedAvgLSTM(\n",
    "        input_sizes_dict=current_input_sizes_global, # From global scope\n",
    "        lstm_hidden_size=lstm_hidden_s,\n",
    "        num_lstm_layers=num_lstm_l,\n",
    "        num_classes=NUM_CLASSES, # Fixed\n",
    "        attention_dim=attention_d,\n",
    "        dropout_rate=dropout_r,\n",
    "        active_stream_names_list=ACTIVE_STREAMS, # Fixed for this run\n",
    "    ).to(DEVICE)\n",
    "\n",
    "    # Class weights (recalculate in case, though train_loader_global uses balanced data)\n",
    "    train_labels_list = train_loader_global.dataset.labels.tolist()\n",
    "    n_class0, n_class1 = train_labels_list.count(0), train_labels_list.count(1)\n",
    "    total_samples = len(train_labels_list)\n",
    "    \n",
    "    weight_c0, weight_c1 = (1.0,1.0)\n",
    "    if total_samples > 0 and n_class0 > 0 and n_class1 > 0 :\n",
    "        weight_c0 = total_samples / (2. * n_class0)\n",
    "        weight_c1 = total_samples / (2. * n_class1)\n",
    "    \n",
    "    criterion_trial = nn.CrossEntropyLoss(weight=torch.tensor([weight_c0, weight_c1], dtype=torch.float32).to(DEVICE))\n",
    "    optimizer_trial = optim.Adam(model_trial.parameters(), lr=learning_r)\n",
    "\n",
    "    # Training loop for this trial\n",
    "    for epoch_num in range(NUM_EPOCHS_TUNING):\n",
    "        _ = train_epoch(model_trial, train_loader_global, optimizer_trial, criterion_trial, DEVICE)\n",
    "        # No intermediate evaluation during tuning epochs to speed up, F1 on val set after all tuning epochs\n",
    "\n",
    "    # Evaluate on HPO validation set\n",
    "    # The `evaluate_model_performance` can do threshold tuning internally if requested\n",
    "    if len(val_loader_for_hpo_global.dataset) == 0:\n",
    "        print(f\"Optuna trial {trial.number}: HPO Validation dataset is empty. Returning F1=0.\")\n",
    "        return 0.0 # Or handle as Optuna pruner would\n",
    "\n",
    "    eval_results_trial = evaluate_model_performance(\n",
    "        model_trial, val_loader_for_hpo_global, criterion_trial, DEVICE, \n",
    "        tune_threshold_on_this_data=True # This will find optimal F1 on val set for HPO\n",
    "    )\n",
    "    \n",
    "    f1_for_this_trial = eval_results_trial[\"f1_after_tuning_if_any\"] if eval_results_trial[\"f1_after_tuning_if_any\"] is not None else 0.0\n",
    "\n",
    "    # Optuna pruner hook (optional, for early stopping of unpromising trials)\n",
    "    trial.report(f1_for_this_trial, step=NUM_EPOCHS_TUNING -1) # Report at the end of all tuning epochs\n",
    "    if trial.should_prune():\n",
    "        raise optuna.exceptions.TrialPruned()\n",
    "\n",
    "    return f1_for_this_trial # Optuna maximizes this\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                            Main execution block                              #\n",
    "# -----------------------------------------------------------------------------\n",
    "\n",
    "if __name__ == \"__main__\": # Ensures this runs only when script is executed directly\n",
    "    print(\"--- CELL 2: Model Training, HPO, and Evaluation on Set03 ---\")\n",
    "    print(f\"Active Streams: {ACTIVE_STREAMS}\")\n",
    "\n",
    "    # --- 1. Load pre-processed data (from Cell 1) and PIE DB ---\n",
    "    print(\"\\nLoading balanced training data, scalers, and PIE database …\")\n",
    "    try:\n",
    "        with open(BALANCED_DATA_PKL_PATH, \"rb\") as f: balanced_train_data_global = pickle.load(f)\n",
    "        with open(SCALERS_PKL_PATH, \"rb\") as f: scalers_global = pickle.load(f)\n",
    "        if not os.path.exists(PIE_DATABASE_CACHE_PATH_CELL2): \n",
    "            raise FileNotFoundError(f\"PIE db cache not found at {PIE_DATABASE_CACHE_PATH_CELL2}\")\n",
    "        with open(PIE_DATABASE_CACHE_PATH_CELL2, \"rb\") as f: pie_database_global = pickle.load(f)\n",
    "        print(\"   ✓ Pre-processed data and PIE database loaded.\")\n",
    "    except FileNotFoundError as e: \n",
    "        print(f\"ERROR: {e}. Ensure Cell 1 has run successfully and paths are correct.\"); sys.exit(1)\n",
    "    except Exception as e: \n",
    "        print(f\"Error loading data: {e}\"); sys.exit(1)\n",
    "\n",
    "    # --- 2. Prepare Datasets and DataLoaders for HPO and Final Training ---\n",
    "    print(\"\\nCreating Datasets and DataLoaders …\")\n",
    "    try:\n",
    "        # Training dataset (from balanced pickle)\n",
    "        train_dataset_obj = BalancedDataset(\n",
    "            balanced_train_data_global, \n",
    "            ACTIVE_STREAMS, # Model will use these streams\n",
    "            label_key=\"label\"\n",
    "        )\n",
    "        # Validation dataset for HPO (uses VAL_SETS_STR)\n",
    "        # PIEDataset_Cell2 needs all possible streams it *might* be asked for by any model variant.\n",
    "        # Model then picks ACTIVE_STREAMS.\n",
    "        val_dataset_for_hpo_obj = PIEDataset_Cell2(\n",
    "            pie_database_global, VAL_SETS_STR, POSE_DATA_DIR_CELL2, SEQ_LEN, PRED_LEN,\n",
    "            scalers_global, streams_to_extract=ALL_POSSIBLE_STREAMS_CELL2, \n",
    "        )\n",
    "        if len(train_dataset_obj) == 0 : raise ValueError(\"Train dataset (BalancedDataset) is empty!\")\n",
    "        if len(val_dataset_for_hpo_obj) == 0 : print(f\"Warning: HPO Validation dataset ({VAL_SETS_STR}) is empty! Check set names and PIE data.\")\n",
    "\n",
    "        train_loader_global = DataLoader(train_dataset_obj, batch_size=BATCH_SIZE, shuffle=True, num_workers=2, pin_memory=True)\n",
    "        val_loader_for_hpo_global = DataLoader(val_dataset_for_hpo_obj, batch_size=BATCH_SIZE, shuffle=False, num_workers=2, pin_memory=True)\n",
    "        print(f\"   ✓ Train DataLoader ready ({len(train_dataset_obj)} samples).\")\n",
    "        print(f\"   ✓ HPO Validation DataLoader ready ({len(val_dataset_for_hpo_obj)} samples for {VAL_SETS_STR}).\")\n",
    "\n",
    "    except Exception as e: \n",
    "        print(f\"Error creating datasets/dataloaders: {e}\"); raise\n",
    "\n",
    "    # Determine input sizes for active streams (used by model constructor)\n",
    "    current_input_sizes_global = {}\n",
    "    SPECIAL_MAP_CELL2 = { # To map stream names to global INPUT_SIZE constants\n",
    "        \"TRAFFIC_LIGHT\": \"TL_STATE\", \"STATIC_CONTEXT\": \"STATIC\", \"EGO_SPEED\": \"EGO_SPEED\",\n",
    "        \"EGO_ACC\": \"EGO_ACC\", \"EGO_GYRO\": \"EGO_GYRO\", \"PED_ACTION\": \"PED_ACTION\",\n",
    "        \"PED_LOOK\": \"PED_LOOK\", \"PED_OCCLUSION\": \"PED_OCC\",\n",
    "    }\n",
    "    for s_name in ACTIVE_STREAMS:\n",
    "        const_suffix = SPECIAL_MAP_CELL2.get(s_name.upper(), s_name.upper())\n",
    "        if s_name == \"bbox\": const_suffix = \"BBOX\"\n",
    "        elif s_name == \"pose\": const_suffix = \"POSE\"\n",
    "        size_const_name = f\"INPUT_SIZE_{const_suffix}\"\n",
    "        if size_const_name not in globals(): # Check Cell 1 globals\n",
    "            raise ValueError(f\"Input-size constant {size_const_name} for stream '{s_name}' not found in globals.\")\n",
    "        current_input_sizes_global[s_name] = globals()[size_const_name]\n",
    "    \n",
    "    # --- 3. Hyperparameter Optimization with Optuna ---\n",
    "    print(f\"\\n--- Starting Hyperparameter Optimization ({N_OPTUNA_TRIALS} trials, {NUM_EPOCHS_TUNING} epochs/trial) ---\")\n",
    "    # optuna.logging.set_verbosity(optuna.logging.WARNING) # Reduce Optuna's own logging\n",
    "    study = optuna.create_study(\n",
    "        direction=\"maximize\", # We want to maximize F1 score\n",
    "        sampler=optuna.samplers.TPESampler(seed=SEED)\n",
    "    )\n",
    "    \n",
    "    # Pass global vars by assignment before study, objective function will access them\n",
    "    # This is done above where they are defined with _global suffix\n",
    "\n",
    "    start_hpo_time = time.time()\n",
    "    study.optimize(objective_for_optuna, n_trials=N_OPTUNA_TRIALS, show_progress_bar=True)\n",
    "    hpo_duration = time.time() - start_hpo_time\n",
    "    \n",
    "    print(f\"\\n--- Hyperparameter Optimization Finished ({hpo_duration:.2f}s) ---\")\n",
    "    print(f\"Best HPO F1 score on validation set ({VAL_SETS_STR}): {study.best_value:.4f}\")\n",
    "    print(\"Best hyperparameters found:\")\n",
    "    for key, value in study.best_params.items():\n",
    "        print(f\"  {key}: {value}\")\n",
    "    \n",
    "    best_hps = study.best_params\n",
    "\n",
    "    # --- 4. Train Final Model with Best Hyperparameters ---\n",
    "    print(\"\\n--- Training Final Model with Best Hyperparameters ---\")\n",
    "    final_model = MultiStreamWeightedAvgLSTM(\n",
    "        input_sizes_dict=current_input_sizes_global,\n",
    "        lstm_hidden_size=best_hps['lstm_hidden_size'],\n",
    "        num_lstm_layers=best_hps['num_lstm_layers'],\n",
    "        num_classes=NUM_CLASSES,\n",
    "        attention_dim=best_hps['attention_dim'],\n",
    "        dropout_rate=best_hps['dropout_rate'],\n",
    "        active_stream_names_list=ACTIVE_STREAMS,\n",
    "    ).to(DEVICE)\n",
    "\n",
    "    # Print model summary\n",
    "    print(\"\\n--- Final Model Architecture ---\")\n",
    "    # print(final_model) # Can be very verbose\n",
    "    total_params_final = sum(p.numel() for p in final_model.parameters() if p.requires_grad)\n",
    "    print(f\"Trainable parameters in final model: {total_params_final:,}\")\n",
    "\n",
    "    # Optimizer and Criterion for final model\n",
    "    train_labels_final = train_loader_global.dataset.labels.tolist() # From the global loader\n",
    "    n0_final, n1_final = train_labels_final.count(0), train_labels_final.count(1)\n",
    "    total_final = len(train_labels_final)\n",
    "    w0_final, w1_final = (1.0,1.0)\n",
    "    if total_final > 0 and n0_final > 0 and n1_final > 0:\n",
    "        w0_final = total_final / (2. * n0_final)\n",
    "        w1_final = total_final / (2. * n1_final)\n",
    "    \n",
    "    class_weights_final = torch.tensor([w0_final, w1_final], dtype=torch.float32).to(DEVICE)\n",
    "    criterion_final = nn.CrossEntropyLoss(weight=class_weights_final)\n",
    "    optimizer_final = optim.Adam(final_model.parameters(), lr=best_hps['learning_rate'])\n",
    "\n",
    "    print(f\"\\nTraining final model for {NUM_EPOCHS_FINAL_TRAINING} epochs with LR={best_hps['learning_rate']:.2e}...\")\n",
    "    history_final_model = {\"train_loss\": [], \"val_loss_on_hpo_set\": [], \"val_f1_on_hpo_set\": []} # Track basic metrics\n",
    "\n",
    "    for epoch in range(NUM_EPOCHS_FINAL_TRAINING):\n",
    "        t_epoch_start = time.time()\n",
    "        final_train_loss = train_epoch(final_model, train_loader_global, optimizer_final, criterion_final, DEVICE)\n",
    "        \n",
    "        # Optional: evaluate on HPO val set during final training to monitor\n",
    "        # Using fixed 0.5 threshold for this interim check, not tuning threshold every epoch here\n",
    "        val_metrics_interim = evaluate_model_performance(\n",
    "            final_model, val_loader_for_hpo_global, criterion_final, DEVICE, threshold_to_apply=0.5 \n",
    "        )\n",
    "        \n",
    "        history_final_model[\"train_loss\"].append(final_train_loss)\n",
    "        history_final_model[\"val_loss_on_hpo_set\"].append(val_metrics_interim[\"loss\"])\n",
    "        history_final_model[\"val_f1_on_hpo_set\"].append(val_metrics_interim[\"f1\"]) # F1 at 0.5 on HPO val set\n",
    "\n",
    "        print(f\"  Epoch {epoch + 1:02d}/{NUM_EPOCHS_FINAL_TRAINING} – {time.time() - t_epoch_start:.1f}s \"\n",
    "              f\"| Train Loss: {final_train_loss:.4f} \"\n",
    "              f\"| Val HPO Loss: {val_metrics_interim['loss']:.4f} \"\n",
    "              f\"| Val HPO F1@0.5: {val_metrics_interim['f1']:.4f}\")\n",
    "\n",
    "    # --- 5. Evaluate Final Model on the Test Set (set03) ---\n",
    "    print(f\"\\n--- Final Evaluation on Test Set ({TEST_SET_STR}) ---\")\n",
    "    # Create Test DataLoader for set03\n",
    "    test_dataset_obj = PIEDataset_Cell2(\n",
    "        pie_database_global, TEST_SET_STR, POSE_DATA_DIR_CELL2, SEQ_LEN, PRED_LEN,\n",
    "        scalers_global, streams_to_extract=ALL_POSSIBLE_STREAMS_CELL2,\n",
    "    )\n",
    "    if len(test_dataset_obj) == 0:\n",
    "        print(f\"ERROR: Test dataset ({TEST_SET_STR}) is empty. Cannot perform final evaluation.\")\n",
    "    else:\n",
    "        test_loader = DataLoader(test_dataset_obj, batch_size=BATCH_SIZE, shuffle=False, num_workers=2, pin_memory=True)\n",
    "        print(f\"   ✓ Test DataLoader ready ({len(test_dataset_obj)} samples for {TEST_SET_STR}).\")\n",
    "\n",
    "        # Get probabilities and true labels from the test set (set03)\n",
    "        # The criterion_final is just for calculating loss if needed, not strictly for metrics here\n",
    "        test_eval_results = evaluate_model_performance(\n",
    "            final_model, test_loader, criterion_final, DEVICE, \n",
    "            tune_threshold_on_this_data=True # CRUCIAL: Tune threshold on set03 data to get best F1\n",
    "        )\n",
    "        \n",
    "        final_optimal_threshold_set03 = test_eval_results[\"tuned_threshold_if_any\"]\n",
    "        final_f1_set03 = test_eval_results[\"f1_after_tuning_if_any\"] # This is the F1 after tuning on set03\n",
    "        \n",
    "        # Re-calculate metrics with the tuned threshold for consistent reporting\n",
    "        y_true_set03 = test_eval_results[\"true_labels\"]\n",
    "        y_probs_pos_set03 = test_eval_results[\"positive_class_probs\"]\n",
    "        y_pred_set03_tuned = (y_probs_pos_set03 >= final_optimal_threshold_set03).astype(int)\n",
    "\n",
    "        final_accuracy_set03 = accuracy_score(y_true_set03, y_pred_set03_tuned)\n",
    "        final_precision_set03, final_recall_set03, _, = \\\n",
    "            precision_recall_fscore_support(y_true_set03, y_pred_set03_tuned, average='binary', pos_label=1, zero_division=0)[0:3]\n",
    "        final_auc_set03 = roc_auc_score(y_true_set03, y_probs_pos_set03) if len(np.unique(y_true_set03)) > 1 else float('nan')\n",
    "        \n",
    "        cm_set03_tuned = confusion_matrix(y_true_set03, y_pred_set03_tuned, labels=[0, 1])\n",
    "\n",
    "        print(\"\\n--- Final Metrics on Test Set (set03) with Tuned Threshold ---\")\n",
    "        print(f\"{'Optimal Threshold on Set03':<30}: {final_optimal_threshold_set03:.4f}\")\n",
    "        print(f\"{'F1-score (Maximized on Set03)':<30}: {final_f1_set03:.4f}\")\n",
    "        print(f\"{'Accuracy':<30}: {final_accuracy_set03:.4f}\")\n",
    "        print(f\"{'Precision':<30}: {final_precision_set03:.4f}\")\n",
    "        print(f\"{'Recall':<30}: {final_recall_set03:.4f}\")\n",
    "        print(f\"{'AUC':<30}: {final_auc_set03:.4f}\")\n",
    "\n",
    "        # Display Confusion Matrix for set03\n",
    "        ConfusionMatrixDisplay(cm_set03_tuned, display_labels=[\"Not Crossing\", \"Crossing\"]).plot(cmap=plt.cm.Blues)\n",
    "        plt.title(f\"Confusion Matrix - Test Set (set03)\\nOptimal Threshold: {final_optimal_threshold_set03:.2f}, F1: {final_f1_set03:.4f}\")\n",
    "        plt.show()\n",
    "\n",
    "        # Display learned fusion weights from the final model\n",
    "        if hasattr(final_model, \"fusion_weights\"):\n",
    "            f_weights = torch.softmax(final_model.fusion_weights, 0).detach().cpu().numpy()\n",
    "            print(\"\\n--- Learned Fusion Weights (Final Model) ---\")\n",
    "            for stream_name, weight_val in zip(final_model.active_stream_names, f_weights):\n",
    "                print(f\"{stream_name:<20}: {weight_val:.4f}\")\n",
    "            print(\"-\" * 30)\n",
    "\n",
    "    # --- 6. Plot training curves for the final model (optional) ---\n",
    "    if NUM_EPOCHS_FINAL_TRAINING > 0 :\n",
    "        fig_final, ax_final = plt.subplots(1, 2, figsize=(12, 4))\n",
    "        ax_final[0].plot(range(1, NUM_EPOCHS_FINAL_TRAINING + 1), history_final_model[\"train_loss\"], label=\"Final Model Train Loss\")\n",
    "        ax_final[0].plot(range(1, NUM_EPOCHS_FINAL_TRAINING + 1), history_final_model[\"val_loss_on_hpo_set\"], label=f\"Final Model Val Loss ({VAL_SETS_STR})\")\n",
    "        ax_final[0].set_xlabel(\"Epoch\"); ax_final[0].set_ylabel(\"Loss\"); ax_final[0].set_title(\"Final Model Loss\"); ax_final[0].legend(); ax_final[0].grid(True)\n",
    "        \n",
    "        ax_final[1].plot(range(1, NUM_EPOCHS_FINAL_TRAINING + 1), history_final_model[\"val_f1_on_hpo_set\"], label=f\"Final Model Val F1@0.5 ({VAL_SETS_STR})\")\n",
    "        ax_final[1].set_xlabel(\"Epoch\"); ax_final[1].set_ylabel(\"F1 Score @ 0.5\"); ax_final[1].set_title(f\"Final Model F1 on {VAL_SETS_STR}\"); ax_final[1].legend(); ax_final[1].grid(True)\n",
    "        plt.tight_layout(); plt.show()\n",
    "\n",
    "\n",
    "    # Clean up global variables if needed, though script end will do it\n",
    "    del pie_database_global, scalers_global, balanced_train_data_global\n",
    "    del train_loader_global, val_loader_for_hpo_global, current_input_sizes_global\n",
    "    gc.collect()\n",
    "\n",
    "    print(\"\\n--- CELL 2: Script complete ---\")"
   ]
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "gpu",
   "dataSources": [
    {
     "datasetId": 6993690,
     "sourceId": 11201333,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 6993708,
     "sourceId": 11201362,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 6993722,
     "sourceId": 11201388,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 6993740,
     "sourceId": 11201422,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 6993794,
     "sourceId": 11201506,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 6993809,
     "sourceId": 11201543,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 7034191,
     "sourceId": 11255589,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 7127490,
     "sourceId": 11382982,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 7142036,
     "sourceId": 11402679,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 7333398,
     "sourceId": 11684148,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 7357780,
     "sourceId": 11720877,
     "sourceType": "datasetVersion"
    },
    {
     "modelId": 279383,
     "modelInstanceId": 258142,
     "sourceId": 302300,
     "sourceType": "modelInstanceVersion"
    },
    {
     "modelId": 283333,
     "modelInstanceId": 262207,
     "sourceId": 307831,
     "sourceType": "modelInstanceVersion"
    },
    {
     "modelId": 288527,
     "modelInstanceId": 267476,
     "sourceId": 316944,
     "sourceType": "modelInstanceVersion"
    },
    {
     "modelId": 297682,
     "modelInstanceId": 276781,
     "sourceId": 329886,
     "sourceType": "modelInstanceVersion"
    },
    {
     "modelId": 297702,
     "modelInstanceId": 276800,
     "sourceId": 329908,
     "sourceType": "modelInstanceVersion"
    },
    {
     "isSourceIdPinned": true,
     "modelId": 314775,
     "modelInstanceId": 294156,
     "sourceId": 352620,
     "sourceType": "modelInstanceVersion"
    }
   ],
   "dockerImageVersionId": 30918,
   "isGpuEnabled": true,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 11214.606819,
   "end_time": "2025-05-13T17:03:40.251443",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-05-13T13:56:45.644624",
   "version": "2.6.0"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {
     "029c01b9c5e941ac89ca7f6cf118c981": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "03c12b4a226948c1842e2b4bf4476307": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     },
     "10754b3843dc4a26860dd6c13281bba0": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "1653459da95e49159a95351c9be72b9f": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_029c01b9c5e941ac89ca7f6cf118c981",
       "placeholder": "​",
       "style": "IPY_MODEL_95007bdac1da475c913a391137fe4460",
       "tabbable": null,
       "tooltip": null,
       "value": " 1/? [00:00&lt;00:00,  6.97it/s]"
      }
     },
     "16e2f5efb7f245b0bada2e0229791762": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "227c346828db444f93af0496daa7b882": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "27c527f397854b9ab0b8072c3ac0987d": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_e5c10bab36e14b9fa2fa0f3d427e16e3",
        "IPY_MODEL_4a26ed73230d499bb63e39f97f760aa8",
        "IPY_MODEL_1653459da95e49159a95351c9be72b9f"
       ],
       "layout": "IPY_MODEL_aaebf0a904f445b89c2da80c146de64f",
       "tabbable": null,
       "tooltip": null
      }
     },
     "3296200b45f142a9bfe64816a93079aa": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "38b8046445824ad1902e009c4daa1721": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "3cc54b8cef1349dea5c7f3b5681ef2cb": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_51e24040a4a64e088727f4911f4de2d1",
       "placeholder": "​",
       "style": "IPY_MODEL_8baa83f1b1404182ac3a49c45ae8d7b5",
       "tabbable": null,
       "tooltip": null,
       "value": ""
      }
     },
     "40064fd7e3694c7e8829155faf0b6ad9": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_227c346828db444f93af0496daa7b882",
       "placeholder": "​",
       "style": "IPY_MODEL_bcfd5610f9a24f2883a196ca56c2029a",
       "tabbable": null,
       "tooltip": null,
       "value": " 2/? [00:00&lt;00:00, 15.78it/s]"
      }
     },
     "4a26ed73230d499bb63e39f97f760aa8": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "info",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_fb9893d1d21f4db6ad44818128290cc3",
       "max": 1.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_7abd11ad5a6c42c39353244a4a6ff6e8",
       "tabbable": null,
       "tooltip": null,
       "value": 1.0
      }
     },
     "4bc3aea8e144486eaa1d09640702bc18": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "4f2265fe6e654755a07f5fca0878ad0e": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_8d626a2b189443d7860318cfbfa31ba1",
        "IPY_MODEL_ca9bb964b95f43429dfbb678cd3c043a",
        "IPY_MODEL_40064fd7e3694c7e8829155faf0b6ad9"
       ],
       "layout": "IPY_MODEL_f2356ac67d5846d3bb5c9cf3d0c87df6",
       "tabbable": null,
       "tooltip": null
      }
     },
     "51e24040a4a64e088727f4911f4de2d1": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "520b04611bea4113b495749954284cb4": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "5660819a9e924adcaf0058e9128a9c26": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     },
     "59f4a5c07cae4e7b9d324434a5a4b5a6": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_8516a70ad2674bd090c8b0e6911aa611",
       "placeholder": "​",
       "style": "IPY_MODEL_38b8046445824ad1902e009c4daa1721",
       "tabbable": null,
       "tooltip": null,
       "value": " 14/? [00:00&lt;00:00, 23.20it/s]"
      }
     },
     "5d2f9d6a651e4492a7d281bb0d0029fc": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "5f8b378487aa4be4bdae6e961ed27381": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "610e1d52c7b14d96a94bdc217eec7558": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_3cc54b8cef1349dea5c7f3b5681ef2cb",
        "IPY_MODEL_84978ad883c041c18a47d39356e47445",
        "IPY_MODEL_59f4a5c07cae4e7b9d324434a5a4b5a6"
       ],
       "layout": "IPY_MODEL_bcf9d174b1eb4ca9a9bc0c4af0b80981",
       "tabbable": null,
       "tooltip": null
      }
     },
     "73027980234a46a395f92fa1bc2e6e48": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "73c1ca744d54462798d1ad6ee7962fe1": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "7abd11ad5a6c42c39353244a4a6ff6e8": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     },
     "7b5f582d22754cd8af03d198b3a0d003": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_89d333fd5f7b4adc83d2e615eae5b506",
        "IPY_MODEL_be4cf2f104474ec29f7c24cba39939cc",
        "IPY_MODEL_cf9fd70c0e4a43d5832cdf542d0468b5"
       ],
       "layout": "IPY_MODEL_4bc3aea8e144486eaa1d09640702bc18",
       "tabbable": null,
       "tooltip": null
      }
     },
     "84978ad883c041c18a47d39356e47445": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "info",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_eb324b546f44494688dd4950eeeda56b",
       "max": 1.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_e341496c857b4db88ed0623eeff140bc",
       "tabbable": null,
       "tooltip": null,
       "value": 1.0
      }
     },
     "8516a70ad2674bd090c8b0e6911aa611": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "89d333fd5f7b4adc83d2e615eae5b506": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_10754b3843dc4a26860dd6c13281bba0",
       "placeholder": "​",
       "style": "IPY_MODEL_73027980234a46a395f92fa1bc2e6e48",
       "tabbable": null,
       "tooltip": null,
       "value": "Best trial: 11. Best value: 0.824754: 100%"
      }
     },
     "8b1b53ebb8754fa196d888ad0aa11e0a": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "20px"
      }
     },
     "8baa83f1b1404182ac3a49c45ae8d7b5": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "8d626a2b189443d7860318cfbfa31ba1": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_d5b3f6fac07c43e09eb711e7ea9986e2",
       "placeholder": "​",
       "style": "IPY_MODEL_9656717d21b7428199ca4c8d86e3796e",
       "tabbable": null,
       "tooltip": null,
       "value": ""
      }
     },
     "95007bdac1da475c913a391137fe4460": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "9656717d21b7428199ca4c8d86e3796e": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "9681bd02bd184a3bbb24a6a65a89f28f": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "a0e803962d2449a3b6fa730741856dcf": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "aaade724ef0346f3bd0c6bb451003e76": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "aaebf0a904f445b89c2da80c146de64f": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": "hidden",
       "width": null
      }
     },
     "b59afb393eac4a60915d32e75637dd32": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     },
     "b93a0aee3bf8433b9d88d5259a0c659c": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_ec984581133b42b8818692359973473f",
       "placeholder": "​",
       "style": "IPY_MODEL_a0e803962d2449a3b6fa730741856dcf",
       "tabbable": null,
       "tooltip": null,
       "value": "seq: 100%"
      }
     },
     "bcf9d174b1eb4ca9a9bc0c4af0b80981": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": "hidden",
       "width": null
      }
     },
     "bcfd5610f9a24f2883a196ca56c2029a": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "be4cf2f104474ec29f7c24cba39939cc": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "success",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_3296200b45f142a9bfe64816a93079aa",
       "max": 15.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_b59afb393eac4a60915d32e75637dd32",
       "tabbable": null,
       "tooltip": null,
       "value": 15.0
      }
     },
     "c1b99da5fc7b4fffb57ca6a3a527e009": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_b93a0aee3bf8433b9d88d5259a0c659c",
        "IPY_MODEL_f61c0d7f1f004ebb8fd1de637a1664d2",
        "IPY_MODEL_dbe1ef4343744c50a6de30a72b96ddf1"
       ],
       "layout": "IPY_MODEL_520b04611bea4113b495749954284cb4",
       "tabbable": null,
       "tooltip": null
      }
     },
     "ca9bb964b95f43429dfbb678cd3c043a": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "info",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_8b1b53ebb8754fa196d888ad0aa11e0a",
       "max": 1.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_5660819a9e924adcaf0058e9128a9c26",
       "tabbable": null,
       "tooltip": null,
       "value": 1.0
      }
     },
     "cf9fd70c0e4a43d5832cdf542d0468b5": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_73c1ca744d54462798d1ad6ee7962fe1",
       "placeholder": "​",
       "style": "IPY_MODEL_16e2f5efb7f245b0bada2e0229791762",
       "tabbable": null,
       "tooltip": null,
       "value": " 15/15 [2:29:26&lt;00:00, 438.67s/it]"
      }
     },
     "d5b3f6fac07c43e09eb711e7ea9986e2": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "dbe1ef4343744c50a6de30a72b96ddf1": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_aaade724ef0346f3bd0c6bb451003e76",
       "placeholder": "​",
       "style": "IPY_MODEL_5f8b378487aa4be4bdae6e961ed27381",
       "tabbable": null,
       "tooltip": null,
       "value": " 333454/333454 [13:11&lt;00:00, 412.40it/s]"
      }
     },
     "e341496c857b4db88ed0623eeff140bc": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     },
     "e5c10bab36e14b9fa2fa0f3d427e16e3": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_9681bd02bd184a3bbb24a6a65a89f28f",
       "placeholder": "​",
       "style": "IPY_MODEL_f39bcbdab23b46baa948e7846e84175c",
       "tabbable": null,
       "tooltip": null,
       "value": ""
      }
     },
     "eb324b546f44494688dd4950eeeda56b": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "20px"
      }
     },
     "ec984581133b42b8818692359973473f": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "f2356ac67d5846d3bb5c9cf3d0c87df6": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": "hidden",
       "width": null
      }
     },
     "f39bcbdab23b46baa948e7846e84175c": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "f61c0d7f1f004ebb8fd1de637a1664d2": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "success",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_5d2f9d6a651e4492a7d281bb0d0029fc",
       "max": 333454.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_03c12b4a226948c1842e2b4bf4476307",
       "tabbable": null,
       "tooltip": null,
       "value": 333454.0
      }
     },
     "fb9893d1d21f4db6ad44818128290cc3": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "20px"
      }
     }
    },
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
