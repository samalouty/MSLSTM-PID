{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "42e13d9f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-13T16:39:28.886912Z",
     "iopub.status.busy": "2025-05-13T16:39:28.886650Z",
     "iopub.status.idle": "2025-05-13T16:39:35.749701Z",
     "shell.execute_reply": "2025-05-13T16:39:35.748663Z"
    },
    "papermill": {
     "duration": 6.870845,
     "end_time": "2025-05-13T16:39:35.751557",
     "exception": false,
     "start_time": "2025-05-13T16:39:28.880712",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Cloning into 'PIE'...\r\n",
      "remote: Enumerating objects: 178, done.\u001b[K\r\n",
      "remote: Counting objects: 100% (93/93), done.\u001b[K\r\n",
      "remote: Compressing objects: 100% (74/74), done.\u001b[K\r\n",
      "remote: Total 178 (delta 32), reused 75 (delta 17), pack-reused 85 (from 1)\u001b[K\r\n",
      "Receiving objects: 100% (178/178), 144.63 MiB | 37.20 MiB/s, done.\r\n",
      "Resolving deltas: 100% (73/73), done.\r\n",
      "Updating files: 100% (41/41), done.\r\n",
      "unzip:  cannot find or open /content/PIE/annotations/annotations.zip, /content/PIE/annotations/annotations.zip.zip or /content/PIE/annotations/annotations.zip.ZIP.\r\n",
      "unzip:  cannot find or open /content/PIE/annotations/annotations_vehicle.zip, /content/PIE/annotations/annotations_vehicle.zip.zip or /content/PIE/annotations/annotations_vehicle.zip.ZIP.\r\n"
     ]
    }
   ],
   "source": [
    "!git clone https://github.com/aras62/PIE.git\n",
    "!unzip /content/PIE/annotations/annotations.zip -d /content/PIE\n",
    "!unzip /content/PIE/annotations/annotations_vehicle.zip -d /content/PIE\n",
    "# !git clone https://github.com/hustvl/YOLOP.git\n",
    "!mkdir /kaggle/working/PIE/content"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "edabc439",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-13T16:39:35.764781Z",
     "iopub.status.busy": "2025-05-13T16:39:35.764514Z",
     "iopub.status.idle": "2025-05-13T16:39:41.358650Z",
     "shell.execute_reply": "2025-05-13T16:39:41.357644Z"
    },
    "papermill": {
     "duration": 5.602433,
     "end_time": "2025-05-13T16:39:41.360353",
     "exception": false,
     "start_time": "2025-05-13T16:39:35.757920",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m1.0/1.0 MB\u001b[0m \u001b[31m3.7 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\r\n",
      "\u001b[?25h"
     ]
    }
   ],
   "source": [
    "!pip install -q ultralytics opencv-python-headless "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "0ae7e359",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-13T16:39:41.373347Z",
     "iopub.status.busy": "2025-05-13T16:39:41.373057Z",
     "iopub.status.idle": "2025-05-13T16:39:47.213970Z",
     "shell.execute_reply": "2025-05-13T16:39:47.213282Z"
    },
    "papermill": {
     "duration": 5.848948,
     "end_time": "2025-05-13T16:39:47.215517",
     "exception": false,
     "start_time": "2025-05-13T16:39:41.366569",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Creating new Ultralytics Settings v0.0.6 file ✅ \n",
      "View Ultralytics Settings with 'yolo settings' or at '/root/.config/Ultralytics/settings.json'\n",
      "Update Settings with 'yolo settings key=value', i.e. 'yolo settings runs_dir=path/to/dir'. For help see https://docs.ultralytics.com/quickstart/#ultralytics-settings.\n"
     ]
    }
   ],
   "source": [
    "import torch\n",
    "import torch.nn as nn\n",
    "import torch.optim as optim\n",
    "from torch.utils.data import Dataset, DataLoader\n",
    "import xml.etree.ElementTree as ET\n",
    "import os\n",
    "import numpy as np\n",
    "from sklearn.metrics import accuracy_score, precision_recall_fscore_support, roc_auc_score, confusion_matrix, ConfusionMatrixDisplay\n",
    "from tqdm.notebook import tqdm\n",
    "import random\n",
    "import math\n",
    "import zipfile\n",
    "import cv2\n",
    "from ultralytics import YOLO\n",
    "import pandas as pd \n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import time"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "6b8575d1",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-13T16:39:47.228590Z",
     "iopub.status.busy": "2025-05-13T16:39:47.228242Z",
     "iopub.status.idle": "2025-05-13T16:39:48.735870Z",
     "shell.execute_reply": "2025-05-13T16:39:48.734924Z"
    },
    "papermill": {
     "duration": 1.515324,
     "end_time": "2025-05-13T16:39:48.737217",
     "exception": false,
     "start_time": "2025-05-13T16:39:47.221893",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Unzipped successfully.\n"
     ]
    }
   ],
   "source": [
    "zip_path = \"/kaggle/working/PIE/annotations/annotations.zip\"\n",
    "extract_to = \"/kaggle/working/PIE/annotations/\"\n",
    "\n",
    "if os.path.exists(extract_to + 'annotations'):\n",
    "    print(\"Exists already. Not unzipping.\")\n",
    "else:\n",
    "    with zipfile.ZipFile(zip_path, 'r') as zip_ref:\n",
    "        zip_ref.extractall(extract_to)\n",
    "    print(\"Unzipped successfully.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "ffec2579",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-13T16:39:48.750117Z",
     "iopub.status.busy": "2025-05-13T16:39:48.749866Z",
     "iopub.status.idle": "2025-05-13T16:39:49.462981Z",
     "shell.execute_reply": "2025-05-13T16:39:49.461864Z"
    },
    "papermill": {
     "duration": 0.720831,
     "end_time": "2025-05-13T16:39:49.464389",
     "exception": false,
     "start_time": "2025-05-13T16:39:48.743558",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Unzipped successfully.\n"
     ]
    }
   ],
   "source": [
    "zip_path = \"/kaggle/working/PIE/annotations/annotations_vehicle.zip\"\n",
    "extract_to = \"/kaggle/working/PIE/annotations/\"\n",
    "\n",
    "if os.path.exists(extract_to + 'annotations_vehicle'):\n",
    "    print(\"Exists already. Not unzipping.\")\n",
    "else:\n",
    "    with zipfile.ZipFile(zip_path, 'r') as zip_ref:\n",
    "        zip_ref.extractall(extract_to)\n",
    "    print(\"Unzipped successfully.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "a2205552",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-13T16:39:49.477191Z",
     "iopub.status.busy": "2025-05-13T16:39:49.476923Z",
     "iopub.status.idle": "2025-05-13T16:39:49.488881Z",
     "shell.execute_reply": "2025-05-13T16:39:49.488128Z"
    },
    "papermill": {
     "duration": 0.019481,
     "end_time": "2025-05-13T16:39:49.490057",
     "exception": false,
     "start_time": "2025-05-13T16:39:49.470576",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Unzipped successfully.\n"
     ]
    }
   ],
   "source": [
    "zip_path = \"/kaggle/working/PIE/annotations/annotations_attributes.zip\"\n",
    "extract_to = \"/kaggle/working/PIE/annotations/\"\n",
    "\n",
    "if os.path.exists(extract_to + \"annotations_attributes\"):\n",
    "    print(\"Exists already. Not unzipping.\")\n",
    "else:\n",
    "    with zipfile.ZipFile(zip_path, 'r') as zip_ref:\n",
    "        zip_ref.extractall(extract_to)\n",
    "    print(\"Unzipped successfully.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "daa50897",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-13T16:39:49.502879Z",
     "iopub.status.busy": "2025-05-13T16:39:49.502653Z",
     "iopub.status.idle": "2025-05-13T16:46:24.535048Z",
     "shell.execute_reply": "2025-05-13T16:46:24.534218Z"
    },
    "papermill": {
     "duration": 395.047332,
     "end_time": "2025-05-13T16:46:24.543281",
     "exception": false,
     "start_time": "2025-05-13T16:39:49.495949",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- CELL 1: DATA PREPARATION ---\n",
      "Loading PIE database cache …\n",
      "✓ PIE DB loaded.\n",
      "\n",
      "Computing scalers …\n",
      "Scalers: {'ego_speed_mean': 15.68396562615558, 'ego_speed_std': 14.917402166954025, 'accX_mean': -0.028554922673878137, 'accX_std': 0.07941281254821907, 'accY_mean': -0.3574035324938731, 'accY_std': 0.9129782108852527, 'gyroZ_mean': -0.07685927490915238, 'gyroZ_std': 3.81257205015616}\n",
      "\n",
      "Extracting training sequences (all streams) …\n",
      "Loading pose PKLs …\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "570878046a074cf5b7fa6b5f7e28d5eb",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "0it [00:00, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "5ea9f7e92d03455fb831abf14ae343b4",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "0it [00:00, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "14985063ee9a4e539b572c73cf0b7814",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "0it [00:00, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "f500830f328645e291d4e02ec26d42f6",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "0it [00:00, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Enumerating sequences …\n",
      "Total sequences: 176593\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "da43f7f7f985452daa2d7ec21cc79d93",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "seq:   0%|          | 0/176593 [00:00<?, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Raw training samples: 176593\n",
      "Balanced: 1s=31387 | 0s=31387\n",
      "\n",
      "Saving balanced data …\n",
      "✓ /kaggle/working/balanced_train_data.pkl\n",
      "Saving scalers …\n",
      "✓ /kaggle/working/scalers.pkl\n",
      "\n",
      "--- CELL 1: DATA PREPARATION COMPLETE ---\n"
     ]
    }
   ],
   "source": [
    "# -----------------------------------------------------------------------------\n",
    "# CELL 1: DATA PREPARATION & BALANCING  (run once before training)\n",
    "# -----------------------------------------------------------------------------\n",
    "#  This cell:\n",
    "#    1. Loads (or regenerates) the PIE database\n",
    "#    2. Computes per-signal standardisation scalers\n",
    "#    3. Extracts ALL training sequences for every stream\n",
    "#    4. Balances the dataset 50 / 50 on the crossing label\n",
    "#    5. Writes two pickles:\n",
    "#         - /kaggle/working/balanced_train_data.pkl\n",
    "#         - /kaggle/working/scalers.pkl\n",
    "# -----------------------------------------------------------------------------\n",
    "\n",
    "import os\n",
    "import sys\n",
    "import time\n",
    "import pickle\n",
    "import gc\n",
    "from pathlib import Path\n",
    "\n",
    "import cv2                               # used internally by PIE utilities\n",
    "import numpy as np\n",
    "import torch\n",
    "from torch.utils.data import Dataset\n",
    "from tqdm.notebook import tqdm\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                                PIE utilities                                 #\n",
    "# -----------------------------------------------------------------------------#\n",
    "pie_utilities_path = \"/kaggle/working/PIE/utilities\"\n",
    "if pie_utilities_path not in sys.path:\n",
    "    sys.path.insert(0, pie_utilities_path)\n",
    "\n",
    "try:\n",
    "    from pie_data import PIE\n",
    "except ImportError as e:\n",
    "    print(\n",
    "        f\"[WARN] Could not import PIE from {pie_utilities_path}. \"\n",
    "        f\"If the DB cache already exists this is fine.\\n→ {e}\"\n",
    "    )\n",
    "    PIE = None\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                              configuration                                   #\n",
    "# -----------------------------------------------------------------------------#\n",
    "PIE_ROOT_PATH           = \"/kaggle/working/PIE\"\n",
    "POSE_DATA_DIR           = \"/kaggle/input/pose-data/extracted_poses2\"\n",
    "PIE_DATABASE_CACHE_PATH = \"/kaggle/input/pie-database/pie_database.pkl\"\n",
    "\n",
    "TRAIN_SETS_STR = [\"set01\", \"set02\", \"set05\", \"set06\"]\n",
    "\n",
    "BALANCED_DATA_PKL_PATH  = \"/kaggle/working/balanced_train_data.pkl\"\n",
    "SCALERS_PKL_PATH        = \"/kaggle/working/scalers.pkl\"\n",
    "\n",
    "# Streams used throughout the project ----------------------------------------\n",
    "ALL_POSSIBLE_STREAMS = [\n",
    "    \"bbox\",\n",
    "    \"pose\",\n",
    "    \"ego_speed\",\n",
    "    \"ego_acc\",\n",
    "    \"ego_gyro\",\n",
    "    \"ped_action\",\n",
    "    \"ped_look\",\n",
    "    \"ped_occlusion\",\n",
    "    \"traffic_light\",\n",
    "    \"static_context\",\n",
    "]\n",
    "\n",
    "# Feature sizes & categorical constants --------------------------------------\n",
    "SEQ_LEN, PRED_LEN = 30, 1\n",
    "\n",
    "INPUT_SIZE_BBOX       = 4\n",
    "INPUT_SIZE_POSE       = 34\n",
    "INPUT_SIZE_EGO_SPEED  = 1\n",
    "INPUT_SIZE_EGO_ACC    = 2\n",
    "INPUT_SIZE_EGO_GYRO   = 1\n",
    "INPUT_SIZE_PED_ACTION = 1\n",
    "INPUT_SIZE_PED_LOOK   = 1\n",
    "INPUT_SIZE_PED_OCC    = 1\n",
    "INPUT_SIZE_TL_STATE   = 4\n",
    "\n",
    "NUM_SIGNALIZED_CATS   = 4\n",
    "NUM_INTERSECTION_CATS = 5\n",
    "NUM_AGE_CATS          = 4\n",
    "NUM_GENDER_CATS       = 3\n",
    "NUM_TRAFFIC_DIR_CATS  = 2\n",
    "\n",
    "LANE_CATEGORIES = {1: 0, 2: 1, 3: 2, 4: 3, 5: 4, 6: 4, 7: 4, 8: 4}\n",
    "NUM_LANE_CATS   = len(set(LANE_CATEGORIES.values()))\n",
    "\n",
    "INPUT_SIZE_STATIC = (\n",
    "    NUM_SIGNALIZED_CATS\n",
    "    + NUM_INTERSECTION_CATS\n",
    "    + NUM_AGE_CATS\n",
    "    + NUM_GENDER_CATS\n",
    "    + NUM_TRAFFIC_DIR_CATS\n",
    "    + NUM_LANE_CATS\n",
    ")  # → 23\n",
    "\n",
    "TL_STATE_MAP = {\"__undefined__\": 0, \"red\": 1, \"yellow\": 2, \"green\": 3}\n",
    "NUM_TL_STATES = len(TL_STATE_MAP)\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                               helper utils                                   #\n",
    "# -----------------------------------------------------------------------------#\n",
    "\n",
    "\n",
    "def to_one_hot(index: int, num_classes: int) -> np.ndarray:\n",
    "    vec = np.zeros(num_classes, dtype=np.float32)\n",
    "    vec[int(np.clip(index, 0, num_classes - 1))] = 1.0\n",
    "    return vec\n",
    "\n",
    "\n",
    "def balance_samples_count(seq_data: dict, label_key: str, seed: int = 42) -> dict:\n",
    "    \"\"\"Undersample majority class so positive and negative labels are equal.\"\"\"\n",
    "    labels = [lbl[0] for lbl in seq_data[label_key]]\n",
    "    n_pos  = int(np.sum(labels))\n",
    "    n_neg  = len(labels) - n_pos\n",
    "\n",
    "    if n_pos == n_neg:\n",
    "        print(\"Dataset already balanced.\")\n",
    "        return seq_data.copy()\n",
    "\n",
    "    majority_label    = 0 if n_neg > n_pos else 1\n",
    "    minority_count    = min(n_pos, n_neg)\n",
    "    majority_indices  = np.where(np.array(labels) == majority_label)[0]\n",
    "    minority_indices  = np.where(np.array(labels) != majority_label)[0]\n",
    "\n",
    "    rng = np.random.default_rng(seed)\n",
    "    keep_majority = rng.choice(majority_indices, size=minority_count, replace=False)\n",
    "    final_indices = np.concatenate([minority_indices, keep_majority])\n",
    "    rng.shuffle(final_indices)\n",
    "\n",
    "    balanced = {}\n",
    "    for k, v in seq_data.items():\n",
    "        balanced[k] = [v[i] for i in final_indices]\n",
    "\n",
    "    print(f\"Balanced: 1s={minority_count} | 0s={minority_count}\")\n",
    "    return balanced\n",
    "\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                                PIEDataset                                    #\n",
    "# -----------------------------------------------------------------------------#\n",
    "class PIEDataset(Dataset):\n",
    "    \"\"\"\n",
    "    Lightweight dataset that can generate any subset of the PIE feature streams.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(\n",
    "        self,\n",
    "        pie_db: dict,\n",
    "        set_names: list[str],\n",
    "        pose_dir: str,\n",
    "        seq_len: int,\n",
    "        pred_len: int,\n",
    "        scalers: dict,\n",
    "        streams_to_generate: list[str],\n",
    "    ):\n",
    "        self.pie_db            = pie_db\n",
    "        self.set_names         = set_names\n",
    "        self.pose_dir          = pose_dir\n",
    "        self.seq_len           = seq_len\n",
    "        self.pred_len          = pred_len\n",
    "        self.scalers           = scalers\n",
    "        self.streams           = streams_to_generate\n",
    "        self._input_sizes      = self._build_input_size_map()\n",
    "        self.all_pose_data     = {}\n",
    "        self.sequences         = []\n",
    "\n",
    "        if \"pose\" in self.streams:\n",
    "            self._load_pose_pkls()\n",
    "        self._enumerate_sequences()\n",
    "\n",
    "    # ------------------------ internal helpers -------------------------------\n",
    "    def _build_input_size_map(self) -> dict:\n",
    "        special = {\n",
    "            \"TRAFFIC_LIGHT\": \"TL_STATE\",\n",
    "            \"STATIC_CONTEXT\": \"STATIC\",\n",
    "            \"EGO_SPEED\": \"EGO_SPEED\",\n",
    "            \"EGO_ACC\": \"EGO_ACC\",\n",
    "            \"EGO_GYRO\": \"EGO_GYRO\",\n",
    "            \"PED_ACTION\": \"PED_ACTION\",\n",
    "            \"PED_LOOK\": \"PED_LOOK\",\n",
    "            \"PED_OCCLUSION\": \"PED_OCC\",\n",
    "        }\n",
    "        sizes = {}\n",
    "        for s in ALL_POSSIBLE_STREAMS:\n",
    "            const = f\"INPUT_SIZE_{special.get(s.upper(), s.upper())}\"\n",
    "            if s == \"bbox\":\n",
    "                const = \"INPUT_SIZE_BBOX\"\n",
    "            elif s == \"pose\":\n",
    "                const = \"INPUT_SIZE_POSE\"\n",
    "            sizes[s] = globals().get(const, 1)\n",
    "        return sizes\n",
    "\n",
    "    def _load_pose_pkls(self):\n",
    "        print(\"Loading pose PKLs …\")\n",
    "        for set_id in self.set_names:\n",
    "            set_dir = Path(self.pose_dir) / set_id\n",
    "            if not set_dir.is_dir():\n",
    "                continue\n",
    "            self.all_pose_data[set_id] = {}\n",
    "            for pkl_path in tqdm(set_dir.glob(f\"{set_id}_*_poses.pkl\"), leave=False):\n",
    "                try:\n",
    "                    with open(pkl_path, \"rb\") as fp:\n",
    "                        loaded = pickle.load(fp)\n",
    "                except Exception as e:\n",
    "                    print(f\"[pose load] {pkl_path}: {e}\")\n",
    "                    continue\n",
    "\n",
    "                if len(loaded) != 1:\n",
    "                    continue\n",
    "                (key, data), *_ = loaded.items()\n",
    "                vid = \"_\".join(key.split(\"_\")[1:])\n",
    "                if vid in self.pie_db.get(set_id, {}):\n",
    "                    self.all_pose_data[set_id][vid] = data\n",
    "\n",
    "    def _enumerate_sequences(self):\n",
    "        print(\"Enumerating sequences …\")\n",
    "        for set_id in self.set_names:\n",
    "            for vid, vdb in self.pie_db.get(set_id, {}).items():\n",
    "                for pid, pdb in vdb.get(\"ped_annotations\", {}).items():\n",
    "                    frames = pdb.get(\"frames\", [])\n",
    "                    if len(frames) < self.seq_len + self.pred_len:\n",
    "                        continue\n",
    "                    frames = sorted(frames)\n",
    "                    for i in range(len(frames) - self.seq_len - self.pred_len + 1):\n",
    "                        start = frames[i]\n",
    "                        obs_end = frames[i + self.seq_len - 1]\n",
    "                        if obs_end - start != self.seq_len - 1:\n",
    "                            continue\n",
    "                        target = frames[i + self.seq_len + self.pred_len - 1]\n",
    "                        if target - obs_end != self.pred_len:\n",
    "                            continue\n",
    "                        self.sequences.append((set_id, vid, pid, start))\n",
    "        print(f\"Total sequences: {len(self.sequences)}\")\n",
    "\n",
    "    # ------------------ Dataset API ------------------------------------------\n",
    "    def __len__(self):\n",
    "        return len(self.sequences)\n",
    "\n",
    "    def __getitem__(self, idx: int):\n",
    "        set_id, vid, pid, start = self.sequences[idx]\n",
    "        vdb  = self.pie_db[set_id][vid]\n",
    "        pdb  = vdb[\"ped_annotations\"][pid]\n",
    "        ego  = vdb.get(\"vehicle_annotations\", {})\n",
    "        tldb = vdb.get(\"traffic_annotations\", {})\n",
    "\n",
    "        frame_nums = list(range(start, start + self.seq_len))\n",
    "        target_f   = start + self.seq_len + self.pred_len - 1\n",
    "\n",
    "        # label ---------------------------------------------------------------\n",
    "        label = 0\n",
    "        if (\n",
    "            \"frames\" in pdb\n",
    "            and \"behavior\" in pdb\n",
    "            and \"cross\" in pdb[\"behavior\"]\n",
    "            and target_f in pdb[\"frames\"]\n",
    "        ):\n",
    "            try:\n",
    "                j = pdb[\"frames\"].index(target_f)\n",
    "                label = pdb[\"behavior\"][\"cross\"][j]\n",
    "                if label == -1:\n",
    "                    label = 0\n",
    "            except (ValueError, IndexError):\n",
    "                pass\n",
    "\n",
    "        # static context ------------------------------------------------------\n",
    "        static_vec = np.zeros(INPUT_SIZE_STATIC, np.float32)\n",
    "        if \"static_context\" in self.streams:\n",
    "            attr  = pdb.get(\"attributes\", {})\n",
    "            sig   = attr.get(\"signalized\", 0)\n",
    "            intr  = attr.get(\"intersection\", 0)\n",
    "            age   = attr.get(\"age\", 2)\n",
    "            gen   = attr.get(\"gender\", 0)\n",
    "            tdir  = int(attr.get(\"traffic_direction\", 0))\n",
    "            ln    = attr.get(\"num_lanes\", 2)\n",
    "            lncat = LANE_CATEGORIES.get(ln, LANE_CATEGORIES[max(LANE_CATEGORIES)])\n",
    "            static_vec = np.concatenate(\n",
    "                [\n",
    "                    to_one_hot(sig,  NUM_SIGNALIZED_CATS),\n",
    "                    to_one_hot(intr, NUM_INTERSECTION_CATS),\n",
    "                    to_one_hot(age,  NUM_AGE_CATS),\n",
    "                    to_one_hot(gen,  NUM_GENDER_CATS),\n",
    "                    to_one_hot(tdir, NUM_TRAFFIC_DIR_CATS),\n",
    "                    to_one_hot(lncat, NUM_LANE_CATS),\n",
    "                ]\n",
    "            ).astype(np.float32)\n",
    "\n",
    "        # per-frame feature assembly -----------------------------------------\n",
    "        feats = {s: [] for s in self.streams}\n",
    "\n",
    "        for fn in frame_nums:\n",
    "            fidx = -1\n",
    "            if \"frames\" in pdb:\n",
    "                try:\n",
    "                    fidx = pdb[\"frames\"].index(fn)\n",
    "                except ValueError:\n",
    "                    pass\n",
    "\n",
    "            ego_f = ego.get(fn, {})\n",
    "\n",
    "            # bbox ----------------------------------------------------------\n",
    "            if \"bbox\" in self.streams:\n",
    "                bb = np.zeros(INPUT_SIZE_BBOX, np.float32)\n",
    "                if (\n",
    "                    fidx != -1\n",
    "                    and \"bbox\" in pdb\n",
    "                    and len(pdb[\"bbox\"]) > fidx\n",
    "                ):\n",
    "                    try:\n",
    "                        x1, y1, x2, y2 = pdb[\"bbox\"][fidx]\n",
    "                        w_img = vdb.get(\"width\", 1920)\n",
    "                        h_img = vdb.get(\"height\", 1080)\n",
    "                        if w_img > 0 and h_img > 0:\n",
    "                            cx = ((x1 + x2) / 2) / w_img\n",
    "                            cy = ((y1 + y2) / 2) / h_img\n",
    "                            w  = (x2 - x1) / w_img\n",
    "                            h  = (y2 - y1) / h_img\n",
    "                            if 0 < w and 0 < h and 0 <= cx <= 1 and 0 <= cy <= 1:\n",
    "                                bb = np.array([cx, cy, w, h], np.float32)\n",
    "                    except Exception:\n",
    "                        pass\n",
    "                feats[\"bbox\"].append(bb)\n",
    "\n",
    "            # pose ----------------------------------------------------------\n",
    "            if \"pose\" in self.streams:\n",
    "                pvec = np.zeros(INPUT_SIZE_POSE, np.float32)\n",
    "                pose_set = self.all_pose_data.get(set_id, {}).get(vid, {})\n",
    "                p_loaded = pose_set.get(fn, {}).get(pid)\n",
    "                if (\n",
    "                    isinstance(p_loaded, np.ndarray)\n",
    "                    and p_loaded.shape == (INPUT_SIZE_POSE,)\n",
    "                ):\n",
    "                    pvec = p_loaded\n",
    "                feats[\"pose\"].append(pvec)\n",
    "\n",
    "            # ego signals ---------------------------------------------------\n",
    "            if \"ego_speed\" in self.streams:\n",
    "                s = ego_f.get(\"OBD_speed\", 0.0) or ego_f.get(\"GPS_speed\", 0.0)\n",
    "                s = (s - self.scalers.get(\"ego_speed_mean\", 0.0)) / self.scalers.get(\n",
    "                    \"ego_speed_std\", 1.0\n",
    "                )\n",
    "                feats[\"ego_speed\"].append([s])\n",
    "\n",
    "            if \"ego_acc\" in self.streams:\n",
    "                ax = ego_f.get(\"accX\", 0.0)\n",
    "                ay = ego_f.get(\"accY\", 0.0)\n",
    "                ax = (ax - self.scalers.get(\"accX_mean\", 0.0)) / self.scalers.get(\n",
    "                    \"accX_std\", 1.0\n",
    "                )\n",
    "                ay = (ay - self.scalers.get(\"accY_mean\", 0.0)) / self.scalers.get(\n",
    "                    \"accY_std\", 1.0\n",
    "                )\n",
    "                feats[\"ego_acc\"].append([ax, ay])\n",
    "\n",
    "            if \"ego_gyro\" in self.streams:\n",
    "                gz = ego_f.get(\"gyroZ\", 0.0)\n",
    "                gz = (gz - self.scalers.get(\"gyroZ_mean\", 0.0)) / self.scalers.get(\n",
    "                    \"gyroZ_std\", 1.0\n",
    "                )\n",
    "                feats[\"ego_gyro\"].append([gz])\n",
    "\n",
    "            # pedestrian behaviour -----------------------------------------\n",
    "            if \"ped_action\" in self.streams:\n",
    "                action = (\n",
    "                    pdb[\"behavior\"][\"action\"][fidx]\n",
    "                    if fidx != -1\n",
    "                    and \"behavior\" in pdb\n",
    "                    and \"action\" in pdb[\"behavior\"]\n",
    "                    and len(pdb[\"behavior\"][\"action\"]) > fidx\n",
    "                    else 0\n",
    "                )\n",
    "                feats[\"ped_action\"].append([float(action)])\n",
    "\n",
    "            if \"ped_look\" in self.streams:\n",
    "                look = (\n",
    "                    pdb[\"behavior\"][\"look\"][fidx]\n",
    "                    if fidx != -1\n",
    "                    and \"behavior\" in pdb\n",
    "                    and \"look\" in pdb[\"behavior\"]\n",
    "                    and len(pdb[\"behavior\"][\"look\"]) > fidx\n",
    "                    else 0\n",
    "                )\n",
    "                feats[\"ped_look\"].append([float(look)])\n",
    "\n",
    "            if \"ped_occlusion\" in self.streams:\n",
    "                occ = (\n",
    "                    float(pdb[\"occlusion\"][fidx]) / 2.0\n",
    "                    if fidx != -1\n",
    "                    and \"occlusion\" in pdb\n",
    "                    and len(pdb[\"occlusion\"]) > fidx\n",
    "                    else 0.0\n",
    "                )\n",
    "                feats[\"ped_occlusion\"].append([occ])\n",
    "\n",
    "            # traffic light -------------------------------------------------\n",
    "            if \"traffic_light\" in self.streams:\n",
    "                tl_state = 0\n",
    "                for obj in tldb.values():\n",
    "                    if obj.get(\"obj_class\") != \"traffic_light\":\n",
    "                        continue\n",
    "                    if \"frames\" not in obj or \"state\" not in obj:\n",
    "                        continue\n",
    "                    try:\n",
    "                        j = obj[\"frames\"].index(fn)\n",
    "                        if obj[\"state\"][j] != 0:\n",
    "                            tl_state = obj[\"state\"][j]\n",
    "                            break\n",
    "                    except (ValueError, IndexError):\n",
    "                        continue\n",
    "                feats[\"traffic_light\"].append(to_one_hot(tl_state, NUM_TL_STATES))\n",
    "\n",
    "            # static context -----------------------------------------------\n",
    "            if \"static_context\" in self.streams:\n",
    "                feats[\"static_context\"].append(static_vec)\n",
    "\n",
    "        # numpy → torch ------------------------------------------------------\n",
    "        out = {\n",
    "            s: torch.tensor(np.asarray(feats[s], np.float32), dtype=torch.float32)\n",
    "            for s in self.streams\n",
    "        }\n",
    "        return out, torch.tensor(label, dtype=torch.long)\n",
    "\n",
    "\n",
    "# =============================================================================\n",
    "#                       MAIN: build balanced training set\n",
    "# =============================================================================\n",
    "if __name__ == \"__main__\" and '__file__' not in globals(): # Avoid running this if imported\n",
    "    print(\"\\n--- CELL 1: DATA PREPARATION ---\")\n",
    "\n",
    "    # 1) load / regenerate PIE DB -------------------------------------------\n",
    "    cache = Path(PIE_DATABASE_CACHE_PATH)\n",
    "    if cache.is_file():\n",
    "        print(\"Loading PIE database cache …\")\n",
    "        with cache.open(\"rb\") as fp:\n",
    "            pie_db = pickle.load(fp)\n",
    "        print(\"✓ PIE DB loaded.\")\n",
    "    else:\n",
    "        if PIE is None:\n",
    "            raise RuntimeError(\"PIE class unavailable: cannot rebuild database.\")\n",
    "        print(\"Cache not found – regenerating PIE DB …\")\n",
    "        pie_db = PIE(data_path=PIE_ROOT_PATH, regen_database=True).generate_database()\n",
    "        if not pie_db:\n",
    "            raise RuntimeError(\"PIE DB generation failed.\")\n",
    "        print(\"✓ PIE DB generated.\")\n",
    "\n",
    "    # 2) compute scalers -----------------------------------------------------\n",
    "    print(\"\\nComputing scalers …\")\n",
    "    spd, accx, accy, gyz = [], [], [], []\n",
    "    for sid in TRAIN_SETS_STR:\n",
    "        for vid, vdb in pie_db.get(sid, {}).items():\n",
    "            for frame, e in vdb.get(\"vehicle_annotations\", {}).items():\n",
    "                s  = e.get(\"OBD_speed\", 0.0) or e.get(\"GPS_speed\", 0.0)\n",
    "                spd.append(s)\n",
    "                accx.append(e.get(\"accX\", 0.0))\n",
    "                accy.append(e.get(\"accY\", 0.0))\n",
    "                gyz.append(e.get(\"gyroZ\", 0.0))\n",
    "\n",
    "    scalers = {}\n",
    "    if spd:\n",
    "        scalers[\"ego_speed_mean\"] = float(np.mean(spd))\n",
    "        scalers[\"ego_speed_std\"]  = float(max(np.std(spd), 1e-6))\n",
    "    if accx:\n",
    "        scalers[\"accX_mean\"] = float(np.mean(accx))\n",
    "        scalers[\"accX_std\"]  = float(max(np.std(accx), 1e-6))\n",
    "        scalers[\"accY_mean\"] = float(np.mean(accy))\n",
    "        scalers[\"accY_std\"]  = float(max(np.std(accy), 1e-6))\n",
    "    if gyz:\n",
    "        scalers[\"gyroZ_mean\"] = float(np.mean(gyz))\n",
    "        scalers[\"gyroZ_std\"]  = float(max(np.std(gyz), 1e-6))\n",
    "\n",
    "    print(\"Scalers:\", scalers)\n",
    "\n",
    "    # 3) extract full training dataset --------------------------------------\n",
    "    print(\"\\nExtracting training sequences (all streams) …\")\n",
    "    full_ds = PIEDataset(\n",
    "        pie_db,\n",
    "        TRAIN_SETS_STR,\n",
    "        POSE_DATA_DIR,\n",
    "        SEQ_LEN,\n",
    "        PRED_LEN,\n",
    "        scalers,\n",
    "        ALL_POSSIBLE_STREAMS,\n",
    "    )\n",
    "\n",
    "    train_dict = {s: [] for s in ALL_POSSIBLE_STREAMS}\n",
    "    train_dict[\"label\"] = []\n",
    "\n",
    "    for i in tqdm(range(len(full_ds)), desc=\"seq\"):\n",
    "        feat, lbl = full_ds[i]\n",
    "        for s in ALL_POSSIBLE_STREAMS:\n",
    "            train_dict[s].append(feat[s].numpy())\n",
    "        train_dict[\"label\"].append([lbl.item()])\n",
    "\n",
    "    print(f\"Raw training samples: {len(train_dict['label'])}\")\n",
    "\n",
    "    # 4) balance -------------------------------------------------------------\n",
    "    balanced = balance_samples_count(train_dict, \"label\")\n",
    "    del train_dict, full_ds\n",
    "    gc.collect()\n",
    "\n",
    "    # 5) write pickles -------------------------------------------------------\n",
    "    print(\"\\nSaving balanced data …\")\n",
    "    with open(BALANCED_DATA_PKL_PATH, \"wb\") as fp:\n",
    "        pickle.dump(balanced, fp, pickle.HIGHEST_PROTOCOL)\n",
    "    print(f\"✓ {BALANCED_DATA_PKL_PATH}\")\n",
    "\n",
    "    print(\"Saving scalers …\")\n",
    "    with open(SCALERS_PKL_PATH, \"wb\") as fp:\n",
    "        pickle.dump(scalers, fp, pickle.HIGHEST_PROTOCOL)\n",
    "    print(f\"✓ {SCALERS_PKL_PATH}\")\n",
    "\n",
    "    del pie_db\n",
    "    gc.collect()\n",
    "\n",
    "    print(\"\\n--- CELL 1: DATA PREPARATION COMPLETE ---\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "6941c285",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-13T16:46:24.564047Z",
     "iopub.status.busy": "2025-05-13T16:46:24.563785Z",
     "iopub.status.idle": "2025-05-13T21:23:33.648799Z",
     "shell.execute_reply": "2025-05-13T21:23:33.647779Z"
    },
    "papermill": {
     "duration": 16629.100074,
     "end_time": "2025-05-13T21:23:33.650465",
     "exception": false,
     "start_time": "2025-05-13T16:46:24.550391",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- CELL 1: Skipping data preparation, balanced data and scalers found. ---\n",
      "--- Running Weighted Average Fusion With Active Streams: ['bbox', 'ped_action', 'ped_look', 'ego_speed', 'ego_acc', 'static_context'] ---\n",
      "Using device: cuda\n",
      "--- CELL 2: Model Training, HPO, and Evaluation on Set03 ---\n",
      "Active Streams: ['bbox', 'ped_action', 'ped_look', 'ego_speed', 'ego_acc', 'static_context']\n",
      "\n",
      "Loading balanced training data, scalers, and PIE database …\n",
      "   ✓ Pre-processed data and PIE database loaded.\n",
      "\n",
      "Creating Datasets and DataLoaders …\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[I 2025-05-13 16:46:35,015] A new study created in memory with name: no-name-c14fd831-352d-4e85-82f7-713beaefb120\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "   ✓ Train DataLoader ready (62774 samples).\n",
      "   ✓ HPO Validation DataLoader ready (271078 samples for ['set03']).\n",
      "\n",
      "--- Starting Hyperparameter Optimization (15 trials, 3 epochs/trial) ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "0a9ed6f4956e442a9789a44b6749596f",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "  0%|          | 0/15 [00:00<?, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[I 2025-05-13 17:00:53,890] Trial 0 finished with value: 0.7076541958730963 and parameters: {'lstm_hidden_size': 256, 'num_lstm_layers': 2, 'dropout_rate': 0.2, 'learning_rate': 7.160849144555769e-05, 'attention_dim': 128}. Best is trial 0 with value: 0.7076541958730963.\n",
      "[I 2025-05-13 17:15:10,972] Trial 1 finished with value: 0.7227852239293887 and parameters: {'lstm_hidden_size': 256, 'num_lstm_layers': 2, 'dropout_rate': 0.5, 'learning_rate': 8.152843673110742e-05, 'attention_dim': 128}. Best is trial 1 with value: 0.7227852239293887.\n",
      "[I 2025-05-13 17:25:54,192] Trial 2 finished with value: 0.7267002634501877 and parameters: {'lstm_hidden_size': 256, 'num_lstm_layers': 1, 'dropout_rate': 0.4, 'learning_rate': 6.893882309676892e-05, 'attention_dim': 128}. Best is trial 2 with value: 0.7267002634501877.\n",
      "[I 2025-05-13 17:40:11,432] Trial 3 finished with value: 0.7356871443375816 and parameters: {'lstm_hidden_size': 256, 'num_lstm_layers': 2, 'dropout_rate': 0.4, 'learning_rate': 5.564426587452873e-05, 'attention_dim': 64}. Best is trial 3 with value: 0.7356871443375816.\n",
      "[I 2025-05-13 17:57:44,971] Trial 4 finished with value: 0.7134413228087241 and parameters: {'lstm_hidden_size': 384, 'num_lstm_layers': 2, 'dropout_rate': 0.30000000000000004, 'learning_rate': 6.260977143530197e-05, 'attention_dim': 64}. Best is trial 3 with value: 0.7356871443375816.\n",
      "[I 2025-05-13 18:12:03,845] Trial 5 finished with value: 0.7301901183649256 and parameters: {'lstm_hidden_size': 256, 'num_lstm_layers': 2, 'dropout_rate': 0.30000000000000004, 'learning_rate': 0.00022987528923660826, 'attention_dim': 128}. Best is trial 3 with value: 0.7356871443375816.\n",
      "[I 2025-05-13 18:29:37,268] Trial 6 finished with value: 0.7385463519484139 and parameters: {'lstm_hidden_size': 384, 'num_lstm_layers': 2, 'dropout_rate': 0.5, 'learning_rate': 0.00039246176690796805, 'attention_dim': 128}. Best is trial 6 with value: 0.7385463519484139.\n",
      "[I 2025-05-13 18:40:34,590] Trial 7 finished with value: 0.7349391852634988 and parameters: {'lstm_hidden_size': 256, 'num_lstm_layers': 1, 'dropout_rate': 0.30000000000000004, 'learning_rate': 9.33940128553535e-05, 'attention_dim': 64}. Best is trial 6 with value: 0.7385463519484139.\n",
      "[I 2025-05-13 18:54:54,217] Trial 8 finished with value: 0.7323337817744106 and parameters: {'lstm_hidden_size': 256, 'num_lstm_layers': 2, 'dropout_rate': 0.2, 'learning_rate': 0.0004851286697060366, 'attention_dim': 64}. Best is trial 6 with value: 0.7385463519484139.\n",
      "[I 2025-05-13 19:09:18,430] Trial 9 finished with value: 0.7319392682076044 and parameters: {'lstm_hidden_size': 256, 'num_lstm_layers': 2, 'dropout_rate': 0.5, 'learning_rate': 5.929453342787639e-05, 'attention_dim': 64}. Best is trial 6 with value: 0.7385463519484139.\n",
      "[I 2025-05-13 19:20:58,979] Trial 10 pruned. \n",
      "[I 2025-05-13 19:31:33,497] Trial 11 pruned. \n",
      "[I 2025-05-13 19:49:01,928] Trial 12 finished with value: 0.7422073346140109 and parameters: {'lstm_hidden_size': 384, 'num_lstm_layers': 2, 'dropout_rate': 0.4, 'learning_rate': 0.00027672568554683644, 'attention_dim': 64}. Best is trial 12 with value: 0.7422073346140109.\n",
      "[I 2025-05-13 20:06:38,475] Trial 13 pruned. \n",
      "[I 2025-05-13 20:18:14,871] Trial 14 pruned. \n",
      "\n",
      "--- Hyperparameter Optimization Finished (12699.86s) ---\n",
      "Best HPO F1 score on validation set (['set03']): 0.7422\n",
      "Best hyperparameters found:\n",
      "  lstm_hidden_size: 384\n",
      "  num_lstm_layers: 2\n",
      "  dropout_rate: 0.4\n",
      "  learning_rate: 0.00027672568554683644\n",
      "  attention_dim: 64\n",
      "\n",
      "--- Training Final Model with Best Hyperparameters ---\n",
      "\n",
      "--- Final Model Architecture ---\n",
      "Trainable parameters in final model: 29,075,342\n",
      "\n",
      "Training final model for 5 epochs with LR=2.77e-04...\n",
      "  Epoch 01/5 – 697.5s | Train Loss: 0.3201 | Val HPO Loss: 0.3607 | Val HPO F1@0.5: 0.6700\n",
      "  Epoch 02/5 – 697.3s | Train Loss: 0.2291 | Val HPO Loss: 0.3474 | Val HPO F1@0.5: 0.6720\n",
      "  Epoch 03/5 – 694.7s | Train Loss: 0.1953 | Val HPO Loss: 0.3622 | Val HPO F1@0.5: 0.6801\n",
      "  Epoch 04/5 – 698.6s | Train Loss: 0.1674 | Val HPO Loss: 0.4035 | Val HPO F1@0.5: 0.6905\n",
      "  Epoch 05/5 – 694.5s | Train Loss: 0.1473 | Val HPO Loss: 0.3717 | Val HPO F1@0.5: 0.7222\n",
      "\n",
      "--- Final Evaluation on Test Set (['set04']) ---\n",
      "   ✓ Test DataLoader ready (234149 samples for ['set04']).\n",
      "\n",
      "--- Final Metrics on Test Set (set03) with Tuned Threshold ---\n",
      "Optimal Threshold on Set03    : 0.8400\n",
      "F1-score (Maximized on Set03) : 0.7164\n",
      "Accuracy                      : 0.9104\n",
      "Precision                     : 0.6871\n",
      "Recall                        : 0.7482\n",
      "AUC                           : 0.9509\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 640x480 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Learned Fusion Weights (Final Model) ---\n",
      "bbox                : 0.1732\n",
      "ped_action          : 0.1675\n",
      "ped_look            : 0.1514\n",
      "ego_speed           : 0.1604\n",
      "ego_acc             : 0.1769\n",
      "static_context      : 0.1707\n",
      "------------------------------\n"
     ]
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAABKUAAAGGCAYAAACqvTJ0AAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuNSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/xnp5ZAAAACXBIWXMAAA9hAAAPYQGoP6dpAADPs0lEQVR4nOzdd1zV9ffA8de9l733UoZ7Iph7U6m408xtrjRzNEQrza2VmWmWI7Nclf1Qc9RXTVFza85cqaQm4kJxILLH/fz+uHH1CiggcBnn+Xh8HnI/433PuRfhw7nvoVIURUEIIYQQQgghhBBCiEKkNnYAQgghhBBCCCGEEKL0kaKUEEIIIYQQQgghhCh0UpQSQgghhBBCCCGEEIVOilJCCCGEEEIIIYQQotBJUUoIIYQQQgghhBBCFDopSgkhhBBCCCGEEEKIQidFKSGEEEIIIYQQQghR6KQoJYQQQgghhBBCCCEKnRSlhBBCCCGEEEIIIUShk6KUECLXIiIiUKlULF++vECfx8/PjwEDBhToczyPAQMG4Ofnl6drg4KCCAoKytd4hBBCiNJK7k105N4kd/z8/FCpVKhUKkaOHGnscArNhg0b9HmrVCqOHj1q7JBEKSZFKSFEJsuXLzf4RfX4NnbsWGOHl0lGbIMHD87y+Pjx4/Xn3Llzp5Cjez5+fn506NDB2GEIIYQQRiX3JkXH44WcJ7ekpCQA4uLimDx5Mm3atMHJyalQCoZ51axZM3788Uf69++v35dR5Ny1a1eBPOfmzZuZMmVKtsd/++03XnjhBSwsLPDx8WHy5MmkpaUZnLNnzx46deqEt7c3FhYWeHh40KZNG/bv35+pPT8/P4Pnq1u3Lj/++CNvvvlmfqUkRJ6ZGDsAIUTRNW3aNMqVK2ewr2bNmvj6+pKYmIipqamRIsvMwsKCtWvXsnDhQszMzAyO/d///R8WFhb6GyUhhBBCFE9yb1I0BAYGMnr06Ez7M/K8c+cO06ZNw8fHh4CAgAIr7uSH8uXL07dv30J9zs2bN7NgwYIsC1O///47nTt3JigoiHnz5nH69Gk+/vhjbt++zTfffKM/759//kGtVvPWW2/h4eHB/fv3+emnn2jevDmbNm2iTZs22T5/2bJl6du3L2lpaSxevLggUhQix6QoJYTIVtu2balbt26WxywsLAo5mqdr06YNv/32G7///juvvPKKfv+BAwe4fPkyXbt2Ze3atUaMUAghhBDPS+5NioYyZco8tZDj6enJzZs38fDw4OjRo9SrV68QoyvexowZQ61atQgLC8PERPfnup2dHZ9++invvvsuVatWBWDw4MGZeuINHz6c8uXLM3fu3KcWpYQoSmT4nhAi17Kat2HAgAHY2Nhw/fp1OnfujI2NDa6urowZM4b09HSD67/44gsaN26Ms7MzlpaW1KlTh19++eW5YipTpgzNmzfn559/Nti/cuVK/P39qVmzZpbXrVmzhjp16mBpaYmLiwt9+/bl+vXrmc7bsGEDNWvWxMLCgpo1a7J+/fos29NqtcydO5caNWpgYWGBu7s7Q4cO5f79+8+V39OkpaUxffp0KlSogLm5OX5+fnz00UckJycbnHf06FGCg4NxcXHB0tKScuXKMWjQIINzQkNDqVOnDra2ttjZ2eHv789XX31VYLELIYQQ+UHuTYrWvYm5uTkeHh7P1cYff/xBs2bNsLa2xsHBgVdeeYVz584ZnDNlyhRUKhUXL15kwIABODg4YG9vz8CBA0lISHiu539SVFQUAwcOpGzZspibm+Pp6ckrr7xCRESEwXm///67Pm5bW1vat2/P33//rT8+YMAAFixYAGAw9BHg7NmznD17ljfffFNfkAJdsUlRlGd+T1pZWeHq6kpMTEz+JC1EIZCilBAiWw8ePODOnTsG29Okp6cTHByMs7MzX3zxBS1atGD27NmZugV/9dVX1K5dm2nTpvHpp59iYmJCt27d2LRp03PF27t3b/73v/8RFxcH6Io1a9asoXfv3lmev3z5crp3745Go2HGjBkMGTKEdevW0bRpU4Nf5mFhYXTt2hWVSsWMGTPo3LkzAwcOzHJSyKFDh/L+++/TpEkTvvrqKwYOHMjKlSsJDg4mNTX1ufLLzuDBg5k0aRIvvPACX375JS1atGDGjBn07NlTf87t27dp3bo1ERERjB07lnnz5tGnTx/+/PNP/Tnbtm2jV69eODo6MnPmTD777DOCgoKynJtACCGEMAa5N9Ex9r1JampqpvchP4tA27dvJzg4mNu3bzNlyhRCQkI4cOAATZo0yVQEAujevTsPHz5kxowZdO/eneXLlzN16tR8iwega9eurF+/noEDB7Jw4ULeeecdHj58SGRkpP6cH3/8kfbt22NjY8PMmTOZOHEiZ8+epWnT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qqoqysrKsFqtbfJ3dASeEicoVnelWN2Pp8QJirW1nM4FTucGcmFtmUPp37R78pRYPSVOUKzuSrG6n7aOs7k5lIpSTSgvLwega9euTp6JiIiIdATl5eWEhIQ4exodnnIoEREROdPFciiToY/+zmG32zly5AhBQUGYTKZWH7+srIyuXbty6NAhgoODW338jsJT4gTF6q4Uq/vxlDhBsbYWwzAoLy8nNjYWs1ldDy6mLXMo/Zt2T54Sq6fECYrVXSlW99PWcTY3h9JOqSaYzWa6dOnS5n9PcHCwW/8jP81T4gTF6q4Uq/vxlDhBsbYG7ZBqvvbIofRv2j15SqyeEicoVnelWN1PW8bZnBxKH/mJiIiIiIiIiEi7U1FKRERERERERETanYpSTuDj48OsWbPw8fFx9lTalKfECYrVXSlW9+MpcYJiFffjSeusWN2Pp8QJitVdKVb301HiVKNzERERERERERFpd9opJSIiIiIiIiIi7U5FKRERERERERERaXcqSomIiIiIiIiISLtTUaqVrV69mptvvpnY2FhMJhOLFi266HsyMjK44oor8PHxITk5mTfeeKPN59kaWhprRkYGJpPpnIfNZmufCV+iOXPmMGTIEIKCgoiMjGTixIns3r37ou97//336dWrF76+vvTr149PP/20HWZ7eS4l1jfeeOOcNfX19W2nGV+6efPmkZaWRnBwMMHBwaSnp/PZZ59d8D2uuKbQ8lhddU3P9txzz2EymXj44YcveJ6rruuZmhOrq67r7Nmzz5l3r169Lvged1hTT+QpOZSn5E+gHModcyjlT+6fP4Hn5FDunD+B6+RQKkq1ssrKSvr378/LL7/crPNzc3O56aabuOaaa9iyZQsPP/ww999/P0uXLm3jmV6+lsZ62u7duzl69KjjERkZ2UYzbB1ffPEF06ZNY926dSxfvpy6ujrGjRtHZWXled+zdu1a7rzzTu677z42b97MxIkTmThxItu3b2/HmbfcpcQKEBwc3GhNDxw40E4zvnRdunThueeeY+PGjWzYsIFrr72WCRMmsGPHjibPd9U1hZbHCq65pmdav349r776KmlpaRc8z5XX9bTmxgquu659+vRpNO+vvvrqvOe6w5p6Kk/JoTwlfwLlUO6YQyl/cu/8CTwnh/KE/AlcJIcypM0AxkcffXTBc37zm98Yffr0aXTs9ttv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IiIi7U5FKRERERERERERaXcqSomIiIiIiIiISLtTUUpERERERERERNqdilIiIiIiIiIiItLuVJQSEWllJpOJRYsWOXsaIiIiIi5D+ZOIZ1JRSkTcyk9/+lNMJtM5j+uvv97ZUxMRERHpkJQ/iYizeDl7AiIire3666/n9ddfb3TMx8fHSbMRERER6fiUP4mIM2inlIi4HR8fH6Kjoxs9OnfuDDRsDZ83bx433HADfn5+JCYm8sEHHzR6/7Zt27j22mvx8/MjLCyMBx54gIqKikbnLFiwgD59+uDj40NMTAwPPfRQo9eLior4wQ9+gL+/Pz169GDx4sVtG7SIiIjIZVD+JCLOoKKUiHicJ554gltvvZWtW7cyadIk7rjjDnbu3AlAZWUl48ePp3Pnzqxfv57333+fFStWNEqa5s2bx7Rp03jggQfYtm0bixcvJjk5udHf8dRTT3Hbbbfx7bffcuONNzJp0iRKSkraNU4RERGR1qL8SUTahCEi4kYmT55sWCwWIyAgoNHjmWeeMQzDMADjwQcfbPSeYcOGGVOmTDEMwzDmz59vdO7c2aioqHC8/sknnxhms9mw2WyGYRhGbGys8fjjj593DoDx29/+1vG8oqLCAIzPPvus1eIUERERaS3Kn0TEWdRTSkTczjXXXMO8efMaHQsNDXV8nZ6e3ui19PR0tmzZAsDOnTvp378/AQEBjtdHjBiB3W5n9+7dmEwmjhw5wnXXXXfBOaSlpTm+DggIIDg4mIKCgksNSURERKRNKX8SEWdQUUpE3E5AQMA528Fbi5+fX7POs1qtjZ6bTCbsdntbTElERETksil/EhFnUE8pEfE469atO+d5amoqAKmpqWzdupXKykrH62vWrMFsNpOSkkJQUBDx8fGsXLmyXecsIiIi4kzKn0SkLWinlIi4nZqaGmw2W6NjXl5ehIeHA/D+++8zePBgRo4cydtvv80333zD3//+dwAmTZrErFmzmDx5MrNnz6awsJBf/OIX3HXXXURFRQEwe/ZsHnzwQSIjI7nhhhsoLy9nzZo1/OIXv2jfQEVERERaifInEXEGFaVExO0sWbKEmJiYRsdSUlLYtWsX0HBnl3fffZepU6cSExPDv/71L3r37g2Av78/S5cuZfr06QwZMgR/f39uvfVWXnzxRcdYkydPprq6mj/96U/8+te/Jjw8nB/+8IftF6CIiIhIK1P+JCLOYDIMw3D2JERE2ovJZOKjjz5i4sSJzp6KiIiIiEtQ/iQibUU9pUREREREREREpN2pKCUiIiIiIiIiIu1Ol++JiIiIiIiIiEi7004pERERERERERFpdypKiYiIiIiIiIhIu1NRSkRERERERERE2p2KUiIiIiIiIiIi0u5UlBIRERERERERkXanopSIiIiIiIiIiLQ7FaVERERERERERKTdqSglIiIiIiIiIiLtTkUpERERERERERFpd/8fGyX1Zgn2mrQAAAAASUVORK5CYII=\n",
      "text/plain": [
       "<Figure size 1200x400 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- CELL 2: Script complete ---\n"
     ]
    }
   ],
   "source": [
    "# -----------------------------------------------------------------------------\n",
    "# CELL 1: DATA PREPARATION & BALANCING  (run once before training)\n",
    "# -----------------------------------------------------------------------------\n",
    "#  This cell:\n",
    "#    1. Loads (or regenerates) the PIE database\n",
    "#    2. Computes per-signal standardisation scalers\n",
    "#    3. Extracts ALL training sequences for every stream\n",
    "#    4. Balances the dataset 50 / 50 on the crossing label\n",
    "#    5. Writes two pickles:\n",
    "#         - /kaggle/working/balanced_train_data.pkl\n",
    "#         - /kaggle/working/scalers.pkl\n",
    "# -----------------------------------------------------------------------------\n",
    "\n",
    "import os\n",
    "import sys\n",
    "import time\n",
    "import pickle\n",
    "import gc\n",
    "from pathlib import Path\n",
    "\n",
    "import cv2                               # used internally by PIE utilities\n",
    "import numpy as np\n",
    "import torch\n",
    "from torch.utils.data import Dataset\n",
    "from tqdm.notebook import tqdm\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                                PIE utilities                                 #\n",
    "# -----------------------------------------------------------------------------#\n",
    "pie_utilities_path = \"/kaggle/working/PIE/utilities\"\n",
    "if pie_utilities_path not in sys.path:\n",
    "    sys.path.insert(0, pie_utilities_path)\n",
    "\n",
    "try:\n",
    "    from pie_data import PIE\n",
    "except ImportError as e:\n",
    "    print(\n",
    "        f\"[WARN] Could not import PIE from {pie_utilities_path}. \"\n",
    "        f\"If the DB cache already exists this is fine.\\n→ {e}\"\n",
    "    )\n",
    "    PIE = None\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                              configuration                                   #\n",
    "# -----------------------------------------------------------------------------#\n",
    "PIE_ROOT_PATH           = \"/kaggle/working/PIE\"\n",
    "POSE_DATA_DIR           = \"/kaggle/input/pose-data/extracted_poses2\"\n",
    "PIE_DATABASE_CACHE_PATH = \"/kaggle/input/pie-database/pie_database.pkl\"\n",
    "\n",
    "TRAIN_SETS_STR = [\"set01\", \"set02\", \"set05\", \"set06\"] # Used for generating training data and scalers\n",
    "\n",
    "BALANCED_DATA_PKL_PATH  = \"/kaggle/working/balanced_train_data.pkl\"\n",
    "SCALERS_PKL_PATH        = \"/kaggle/working/scalers.pkl\"\n",
    "\n",
    "# Streams used throughout the project ----------------------------------------\n",
    "ALL_POSSIBLE_STREAMS = [\n",
    "    \"bbox\",\n",
    "    \"pose\",\n",
    "    \"ego_speed\",\n",
    "    \"ego_acc\",\n",
    "    \"ego_gyro\",\n",
    "    \"ped_action\",\n",
    "    \"ped_look\",\n",
    "    \"ped_occlusion\",\n",
    "    \"traffic_light\",\n",
    "    \"static_context\",\n",
    "]\n",
    "\n",
    "# Feature sizes & categorical constants --------------------------------------\n",
    "SEQ_LEN, PRED_LEN = 30, 1\n",
    "\n",
    "INPUT_SIZE_BBOX       = 4\n",
    "INPUT_SIZE_POSE       = 34\n",
    "INPUT_SIZE_EGO_SPEED  = 1\n",
    "INPUT_SIZE_EGO_ACC    = 2\n",
    "INPUT_SIZE_EGO_GYRO   = 1\n",
    "INPUT_SIZE_PED_ACTION = 1\n",
    "INPUT_SIZE_PED_LOOK   = 1\n",
    "INPUT_SIZE_PED_OCC    = 1\n",
    "INPUT_SIZE_TL_STATE   = 4\n",
    "\n",
    "NUM_SIGNALIZED_CATS   = 4\n",
    "NUM_INTERSECTION_CATS = 5\n",
    "NUM_AGE_CATS          = 4\n",
    "NUM_GENDER_CATS       = 3\n",
    "NUM_TRAFFIC_DIR_CATS  = 2\n",
    "\n",
    "LANE_CATEGORIES = {1: 0, 2: 1, 3: 2, 4: 3, 5: 4, 6: 4, 7: 4, 8: 4}\n",
    "NUM_LANE_CATS   = len(set(LANE_CATEGORIES.values()))\n",
    "\n",
    "INPUT_SIZE_STATIC = (\n",
    "    NUM_SIGNALIZED_CATS\n",
    "    + NUM_INTERSECTION_CATS\n",
    "    + NUM_AGE_CATS\n",
    "    + NUM_GENDER_CATS\n",
    "    + NUM_TRAFFIC_DIR_CATS\n",
    "    + NUM_LANE_CATS\n",
    ")  # → 23\n",
    "\n",
    "TL_STATE_MAP = {\"__undefined__\": 0, \"red\": 1, \"yellow\": 2, \"green\": 3}\n",
    "NUM_TL_STATES = len(TL_STATE_MAP)\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                               helper utils                                   #\n",
    "# -----------------------------------------------------------------------------#\n",
    "\n",
    "\n",
    "def to_one_hot(index: int, num_classes: int) -> np.ndarray:\n",
    "    vec = np.zeros(num_classes, dtype=np.float32)\n",
    "    vec[int(np.clip(index, 0, num_classes - 1))] = 1.0\n",
    "    return vec\n",
    "\n",
    "\n",
    "def balance_samples_count(seq_data: dict, label_key: str, seed: int = 42) -> dict:\n",
    "    \"\"\"Undersample majority class so positive and negative labels are equal.\"\"\"\n",
    "    labels = [lbl[0] for lbl in seq_data[label_key]]\n",
    "    n_pos  = int(np.sum(labels))\n",
    "    n_neg  = len(labels) - n_pos\n",
    "\n",
    "    if n_pos == n_neg:\n",
    "        print(\"Dataset already balanced.\")\n",
    "        return seq_data.copy()\n",
    "\n",
    "    majority_label    = 0 if n_neg > n_pos else 1\n",
    "    minority_count    = min(n_pos, n_neg)\n",
    "    majority_indices  = np.where(np.array(labels) == majority_label)[0]\n",
    "    minority_indices  = np.where(np.array(labels) != majority_label)[0]\n",
    "\n",
    "    rng = np.random.default_rng(seed)\n",
    "    keep_majority = rng.choice(majority_indices, size=minority_count, replace=False)\n",
    "    final_indices = np.concatenate([minority_indices, keep_majority])\n",
    "    rng.shuffle(final_indices)\n",
    "\n",
    "    balanced = {}\n",
    "    for k, v in seq_data.items():\n",
    "        balanced[k] = [v[i] for i in final_indices]\n",
    "\n",
    "    print(f\"Balanced: 1s={minority_count} | 0s={minority_count}\")\n",
    "    return balanced\n",
    "\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                                PIEDataset                                    #\n",
    "# -----------------------------------------------------------------------------#\n",
    "class PIEDataset(Dataset):\n",
    "    \"\"\"\n",
    "    Lightweight dataset that can generate any subset of the PIE feature streams.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(\n",
    "        self,\n",
    "        pie_db: dict,\n",
    "        set_names: list[str],\n",
    "        pose_dir: str,\n",
    "        seq_len: int,\n",
    "        pred_len: int,\n",
    "        scalers: dict,\n",
    "        streams_to_generate: list[str],\n",
    "    ):\n",
    "        self.pie_db            = pie_db\n",
    "        self.set_names         = set_names\n",
    "        self.pose_dir          = pose_dir\n",
    "        self.seq_len           = seq_len\n",
    "        self.pred_len          = pred_len\n",
    "        self.scalers           = scalers\n",
    "        self.streams           = streams_to_generate\n",
    "        self._input_sizes      = self._build_input_size_map()\n",
    "        self.all_pose_data     = {}\n",
    "        self.sequences         = []\n",
    "\n",
    "        if \"pose\" in self.streams:\n",
    "            self._load_pose_pkls()\n",
    "        self._enumerate_sequences()\n",
    "\n",
    "    # ------------------------ internal helpers -------------------------------\n",
    "    def _build_input_size_map(self) -> dict:\n",
    "        special = {\n",
    "            \"TRAFFIC_LIGHT\": \"TL_STATE\",\n",
    "            \"STATIC_CONTEXT\": \"STATIC\",\n",
    "            \"EGO_SPEED\": \"EGO_SPEED\",\n",
    "            \"EGO_ACC\": \"EGO_ACC\",\n",
    "            \"EGO_GYRO\": \"EGO_GYRO\",\n",
    "            \"PED_ACTION\": \"PED_ACTION\",\n",
    "            \"PED_LOOK\": \"PED_LOOK\",\n",
    "            \"PED_OCCLUSION\": \"PED_OCC\",\n",
    "        }\n",
    "        sizes = {}\n",
    "        for s in ALL_POSSIBLE_STREAMS:\n",
    "            const = f\"INPUT_SIZE_{special.get(s.upper(), s.upper())}\"\n",
    "            if s == \"bbox\":\n",
    "                const = \"INPUT_SIZE_BBOX\"\n",
    "            elif s == \"pose\":\n",
    "                const = \"INPUT_SIZE_POSE\"\n",
    "            sizes[s] = globals().get(const, 1)\n",
    "        return sizes\n",
    "\n",
    "    def _load_pose_pkls(self):\n",
    "        print(f\"Loading pose PKLs for sets {self.set_names} (streams: {self.streams})…\")\n",
    "        for set_id in self.set_names:\n",
    "            set_dir = Path(self.pose_dir) / set_id\n",
    "            if not set_dir.is_dir():\n",
    "                print(f\"Warning: Pose directory not found for set {set_id}: {set_dir}\")\n",
    "                continue\n",
    "            self.all_pose_data[set_id] = {}\n",
    "            # Use tqdm only if there are files to process\n",
    "            pkl_files = list(set_dir.glob(f\"{set_id}_*_poses.pkl\"))\n",
    "            if not pkl_files:\n",
    "                print(f\"No pose PKL files found in {set_dir} matching pattern.\")\n",
    "                continue\n",
    "\n",
    "            for pkl_path in tqdm(pkl_files, desc=f\"Loading poses {set_id}\", leave=False):\n",
    "                try:\n",
    "                    with open(pkl_path, \"rb\") as fp:\n",
    "                        loaded = pickle.load(fp)\n",
    "                except Exception as e:\n",
    "                    print(f\"[pose load] {pkl_path}: {e}\")\n",
    "                    continue\n",
    "\n",
    "                if len(loaded) != 1:\n",
    "                    continue\n",
    "                (key, data), *_ = loaded.items()\n",
    "                vid = \"_\".join(key.split(\"_\")[1:])\n",
    "                if vid in self.pie_db.get(set_id, {}):\n",
    "                    self.all_pose_data[set_id][vid] = data\n",
    "\n",
    "    def _enumerate_sequences(self):\n",
    "        print(f\"Enumerating sequences for sets {self.set_names}…\")\n",
    "        for set_id in self.set_names:\n",
    "            for vid, vdb in self.pie_db.get(set_id, {}).items():\n",
    "                for pid, pdb in vdb.get(\"ped_annotations\", {}).items():\n",
    "                    frames = pdb.get(\"frames\", [])\n",
    "                    if len(frames) < self.seq_len + self.pred_len:\n",
    "                        continue\n",
    "                    frames = sorted(frames)\n",
    "                    for i in range(len(frames) - self.seq_len - self.pred_len + 1):\n",
    "                        start = frames[i]\n",
    "                        obs_end = frames[i + self.seq_len - 1]\n",
    "                        if obs_end - start != self.seq_len - 1:\n",
    "                            continue\n",
    "                        target = frames[i + self.seq_len + self.pred_len - 1]\n",
    "                        if target - obs_end != self.pred_len:\n",
    "                            continue\n",
    "                        self.sequences.append((set_id, vid, pid, start))\n",
    "        print(f\"Total sequences for {self.set_names}: {len(self.sequences)}\")\n",
    "\n",
    "    # ------------------ Dataset API ------------------------------------------\n",
    "    def __len__(self):\n",
    "        return len(self.sequences)\n",
    "\n",
    "    def __getitem__(self, idx: int):\n",
    "        set_id, vid, pid, start = self.sequences[idx]\n",
    "        vdb  = self.pie_db[set_id][vid]\n",
    "        pdb  = vdb[\"ped_annotations\"][pid]\n",
    "        ego  = vdb.get(\"vehicle_annotations\", {})\n",
    "        tldb = vdb.get(\"traffic_annotations\", {})\n",
    "\n",
    "        frame_nums = list(range(start, start + self.seq_len))\n",
    "        target_f   = start + self.seq_len + self.pred_len - 1\n",
    "\n",
    "        # label ---------------------------------------------------------------\n",
    "        label = 0\n",
    "        if (\n",
    "            \"frames\" in pdb\n",
    "            and \"behavior\" in pdb\n",
    "            and \"cross\" in pdb[\"behavior\"]\n",
    "            and target_f in pdb[\"frames\"]\n",
    "        ):\n",
    "            try:\n",
    "                j = pdb[\"frames\"].index(target_f)\n",
    "                label = pdb[\"behavior\"][\"cross\"][j]\n",
    "                if label == -1:\n",
    "                    label = 0\n",
    "            except (ValueError, IndexError):\n",
    "                pass\n",
    "\n",
    "        # static context ------------------------------------------------------\n",
    "        static_vec = np.zeros(INPUT_SIZE_STATIC, np.float32)\n",
    "        if \"static_context\" in self.streams:\n",
    "            attr  = pdb.get(\"attributes\", {})\n",
    "            sig   = attr.get(\"signalized\", 0)\n",
    "            intr  = attr.get(\"intersection\", 0)\n",
    "            age   = attr.get(\"age\", 2)\n",
    "            gen   = attr.get(\"gender\", 0)\n",
    "            tdir  = int(attr.get(\"traffic_direction\", 0))\n",
    "            ln    = attr.get(\"num_lanes\", 2)\n",
    "            lncat = LANE_CATEGORIES.get(ln, LANE_CATEGORIES[max(LANE_CATEGORIES)])\n",
    "            static_vec = np.concatenate(\n",
    "                [\n",
    "                    to_one_hot(sig,  NUM_SIGNALIZED_CATS),\n",
    "                    to_one_hot(intr, NUM_INTERSECTION_CATS),\n",
    "                    to_one_hot(age,  NUM_AGE_CATS),\n",
    "                    to_one_hot(gen,  NUM_GENDER_CATS),\n",
    "                    to_one_hot(tdir, NUM_TRAFFIC_DIR_CATS),\n",
    "                    to_one_hot(lncat, NUM_LANE_CATS),\n",
    "                ]\n",
    "            ).astype(np.float32)\n",
    "\n",
    "        # per-frame feature assembly -----------------------------------------\n",
    "        feats = {s: [] for s in self.streams}\n",
    "\n",
    "        for fn in frame_nums:\n",
    "            fidx = -1\n",
    "            if \"frames\" in pdb:\n",
    "                try:\n",
    "                    fidx = pdb[\"frames\"].index(fn)\n",
    "                except ValueError:\n",
    "                    pass\n",
    "\n",
    "            ego_f = ego.get(fn, {})\n",
    "\n",
    "            # bbox ----------------------------------------------------------\n",
    "            if \"bbox\" in self.streams:\n",
    "                bb = np.zeros(INPUT_SIZE_BBOX, np.float32)\n",
    "                if (\n",
    "                    fidx != -1\n",
    "                    and \"bbox\" in pdb\n",
    "                    and len(pdb[\"bbox\"]) > fidx\n",
    "                ):\n",
    "                    try:\n",
    "                        x1, y1, x2, y2 = pdb[\"bbox\"][fidx]\n",
    "                        w_img = vdb.get(\"width\", 1920)\n",
    "                        h_img = vdb.get(\"height\", 1080)\n",
    "                        if w_img > 0 and h_img > 0:\n",
    "                            cx = ((x1 + x2) / 2) / w_img\n",
    "                            cy = ((y1 + y2) / 2) / h_img\n",
    "                            w  = (x2 - x1) / w_img\n",
    "                            h  = (y2 - y1) / h_img\n",
    "                            if 0 < w and 0 < h and 0 <= cx <= 1 and 0 <= cy <= 1:\n",
    "                                bb = np.array([cx, cy, w, h], np.float32)\n",
    "                    except Exception:\n",
    "                        pass\n",
    "                feats[\"bbox\"].append(bb)\n",
    "\n",
    "            # pose ----------------------------------------------------------\n",
    "            if \"pose\" in self.streams:\n",
    "                pvec = np.zeros(INPUT_SIZE_POSE, np.float32)\n",
    "                pose_set = self.all_pose_data.get(set_id, {}).get(vid, {})\n",
    "                p_loaded = pose_set.get(fn, {}).get(pid)\n",
    "                if (\n",
    "                    isinstance(p_loaded, np.ndarray)\n",
    "                    and p_loaded.shape == (INPUT_SIZE_POSE,)\n",
    "                ):\n",
    "                    pvec = p_loaded\n",
    "                feats[\"pose\"].append(pvec)\n",
    "\n",
    "            # ego signals ---------------------------------------------------\n",
    "            if \"ego_speed\" in self.streams:\n",
    "                s = ego_f.get(\"OBD_speed\", 0.0) or ego_f.get(\"GPS_speed\", 0.0)\n",
    "                s = (s - self.scalers.get(\"ego_speed_mean\", 0.0)) / self.scalers.get(\n",
    "                    \"ego_speed_std\", 1.0\n",
    "                )\n",
    "                feats[\"ego_speed\"].append([s])\n",
    "\n",
    "            if \"ego_acc\" in self.streams:\n",
    "                ax = ego_f.get(\"accX\", 0.0)\n",
    "                ay = ego_f.get(\"accY\", 0.0)\n",
    "                ax = (ax - self.scalers.get(\"accX_mean\", 0.0)) / self.scalers.get(\n",
    "                    \"accX_std\", 1.0\n",
    "                )\n",
    "                ay = (ay - self.scalers.get(\"accY_mean\", 0.0)) / self.scalers.get(\n",
    "                    \"accY_std\", 1.0\n",
    "                )\n",
    "                feats[\"ego_acc\"].append([ax, ay])\n",
    "\n",
    "            if \"ego_gyro\" in self.streams:\n",
    "                gz = ego_f.get(\"gyroZ\", 0.0)\n",
    "                gz = (gz - self.scalers.get(\"gyroZ_mean\", 0.0)) / self.scalers.get(\n",
    "                    \"gyroZ_std\", 1.0\n",
    "                )\n",
    "                feats[\"ego_gyro\"].append([gz])\n",
    "\n",
    "            # pedestrian behaviour -----------------------------------------\n",
    "            if \"ped_action\" in self.streams:\n",
    "                action = (\n",
    "                    pdb[\"behavior\"][\"action\"][fidx]\n",
    "                    if fidx != -1\n",
    "                    and \"behavior\" in pdb\n",
    "                    and \"action\" in pdb[\"behavior\"]\n",
    "                    and len(pdb[\"behavior\"][\"action\"]) > fidx\n",
    "                    else 0\n",
    "                )\n",
    "                feats[\"ped_action\"].append([float(action)])\n",
    "\n",
    "            if \"ped_look\" in self.streams:\n",
    "                look = (\n",
    "                    pdb[\"behavior\"][\"look\"][fidx]\n",
    "                    if fidx != -1\n",
    "                    and \"behavior\" in pdb\n",
    "                    and \"look\" in pdb[\"behavior\"]\n",
    "                    and len(pdb[\"behavior\"][\"look\"]) > fidx\n",
    "                    else 0\n",
    "                )\n",
    "                feats[\"ped_look\"].append([float(look)])\n",
    "\n",
    "            if \"ped_occlusion\" in self.streams:\n",
    "                occ = (\n",
    "                    float(pdb[\"occlusion\"][fidx]) / 2.0\n",
    "                    if fidx != -1\n",
    "                    and \"occlusion\" in pdb\n",
    "                    and len(pdb[\"occlusion\"]) > fidx\n",
    "                    else 0.0\n",
    "                )\n",
    "                feats[\"ped_occlusion\"].append([occ])\n",
    "\n",
    "            # traffic light -------------------------------------------------\n",
    "            if \"traffic_light\" in self.streams:\n",
    "                tl_state = 0\n",
    "                for obj in tldb.values():\n",
    "                    if obj.get(\"obj_class\") != \"traffic_light\":\n",
    "                        continue\n",
    "                    if \"frames\" not in obj or \"state\" not in obj:\n",
    "                        continue\n",
    "                    try:\n",
    "                        j = obj[\"frames\"].index(fn)\n",
    "                        if obj[\"state\"][j] != 0:\n",
    "                            tl_state = obj[\"state\"][j]\n",
    "                            break\n",
    "                    except (ValueError, IndexError):\n",
    "                        continue\n",
    "                feats[\"traffic_light\"].append(to_one_hot(tl_state, NUM_TL_STATES))\n",
    "\n",
    "            # static context -----------------------------------------------\n",
    "            if \"static_context\" in self.streams:\n",
    "                feats[\"static_context\"].append(static_vec)\n",
    "\n",
    "        # numpy → torch ------------------------------------------------------\n",
    "        out = {\n",
    "            s: torch.tensor(np.asarray(feats[s], np.float32), dtype=torch.float32)\n",
    "            for s in self.streams\n",
    "        }\n",
    "        return out, torch.tensor(label, dtype=torch.long)\n",
    "\n",
    "\n",
    "# =============================================================================\n",
    "#                       MAIN: build balanced training set (Cell 1)\n",
    "# =============================================================================\n",
    "if __name__ == \"__main__\" and '__file__' not in globals() and not Path(BALANCED_DATA_PKL_PATH).exists(): # Avoid re-running if files exist\n",
    "    print(\"\\n--- CELL 1: DATA PREPARATION (Running because balanced data not found) ---\")\n",
    "\n",
    "    # 1) load / regenerate PIE DB -------------------------------------------\n",
    "    cache = Path(PIE_DATABASE_CACHE_PATH)\n",
    "    if cache.is_file():\n",
    "        print(\"Loading PIE database cache …\")\n",
    "        with cache.open(\"rb\") as fp:\n",
    "            pie_db_cell1 = pickle.load(fp) # Use a different variable name\n",
    "        print(\"✓ PIE DB loaded.\")\n",
    "    else:\n",
    "        if PIE is None:\n",
    "            raise RuntimeError(\"PIE class unavailable: cannot rebuild database.\")\n",
    "        print(\"Cache not found – regenerating PIE DB …\")\n",
    "        pie_db_cell1 = PIE(data_path=PIE_ROOT_PATH, regen_database=True).generate_database()\n",
    "        if not pie_db_cell1:\n",
    "            raise RuntimeError(\"PIE DB generation failed.\")\n",
    "        print(\"✓ PIE DB generated.\")\n",
    "\n",
    "    # 2) compute scalers -----------------------------------------------------\n",
    "    print(\"\\nComputing scalers …\")\n",
    "    spd, accx, accy, gyz = [], [], [], []\n",
    "    for sid in TRAIN_SETS_STR: # Use TRAIN_SETS_STR for scalers\n",
    "        for vid, vdb in pie_db_cell1.get(sid, {}).items():\n",
    "            for frame, e in vdb.get(\"vehicle_annotations\", {}).items():\n",
    "                s  = e.get(\"OBD_speed\", 0.0) or e.get(\"GPS_speed\", 0.0)\n",
    "                spd.append(s)\n",
    "                accx.append(e.get(\"accX\", 0.0))\n",
    "                accy.append(e.get(\"accY\", 0.0))\n",
    "                gyz.append(e.get(\"gyroZ\", 0.0))\n",
    "\n",
    "    scalers_cell1 = {} # Use a different variable name\n",
    "    if spd:\n",
    "        scalers_cell1[\"ego_speed_mean\"] = float(np.mean(spd))\n",
    "        scalers_cell1[\"ego_speed_std\"]  = float(max(np.std(spd), 1e-6))\n",
    "    if accx:\n",
    "        scalers_cell1[\"accX_mean\"] = float(np.mean(accx))\n",
    "        scalers_cell1[\"accX_std\"]  = float(max(np.std(accx), 1e-6))\n",
    "        scalers_cell1[\"accY_mean\"] = float(np.mean(accy))\n",
    "        scalers_cell1[\"accY_std\"]  = float(max(np.std(accy), 1e-6))\n",
    "    if gyz:\n",
    "        scalers_cell1[\"gyroZ_mean\"] = float(np.mean(gyz))\n",
    "        scalers_cell1[\"gyroZ_std\"]  = float(max(np.std(gyz), 1e-6))\n",
    "\n",
    "    print(\"Scalers:\", scalers_cell1)\n",
    "\n",
    "    # 3) extract full training dataset --------------------------------------\n",
    "    print(\"\\nExtracting training sequences (all streams) …\")\n",
    "    full_ds = PIEDataset(\n",
    "        pie_db_cell1,\n",
    "        TRAIN_SETS_STR, # Use TRAIN_SETS_STR for training data extraction\n",
    "        POSE_DATA_DIR,\n",
    "        SEQ_LEN,\n",
    "        PRED_LEN,\n",
    "        scalers_cell1,\n",
    "        ALL_POSSIBLE_STREAMS,\n",
    "    )\n",
    "\n",
    "    train_dict = {s: [] for s in ALL_POSSIBLE_STREAMS}\n",
    "    train_dict[\"label\"] = []\n",
    "\n",
    "    for i in tqdm(range(len(full_ds)), desc=\"seq\"):\n",
    "        feat, lbl = full_ds[i]\n",
    "        for s in ALL_POSSIBLE_STREAMS:\n",
    "            train_dict[s].append(feat[s].numpy())\n",
    "        train_dict[\"label\"].append([lbl.item()])\n",
    "\n",
    "    print(f\"Raw training samples: {len(train_dict['label'])}\")\n",
    "\n",
    "    # 4) balance -------------------------------------------------------------\n",
    "    balanced = balance_samples_count(train_dict, \"label\")\n",
    "    del train_dict, full_ds\n",
    "    gc.collect()\n",
    "\n",
    "    # 5) write pickles -------------------------------------------------------\n",
    "    print(\"\\nSaving balanced data …\")\n",
    "    with open(BALANCED_DATA_PKL_PATH, \"wb\") as fp:\n",
    "        pickle.dump(balanced, fp, pickle.HIGHEST_PROTOCOL)\n",
    "    print(f\"✓ {BALANCED_DATA_PKL_PATH}\")\n",
    "\n",
    "    print(\"Saving scalers …\")\n",
    "    with open(SCALERS_PKL_PATH, \"wb\") as fp:\n",
    "        pickle.dump(scalers_cell1, fp, pickle.HIGHEST_PROTOCOL)\n",
    "    print(f\"✓ {SCALERS_PKL_PATH}\")\n",
    "\n",
    "    del pie_db_cell1, scalers_cell1 # Clean up cell1 specific vars\n",
    "    gc.collect()\n",
    "\n",
    "    print(\"\\n--- CELL 1: DATA PREPARATION COMPLETE ---\")\n",
    "else:\n",
    "    if Path(BALANCED_DATA_PKL_PATH).exists() and Path(SCALERS_PKL_PATH).exists():\n",
    "        print(\"\\n--- CELL 1: Skipping data preparation, balanced data and scalers found. ---\")\n",
    "    else:\n",
    "        print(\"\\n--- CELL 1: ERROR - Balanced data or scalers missing, but not regenerating. Please check paths or remove existing files to force regeneration. ---\")\n",
    "\n",
    "\n",
    "# --- CELL 2: ABLATION STUDY – MODEL TRAINING AND EVALUATION (with Weighted Average Fusion, Hyperparameter Tuning, and Test on Set03) ---\n",
    "\n",
    "import os\n",
    "import sys\n",
    "import gc\n",
    "import time\n",
    "import math\n",
    "import random\n",
    "import pickle\n",
    "import torch\n",
    "import numpy as np\n",
    "import pandas as pd                      # results-summary table\n",
    "import torch.nn as nn\n",
    "import torch.optim as optim\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from tqdm.notebook import tqdm\n",
    "from torch.utils.data import Dataset, DataLoader\n",
    "from sklearn.metrics import (\n",
    "    accuracy_score,\n",
    "    precision_recall_fscore_support,\n",
    "    roc_auc_score,\n",
    "    confusion_matrix,\n",
    "    ConfusionMatrixDisplay,\n",
    "    f1_score # Explicitly import\n",
    ")\n",
    "import optuna # For hyperparameter tuning\n",
    "\n",
    "# --- Add PIE utilities path if necessary (adjust path) ------------------------\n",
    "pie_utilities_path = \"/kaggle/working/PIE/utilities\"\n",
    "if pie_utilities_path not in sys.path:\n",
    "    sys.path.insert(0, pie_utilities_path)\n",
    "\n",
    "try:\n",
    "    from pie_data import PIE as PIE_imported_cell2 # Rename to avoid conflict with PIE from cell1\n",
    "except ImportError as e:\n",
    "    print(f\"Warn: Could not import PIE class for Cell 2: {e}\")\n",
    "    PIE_imported_cell2 = None\n",
    "\n",
    "# --- Configuration ------------------------------------------------------------\n",
    "PIE_ROOT_PATH_CELL2 = \"/kaggle/working/PIE\" # Renamed for clarity\n",
    "POSE_DATA_DIR_CELL2 = \"/kaggle/input/pose-data/extracted_poses2\"\n",
    "PIE_DATABASE_CACHE_PATH_CELL2 = \"/kaggle/input/pie-database/pie_database.pkl\"\n",
    "\n",
    "# --- Define ALL possible streams (used by Dataset class) ----------------------\n",
    "ALL_POSSIBLE_STREAMS_CELL2 = [ # Renamed to avoid conflict if cell1 not run\n",
    "    \"bbox\",\n",
    "    \"pose\",\n",
    "    \"ego_speed\",\n",
    "    \"ego_acc\",\n",
    "    \"ego_gyro\",\n",
    "    \"ped_action\",\n",
    "    \"ped_look\",\n",
    "    \"ped_occlusion\",\n",
    "    \"traffic_light\",\n",
    "    \"static_context\",\n",
    "]\n",
    "\n",
    "# --- *** CHOOSE ACTIVE STREAMS FOR THIS EXPERIMENT *** ------------------------\n",
    "ACTIVE_STREAMS = [\n",
    "    \"bbox\",\n",
    "    \"ped_action\",\n",
    "    \"ped_look\",\n",
    "    \"ego_speed\",\n",
    "    \"ego_acc\",\n",
    "    \"static_context\",\n",
    "]\n",
    "# ------------------------------------------------------------------------------\n",
    "\n",
    "print(f\"--- Running Weighted Average Fusion With Active Streams: {ACTIVE_STREAMS} ---\")\n",
    "\n",
    "# --- Model Hyper-parameters (default, will be tuned) --------------------------\n",
    "# SEQ_LEN, PRED_LEN already defined in Cell 1, assuming they are globally accessible\n",
    "# INPUT_SIZE_* constants also from Cell 1\n",
    "\n",
    "# Default values, Optuna will override these during tuning\n",
    "DEFAULT_LSTM_HIDDEN_SIZE = 256\n",
    "DEFAULT_NUM_LSTM_LAYERS = 2\n",
    "DEFAULT_DROPOUT_RATE = 0.3\n",
    "DEFAULT_ATTENTION_DIM = 128\n",
    "NUM_CLASSES = 2 # Fixed\n",
    "\n",
    "# --- Training Hyper-parameters (default, LR will be tuned) --------------------\n",
    "DEFAULT_LEARNING_RATE = 1e-4\n",
    "BATCH_SIZE = 32 # Fixed for this example, can also be tuned\n",
    "DEVICE = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "print(f\"Using device: {DEVICE}\")\n",
    "\n",
    "# --- Optuna & Training Epochs Configuration ---\n",
    "N_OPTUNA_TRIALS = 15  # Number of hyperparameter tuning trials (adjust as needed)\n",
    "NUM_EPOCHS_TUNING = 3 # Epochs for each Optuna trial (short for speed)\n",
    "NUM_EPOCHS_FINAL_TRAINING = 5 # Epochs for training the best model (can be same as original NUM_EPOCHS)\n",
    "SEED = 42 # For reproducibility\n",
    "\n",
    "# --- Dataset splits -----------------------------------------------------------\n",
    "# VAL_SETS_STR: Used for validating models during Optuna hyperparameter search\n",
    "VAL_SETS_STR = [\"set03\"]\n",
    "# TEST_SET_STR: Used for final testing of the *best* model from Optuna\n",
    "TEST_SET_STR = [\"set04\"]\n",
    "\n",
    "# --- Paths for pre-processed data (from Cell 1) -------------------------------\n",
    "# BALANCED_DATA_PKL_PATH and SCALERS_PKL_PATH already defined in Cell 1\n",
    "\n",
    "# --- Set random seeds for reproducibility ---\n",
    "random.seed(SEED)\n",
    "np.random.seed(SEED)\n",
    "torch.manual_seed(SEED)\n",
    "if torch.cuda.is_available():\n",
    "    torch.cuda.manual_seed_all(SEED)\n",
    "torch.backends.cudnn.deterministic = True\n",
    "torch.backends.cudnn.benchmark = False\n",
    "\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                               Helper classes (Dataset)                       #\n",
    "# -----------------------------------------------------------------------------\n",
    "\n",
    "# Using to_one_hot from Cell 1. If Cell 1 is not run, define it here:\n",
    "if 'to_one_hot' not in globals():\n",
    "    def to_one_hot(index, num_classes):\n",
    "        vec = np.zeros(num_classes, dtype=np.float32)\n",
    "        safe_index = int(np.clip(index, 0, num_classes - 1))\n",
    "        vec[safe_index] = 1.0\n",
    "        return vec\n",
    "\n",
    "class PIEDataset_Cell2(Dataset): # Renamed to avoid conflict if Cell 1 is run in same notebook\n",
    "    \"\"\"\n",
    "    Dataset that can dynamically enable/disable streams. (Copied from original cell 2)\n",
    "    \"\"\"\n",
    "    def __init__(\n",
    "        self,\n",
    "        pie_database,\n",
    "        set_names,\n",
    "        pose_data_dir,\n",
    "        seq_len,\n",
    "        pred_len,\n",
    "        scalers=None,\n",
    "        streams_to_extract=None, # These are the streams this instance will actually load\n",
    "    ):\n",
    "        self.pie_db = pie_database\n",
    "        self.set_names = set_names\n",
    "        self.pose_data_dir = pose_data_dir\n",
    "        self.seq_len = seq_len\n",
    "        self.pred_len = pred_len\n",
    "        self.scalers = scalers or {}\n",
    "        self.streams_to_extract = streams_to_extract or ALL_POSSIBLE_STREAMS_CELL2 # Default to all if not specified\n",
    "        \n",
    "        self.sequences = []\n",
    "        self.all_pose_data = {}\n",
    "\n",
    "        self._input_sizes_for_error = self._get_input_sizes_dict() # For error handling\n",
    "\n",
    "        if \"pose\" in self.streams_to_extract:\n",
    "            self._load_pose_data()\n",
    "\n",
    "        self._generate_sequence_list()\n",
    "        if not self.sequences:\n",
    "            print(f\"Warning: PIEDataset_Cell2 init: No sequences found for sets {self.set_names} with current config.\")\n",
    "\n",
    "\n",
    "    def _get_input_sizes_dict(self): # Uses global INPUT_SIZE_* constants\n",
    "        input_sizes = {}\n",
    "        special_cases = {\n",
    "            \"TRAFFIC_LIGHT\": \"TL_STATE\", \"STATIC_CONTEXT\": \"STATIC\",\n",
    "            \"EGO_SPEED\": \"EGO_SPEED\", \"EGO_ACC\": \"EGO_ACC\", \"EGO_GYRO\": \"EGO_GYRO\",\n",
    "            \"PED_ACTION\": \"PED_ACTION\", \"PED_LOOK\": \"PED_LOOK\", \"PED_OCCLUSION\": \"PED_OCC\",\n",
    "        }\n",
    "        for stream in ALL_POSSIBLE_STREAMS_CELL2: # Check against all possible for safety\n",
    "            size_constant_name = f\"INPUT_SIZE_{stream.upper()}\"\n",
    "            suffix = special_cases.get(stream.upper())\n",
    "            if suffix: size_constant_name = f\"INPUT_SIZE_{suffix}\"\n",
    "            elif stream == \"bbox\": size_constant_name = \"INPUT_SIZE_BBOX\"\n",
    "            elif stream == \"pose\": size_constant_name = \"INPUT_SIZE_POSE\"\n",
    "            input_sizes[stream] = globals().get(size_constant_name, 1) # globals() is from Cell 1 scope\n",
    "        return input_sizes\n",
    "\n",
    "    def _load_pose_data(self):\n",
    "        # print(f\"PIEDataset_Cell2: Loading pose PKLs for sets {self.set_names} (streams_to_extract: {self.streams_to_extract})…\")\n",
    "        for set_id in self.set_names:\n",
    "            self.all_pose_data[set_id] = {}\n",
    "            pose_set_path = os.path.join(self.pose_data_dir, set_id)\n",
    "            if not os.path.isdir(pose_set_path): \n",
    "                # print(f\"PIEDataset_Cell2: Pose directory not found for set {set_id}: {pose_set_path}\")\n",
    "                continue\n",
    "            \n",
    "            pkl_files_in_set = [f for f in os.listdir(pose_set_path) if f.startswith(f\"{set_id}_\") and f.endswith(\"_poses.pkl\")]\n",
    "            if not pkl_files_in_set: \n",
    "                # print(f\"PIEDataset_Cell2: No pose PKL files found in {pose_set_path}\")\n",
    "                continue\n",
    "\n",
    "            for pkl_filename in pkl_files_in_set: # Not using tqdm here to reduce noise during HPO\n",
    "                pkl_file_path = os.path.join(pose_set_path, pkl_filename)\n",
    "                try:\n",
    "                    with open(pkl_file_path, \"rb\") as f: loaded_pkl_content = pickle.load(f)\n",
    "                except FileNotFoundError: continue\n",
    "                except Exception as e: print(f\"PIEDataset_Cell2: Error loading pose PKL {pkl_file_path}: {e}\"); continue\n",
    "                \n",
    "                if len(loaded_pkl_content) != 1: continue\n",
    "                unique_video_key, video_data = list(loaded_pkl_content.items())[0]\n",
    "                video_id = \"_\".join(unique_video_key.split(\"_\")[1:])\n",
    "                \n",
    "                if self.pie_db and set_id in self.pie_db and video_id in self.pie_db.get(set_id, {}):\n",
    "                    self.all_pose_data[set_id][video_id] = video_data\n",
    "\n",
    "    def _generate_sequence_list(self):\n",
    "        # print(f\"PIEDataset_Cell2: Enumerating sequences for sets {self.set_names}…\")\n",
    "        sequence_count = 0\n",
    "        if not self.pie_db:\n",
    "            print(f\"PIEDataset_Cell2: PIE database not available for {self.set_names}.\")\n",
    "            return\n",
    "\n",
    "        for set_id in self.set_names:\n",
    "            if set_id not in self.pie_db: continue\n",
    "            for video_id, video_data in self.pie_db[set_id].items():\n",
    "                if \"ped_annotations\" not in video_data: continue\n",
    "                for ped_id, ped_data in video_data[\"ped_annotations\"].items():\n",
    "                    frames = ped_data.get(\"frames\", [])\n",
    "                    if len(frames) < self.seq_len + self.pred_len: continue\n",
    "                    frames_sorted = sorted(frames)\n",
    "                    for i in range(len(frames_sorted) - self.seq_len - self.pred_len + 1):\n",
    "                        start_f, obs_end_f = frames_sorted[i], frames_sorted[i + self.seq_len - 1]\n",
    "                        if obs_end_f - start_f != self.seq_len - 1: continue\n",
    "                        \n",
    "                        target_idx_in_frames_sorted = i + self.seq_len + self.pred_len - 1\n",
    "                        if target_idx_in_frames_sorted >= len(frames_sorted): continue # Boundary check\n",
    "                        target_f = frames_sorted[target_idx_in_frames_sorted]\n",
    "\n",
    "                        if target_f - obs_end_f != self.pred_len: continue\n",
    "                        self.sequences.append((set_id, video_id, ped_id, start_f))\n",
    "                        sequence_count += 1\n",
    "        # print(f\"PIEDataset_Cell2: Total sequences for {self.set_names}: {sequence_count}\")\n",
    "\n",
    "\n",
    "    def __len__(self): return len(self.sequences)\n",
    "\n",
    "    def __getitem__(self, idx):\n",
    "        set_id, video_id, ped_id, start_frame = self.sequences[idx]\n",
    "        frame_nums = list(range(start_frame, start_frame + self.seq_len))\n",
    "        target_frame_num = start_frame + self.seq_len + self.pred_len - 1\n",
    "        \n",
    "        video_db, ped_db = {}, {}\n",
    "        if self.pie_db and set_id in self.pie_db and video_id in self.pie_db[set_id]:\n",
    "            video_db = self.pie_db[set_id][video_id]\n",
    "            ped_db = video_db.get(\"ped_annotations\", {}).get(ped_id, {})\n",
    "        \n",
    "        ego_db = video_db.get(\"vehicle_annotations\", {}) if video_db else {}\n",
    "        traffic_db = video_db.get(\"traffic_annotations\", {}) if video_db else {}\n",
    "        ped_attributes = ped_db.get(\"attributes\", {}) if ped_db else {}\n",
    "\n",
    "        feature_sequences = {s: [] for s in self.streams_to_extract}\n",
    "        label = 0\n",
    "        if ped_db and \"frames\" in ped_db and \"behavior\" in ped_db and \"cross\" in ped_db[\"behavior\"]:\n",
    "            try:\n",
    "                target_idx_in_pdb_frames = ped_db[\"frames\"].index(target_frame_num)\n",
    "                label = ped_db[\"behavior\"][\"cross\"][target_idx_in_pdb_frames]\n",
    "                if label == -1: label = 0\n",
    "            except (ValueError, IndexError): pass\n",
    "\n",
    "        static_vec = np.zeros(INPUT_SIZE_STATIC, dtype=np.float32) # From Cell 1\n",
    "        if \"static_context\" in self.streams_to_extract:\n",
    "            sig_idx = ped_attributes.get(\"signalized\", 0)\n",
    "            int_idx = ped_attributes.get(\"intersection\", 0)\n",
    "            age_idx = ped_attributes.get(\"age\", 2) # Default to adult if missing\n",
    "            gen_idx = ped_attributes.get(\"gender\", 0) # Default to male/unknown\n",
    "            td_idx = int(ped_attributes.get(\"traffic_direction\", 0))\n",
    "            nl_val = ped_attributes.get(\"num_lanes\", 2) # Default to 2 lanes\n",
    "            nl_cat_idx = LANE_CATEGORIES.get(nl_val, LANE_CATEGORIES[max(LANE_CATEGORIES.keys())]) # Cell 1\n",
    "            \n",
    "            static_vec = np.concatenate([\n",
    "                to_one_hot(sig_idx, NUM_SIGNALIZED_CATS), to_one_hot(int_idx, NUM_INTERSECTION_CATS),\n",
    "                to_one_hot(age_idx, NUM_AGE_CATS), to_one_hot(gen_idx, NUM_GENDER_CATS),\n",
    "                to_one_hot(td_idx, NUM_TRAFFIC_DIR_CATS), to_one_hot(nl_cat_idx, NUM_LANE_CATS),\n",
    "            ]).astype(np.float32)\n",
    "            if static_vec.shape[0] != INPUT_SIZE_STATIC: # Should not happen with globals\n",
    "                static_vec = np.zeros(INPUT_SIZE_STATIC, dtype=np.float32)\n",
    "\n",
    "\n",
    "        for frame_num in frame_nums:\n",
    "            frame_db_idx = -1 # Index within ped_db['frames']\n",
    "            if ped_db and \"frames\" in ped_db:\n",
    "                try: frame_db_idx = ped_db[\"frames\"].index(frame_num)\n",
    "                except ValueError: pass\n",
    "            \n",
    "            ego_frame_data = ego_db.get(frame_num, {})\n",
    "\n",
    "            if \"bbox\" in self.streams_to_extract:\n",
    "                bbox_norm = np.zeros(INPUT_SIZE_BBOX, dtype=np.float32) # Cell 1\n",
    "                if ped_db and frame_db_idx!=-1 and \"bbox\" in ped_db and len(ped_db[\"bbox\"]) > frame_db_idx:\n",
    "                    try:\n",
    "                        x1,y1,x2,y2 = ped_db[\"bbox\"][frame_db_idx]\n",
    "                        img_w = video_db.get(\"width\",1920) if video_db else 1920\n",
    "                        img_h = video_db.get(\"height\",1080) if video_db else 1080\n",
    "                        if img_w > 0 and img_h > 0:\n",
    "                            cx,cy,w,h = ((x1+x2)/2)/img_w, ((y1+y2)/2)/img_h, (x2-x1)/img_w, (y2-y1)/img_h\n",
    "                            if 0<w and 0<h and 0<=cx<=1 and 0<=cy<=1: \n",
    "                                bbox_norm=np.array([cx,cy,w,h],dtype=np.float32)\n",
    "                    except Exception: pass\n",
    "                feature_sequences[\"bbox\"].append(bbox_norm)\n",
    "\n",
    "            if \"pose\" in self.streams_to_extract:\n",
    "                pose_vector = np.zeros(INPUT_SIZE_POSE, dtype=np.float32) # Cell 1\n",
    "                # Ensure all_pose_data and its nested dicts are accessed safely\n",
    "                vid_pose_data = self.all_pose_data.get(set_id, {}).get(video_id, {})\n",
    "                ped_pose_at_frame = vid_pose_data.get(frame_num, {}).get(ped_id)\n",
    "                if isinstance(ped_pose_at_frame, np.ndarray) and ped_pose_at_frame.shape == (INPUT_SIZE_POSE,):\n",
    "                    pose_vector = ped_pose_at_frame\n",
    "                feature_sequences[\"pose\"].append(pose_vector)\n",
    "\n",
    "            if \"ego_speed\" in self.streams_to_extract:\n",
    "                speed = ego_frame_data.get(\"OBD_speed\",0.0) or ego_frame_data.get(\"GPS_speed\",0.0)\n",
    "                speed_scaled = (speed - self.scalers.get(\"ego_speed_mean\",0.0)) / self.scalers.get(\"ego_speed_std\",1.0)\n",
    "                feature_sequences[\"ego_speed\"].append([speed_scaled])\n",
    "\n",
    "            if \"ego_acc\" in self.streams_to_extract:\n",
    "                ax,ay = ego_frame_data.get(\"accX\",0.0), ego_frame_data.get(\"accY\",0.0)\n",
    "                ax_s = (ax - self.scalers.get(\"accX_mean\",0.0))/self.scalers.get(\"accX_std\",1.0)\n",
    "                ay_s = (ay - self.scalers.get(\"accY_mean\",0.0))/self.scalers.get(\"accY_std\",1.0)\n",
    "                feature_sequences[\"ego_acc\"].append([ax_s, ay_s])\n",
    "\n",
    "            if \"ego_gyro\" in self.streams_to_extract:\n",
    "                gz = ego_frame_data.get(\"gyroZ\",0.0)\n",
    "                gz_s = (gz - self.scalers.get(\"gyroZ_mean\",0.0))/self.scalers.get(\"gyroZ_std\",1.0)\n",
    "                feature_sequences[\"ego_gyro\"].append([gz_s])\n",
    "\n",
    "            if \"ped_action\" in self.streams_to_extract:\n",
    "                action=0.0 # Default if not found\n",
    "                if ped_db and frame_db_idx!=-1 and \"behavior\" in ped_db and \\\n",
    "                   \"action\" in ped_db[\"behavior\"] and len(ped_db[\"behavior\"][\"action\"]) > frame_db_idx:\n",
    "                    action = float(ped_db[\"behavior\"][\"action\"][frame_db_idx])\n",
    "                feature_sequences[\"ped_action\"].append([action])\n",
    "\n",
    "            if \"ped_look\" in self.streams_to_extract:\n",
    "                look=0.0 # Default\n",
    "                if ped_db and frame_db_idx!=-1 and \"behavior\" in ped_db and \\\n",
    "                   \"look\" in ped_db[\"behavior\"] and len(ped_db[\"behavior\"][\"look\"]) > frame_db_idx:\n",
    "                    look = float(ped_db[\"behavior\"][\"look\"][frame_db_idx])\n",
    "                feature_sequences[\"ped_look\"].append([look])\n",
    "\n",
    "            if \"ped_occlusion\" in self.streams_to_extract:\n",
    "                occ=0.0 # Default\n",
    "                if ped_db and frame_db_idx!=-1 and \"occlusion\" in ped_db and \\\n",
    "                   len(ped_db[\"occlusion\"]) > frame_db_idx:\n",
    "                    occ = float(ped_db[\"occlusion\"][frame_db_idx])/2.0 # Normalize 0-2 to 0-1\n",
    "                feature_sequences[\"ped_occlusion\"].append([occ])\n",
    "            \n",
    "            if \"traffic_light\" in self.streams_to_extract:\n",
    "                state_int=0 # Default: undefined/no relevant TL\n",
    "                for _,obj_data in traffic_db.items(): # Iterate through traffic objects\n",
    "                    if obj_data.get(\"obj_class\")==\"traffic_light\" and \"frames\" in obj_data and \"state\" in obj_data:\n",
    "                        try:\n",
    "                            tl_idx_in_obj_frames = obj_data[\"frames\"].index(frame_num)\n",
    "                            if obj_data[\"state\"][tl_idx_in_obj_frames]!=0: # 0 is often undefined/irrelevant\n",
    "                                state_int=obj_data[\"state\"][tl_idx_in_obj_frames]\n",
    "                                break # Assume first relevant TL is the one\n",
    "                        except (ValueError,IndexError): continue\n",
    "                feature_sequences[\"traffic_light\"].append(to_one_hot(state_int,INPUT_SIZE_TL_STATE)) # Cell 1\n",
    "\n",
    "            if \"static_context\" in self.streams_to_extract:\n",
    "                feature_sequences[\"static_context\"].append(static_vec) # Already computed per sequence\n",
    "\n",
    "        # Convert lists of features to tensors\n",
    "        final_features = {}\n",
    "        try:\n",
    "            for stream_name in self.streams_to_extract:\n",
    "                # Ensure all sub-lists in feature_sequences[stream_name] have consistent shape before asarray\n",
    "                np_array = np.asarray(feature_sequences[stream_name], dtype=np.float32)\n",
    "                if np_array.ndim == 1 and self._input_sizes_for_error.get(stream_name,1) > 1: # handles case where list of lists might become 1D\n",
    "                     np_array = np_array.reshape(self.seq_len, -1)\n",
    "\n",
    "                expected_shape_dim1 = self._input_sizes_for_error.get(stream_name,1)\n",
    "                if np_array.shape != (self.seq_len, expected_shape_dim1):\n",
    "                     # Fallback if shapes are inconsistent, e.g. due to missing data for a frame\n",
    "                     # print(f\"Warning: Shape mismatch for stream {stream_name}. Expected {(self.seq_len, expected_shape_dim1)}, got {np_array.shape}. Using zeros.\")\n",
    "                     np_array = np.zeros((self.seq_len, expected_shape_dim1), dtype=np.float32)\n",
    "\n",
    "                final_features[stream_name] = torch.tensor(np_array, dtype=torch.float32)\n",
    "\n",
    "        except Exception as e: # Catch-all for unexpected errors during tensor conversion\n",
    "            print(f\"PIEDataset_Cell2: Error converting features for idx {idx} ({set_id},{video_id},{ped_id},{start_frame}): {e}. Returning zero tensors.\")\n",
    "            final_features = {\n",
    "                name: torch.zeros((self.seq_len, self._input_sizes_for_error.get(name, 1)), dtype=torch.float32)\n",
    "                for name in self.streams_to_extract\n",
    "            }\n",
    "            \n",
    "        return final_features, torch.tensor(label,dtype=torch.long)\n",
    "\n",
    "\n",
    "class BalancedDataset(Dataset): # For using pre-loaded balanced data\n",
    "    def __init__(self, data_dict, active_streams_list, label_key=\"label\"):\n",
    "        self.active_streams = active_streams_list # The streams the model will actually use\n",
    "        self.label_key = label_key\n",
    "        \n",
    "        if self.label_key not in data_dict or not data_dict[self.label_key]:\n",
    "            raise ValueError(f\"Label key '{self.label_key}' missing or empty in data_dict.\")\n",
    "        \n",
    "        self.num_samples = len(data_dict[self.label_key])\n",
    "        if self.num_samples == 0: \n",
    "            print(\"Warning: BalancedDataset initialized with zero samples.\")\n",
    "        \n",
    "        self.features_from_dict = {} # Stores tensors for active_streams\n",
    "        for stream in self.active_streams:\n",
    "            if stream in data_dict and data_dict[stream]:\n",
    "                try: \n",
    "                    # Data from pickle is already numpy array, convert to tensor\n",
    "                    self.features_from_dict[stream] = torch.tensor(np.asarray(data_dict[stream]),dtype=torch.float32)\n",
    "                except ValueError as e: \n",
    "                    raise ValueError(f\"Error converting stream '{stream}' from data_dict: {e}\")\n",
    "            else:\n",
    "                # This should not happen if Cell 1 ran correctly and ACTIVE_STREAMS are subset of ALL_POSSIBLE_STREAMS\n",
    "                raise KeyError(f\"Stream '{stream}' (active) missing or empty in provided data_dict.\")\n",
    "\n",
    "        try: \n",
    "            self.labels = torch.tensor([lbl[0] for lbl in data_dict[self.label_key]],dtype=torch.long)\n",
    "        except (IndexError, TypeError) as e: \n",
    "            raise ValueError(f\"Error converting labels from data_dict: {e}\")\n",
    "\n",
    "        # Sanity check lengths\n",
    "        for stream in self.active_streams:\n",
    "            if len(self.features_from_dict[stream]) != self.num_samples:\n",
    "                raise ValueError(f\"Length mismatch: Stream '{stream}' has {len(self.features_from_dict[stream])} samples, but labels have {self.num_samples}.\")\n",
    "\n",
    "    def __len__(self): return self.num_samples\n",
    "    \n",
    "    def __getitem__(self, idx):\n",
    "        # Return a dictionary of features, only for the active_streams\n",
    "        feature_dict_for_model = {s: self.features_from_dict[s][idx] for s in self.active_streams}\n",
    "        label = self.labels[idx]\n",
    "        return feature_dict_for_model, label\n",
    "\n",
    "\n",
    "class Attention(nn.Module):\n",
    "    def __init__(self, hidden_dim, attention_dim):\n",
    "        super().__init__()\n",
    "        self.attention_net = nn.Sequential(\n",
    "            nn.Linear(hidden_dim, attention_dim), nn.Tanh(), nn.Linear(attention_dim, 1),\n",
    "        )\n",
    "    def forward(self, lstm_output): # (batch, seq_len, hidden_dim*2)\n",
    "        att_scores = self.attention_net(lstm_output).squeeze(2) # (batch, seq_len)\n",
    "        att_weights = torch.softmax(att_scores, dim=1) # (batch, seq_len)\n",
    "        context_vector = torch.sum(lstm_output * att_weights.unsqueeze(2), dim=1) # (batch, hidden_dim*2)\n",
    "        return context_vector, att_weights\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                  ***  MODEL WITH WEIGHTED AVERAGE FUSION  ***                #\n",
    "# -----------------------------------------------------------------------------\n",
    "class MultiStreamWeightedAvgLSTM(nn.Module):\n",
    "    def __init__(\n",
    "        self, input_sizes_dict, lstm_hidden_size, num_lstm_layers,\n",
    "        num_classes, attention_dim, dropout_rate, active_stream_names_list=None,\n",
    "    ):\n",
    "        super().__init__()\n",
    "        if not active_stream_names_list: raise ValueError(\"active_stream_names_list cannot be empty.\")\n",
    "        \n",
    "        self.active_stream_names = active_stream_names_list\n",
    "        self.num_active_streams = len(active_stream_names_list)\n",
    "        self.lstm_output_dim = lstm_hidden_size * 2 # Bidirectional\n",
    "        \n",
    "        self.lstms, self.attentions = nn.ModuleDict(), nn.ModuleDict()\n",
    "        \n",
    "        # print(f\"Initializing Weighted-Avg model with streams: {self.active_stream_names}\")\n",
    "        for name in self.active_stream_names:\n",
    "            if name not in input_sizes_dict: \n",
    "                raise KeyError(f\"Input size for stream '{name}' not provided in input_sizes_dict.\")\n",
    "            in_size = input_sizes_dict[name]\n",
    "            # print(f\"  – Adding stream '{name}' (input size: {in_size}, LSTM hidden: {lstm_hidden_size})\")\n",
    "            self.lstms[name] = nn.LSTM(\n",
    "                in_size, lstm_hidden_size, num_lstm_layers, batch_first=True,\n",
    "                dropout=dropout_rate if num_lstm_layers > 1 else 0, bidirectional=True,\n",
    "            )\n",
    "            self.attentions[name] = Attention(self.lstm_output_dim, attention_dim)\n",
    "            \n",
    "        self.fusion_weights = nn.Parameter(torch.ones(self.num_active_streams))\n",
    "        \n",
    "        fused_representation_dim = self.lstm_output_dim # Since we average same-sized context vectors\n",
    "        \n",
    "        self.dropout_layer = nn.Dropout(dropout_rate)\n",
    "        \n",
    "        # Intermediate FC layer dimension (heuristic)\n",
    "        intermediate_fc_dim = max(num_classes * 4, fused_representation_dim // 2)\n",
    "        \n",
    "        self.fc1 = nn.Linear(fused_representation_dim, intermediate_fc_dim)\n",
    "        self.relu_activation = nn.ReLU()\n",
    "        self.fc2_final_classifier = nn.Linear(intermediate_fc_dim, num_classes)\n",
    "\n",
    "    def forward(self, x_input_dict): # x_input_dict contains {stream_name: tensor}\n",
    "        context_vectors_list = []\n",
    "        \n",
    "        for stream_name in self.active_stream_names:\n",
    "            if stream_name not in x_input_dict:\n",
    "                # This case should ideally be handled by the DataLoader ensuring all active streams are present.\n",
    "                # If a stream is truly optional and might be missing, this needs robust handling.\n",
    "                # For now, assume all active_stream_names are keys in x_input_dict.\n",
    "                # print(f\"Warning: Stream '{stream_name}' not in input dict x. Using zeros.\")\n",
    "                # Fallback: create a zero tensor. This might affect training if happens often.\n",
    "                batch_size_est = x_input_dict[next(iter(x_input_dict))].shape[0] # Get batch size from another stream\n",
    "                zero_ctx = torch.zeros(batch_size_est, self.lstm_output_dim, device=DEVICE)\n",
    "                context_vectors_list.append(zero_ctx)\n",
    "                continue\n",
    "\n",
    "            lstm_out, _ = self.lstms[stream_name](x_input_dict[stream_name])\n",
    "            context_vector, _ = self.attentions[stream_name](lstm_out)\n",
    "            context_vectors_list.append(context_vector)\n",
    "            \n",
    "        if len(context_vectors_list) != self.num_active_streams:\n",
    "            raise RuntimeError(f\"Mismatch: collected {len(context_vectors_list)} context vectors, expected {self.num_active_streams} for streams {self.active_stream_names}\")\n",
    "\n",
    "        # Stack context vectors for weighted sum: (batch, num_streams, lstm_output_dim)\n",
    "        stacked_context_vectors = torch.stack(context_vectors_list, dim=1)\n",
    "        \n",
    "        # Apply softmax to fusion_weights to make them sum to 1: (num_streams) -> (1, num_streams, 1) for broadcasting\n",
    "        normalized_fusion_weights = torch.softmax(self.fusion_weights, dim=0).view(1, -1, 1)\n",
    "        \n",
    "        # Weighted sum: (batch, num_streams, lstm_output_dim) * (1, num_streams, 1) -> sum over dim=1\n",
    "        fused_representation = torch.sum(stacked_context_vectors * normalized_fusion_weights, dim=1) # (batch, lstm_output_dim)\n",
    "        \n",
    "        # Pass through final classification layers\n",
    "        out = self.dropout_layer(fused_representation)\n",
    "        out = self.relu_activation(self.fc1(out))\n",
    "        out = self.dropout_layer(out)\n",
    "        logits = self.fc2_final_classifier(out)\n",
    "        \n",
    "        return logits\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#         Training / evaluation / Threshold Tuning helpers                     #\n",
    "# -----------------------------------------------------------------------------\n",
    "\n",
    "def get_all_probabilities_and_labels(model, dataloader, device):\n",
    "    model.eval()\n",
    "    all_true_labels, all_positive_class_probs = [], []\n",
    "    # active_streams_for_model = model.active_stream_names # Get from model instance\n",
    "\n",
    "    with torch.no_grad():\n",
    "        for features_dict, true_labels in dataloader: # tqdm removed for less noise in HPO\n",
    "            # Ensure only active streams are passed, and they are on the correct device\n",
    "            inputs_for_model = {\n",
    "                name: features_dict[name].to(device) \n",
    "                for name in model.active_stream_names # Use model's configured streams\n",
    "                if name in features_dict # Data loader provides these\n",
    "            }\n",
    "            \n",
    "            logits = model(inputs_for_model)\n",
    "            probabilities = torch.softmax(logits, dim=1)\n",
    "\n",
    "            all_true_labels.extend(true_labels.cpu().numpy())\n",
    "            all_positive_class_probs.extend(probabilities[:, 1].cpu().numpy()) # Prob for class 1\n",
    "\n",
    "    return np.asarray(all_true_labels), np.asarray(all_positive_class_probs)\n",
    "\n",
    "\n",
    "def find_optimal_threshold(y_true, y_probs_positive_class, metric_to_optimize='f1', num_steps=100):\n",
    "    best_threshold_val = 0.5\n",
    "    best_metric_score = -1.0\n",
    "\n",
    "    if metric_to_optimize == 'f1':\n",
    "        # precision_recall_fscore_support returns (precision, recall, f1, support)\n",
    "        # We need the f1_score for the positive class (binary classification)\n",
    "        metric_function = lambda true_y, pred_y: f1_score(true_y, pred_y, pos_label=1, zero_division=0)\n",
    "    else:\n",
    "        raise ValueError(f\"Unsupported metric for threshold tuning: {metric_to_optimize}\")\n",
    "\n",
    "    # Iterate over potential thresholds\n",
    "    threshold_candidates = np.linspace(0.0, 1.0, num_steps + 1)\n",
    "\n",
    "    for current_threshold in threshold_candidates: # tqdm removed\n",
    "        # Apply current threshold to get binary predictions\n",
    "        y_pred_at_threshold = (y_probs_positive_class >= current_threshold).astype(int)\n",
    "        current_metric_score = metric_function(y_true, y_pred_at_threshold)\n",
    "\n",
    "        if current_metric_score > best_metric_score:\n",
    "            best_metric_score = current_metric_score\n",
    "            best_threshold_val = current_threshold\n",
    "        elif current_metric_score == best_metric_score: # Tie-breaking: prefer threshold closer to 0.5\n",
    "            if abs(current_threshold - 0.5) < abs(best_threshold_val - 0.5):\n",
    "                best_threshold_val = current_threshold\n",
    "    \n",
    "    # print(f\"Optimal threshold for {metric_to_optimize.upper()}: {best_threshold_val:.4f} (Max value: {best_metric_score:.4f})\")\n",
    "    return best_threshold_val, best_metric_score\n",
    "\n",
    "\n",
    "def train_epoch(model, dataloader, optimizer, criterion, device):\n",
    "    model.train()\n",
    "    current_epoch_loss = 0.0\n",
    "    # active_streams_for_model = model.active_stream_names\n",
    "\n",
    "    for features_dict, true_labels in dataloader: # tqdm removed for HPO\n",
    "        inputs_for_model = {\n",
    "            name: features_dict[name].to(device) \n",
    "            for name in model.active_stream_names if name in features_dict\n",
    "        }\n",
    "        true_labels = true_labels.to(device)\n",
    "        \n",
    "        optimizer.zero_grad()\n",
    "        logits = model(inputs_for_model)\n",
    "        loss = criterion(logits, true_labels)\n",
    "        loss.backward()\n",
    "        optimizer.step()\n",
    "        current_epoch_loss += loss.item()\n",
    "        \n",
    "    avg_epoch_loss = current_epoch_loss / max(1, len(dataloader))\n",
    "    return avg_epoch_loss # Accuracy calculation removed to speed up HPO, F1 is the target\n",
    "\n",
    "\n",
    "def evaluate_model_performance(model, dataloader, criterion, device, threshold_to_apply=0.5, tune_threshold_on_this_data=False):\n",
    "    \"\"\"Evaluates model, returns metrics. Can optionally tune threshold.\"\"\"\n",
    "    model.eval()\n",
    "    total_eval_loss = 0.0\n",
    "    all_true_labels_list, all_predicted_probs_list = [], []\n",
    "    # active_streams_for_model = model.active_stream_names\n",
    "\n",
    "    with torch.no_grad():\n",
    "        for features_dict, true_labels in dataloader: # tqdm removed for HPO\n",
    "            inputs_for_model = {\n",
    "                name: features_dict[name].to(device) \n",
    "                for name in model.active_stream_names if name in features_dict\n",
    "            }\n",
    "            labels_on_gpu = true_labels.to(device)\n",
    "            \n",
    "            logits = model(inputs_for_model)\n",
    "            loss = criterion(logits, labels_on_gpu)\n",
    "            total_eval_loss += loss.item()\n",
    "            \n",
    "            probabilities = torch.softmax(logits, 1)\n",
    "            all_true_labels_list.extend(true_labels.cpu().numpy())\n",
    "            all_predicted_probs_list.extend(probabilities.cpu().numpy())\n",
    "\n",
    "    avg_eval_loss = total_eval_loss / max(1, len(dataloader))\n",
    "    \n",
    "    y_true_np = np.asarray(all_true_labels_list)\n",
    "    y_probs_all_classes_np = np.asarray(all_predicted_probs_list)\n",
    "    y_probs_positive_class_np = y_probs_all_classes_np[:, 1] # Probabilities for class 1\n",
    "\n",
    "    current_f1_score = 0.0\n",
    "    final_threshold_used = threshold_to_apply\n",
    "\n",
    "    if tune_threshold_on_this_data:\n",
    "        if len(y_true_np) > 0:\n",
    "            optimal_eval_threshold, f1_at_optimal = find_optimal_threshold(y_true_np, y_probs_positive_class_np, metric_to_optimize='f1')\n",
    "            final_threshold_used = optimal_eval_threshold\n",
    "            current_f1_score = f1_at_optimal\n",
    "            # print(f\"  (Threshold tuned on this data: {final_threshold_used:.4f} -> F1: {current_f1_score:.4f})\")\n",
    "        else: # Should not happen with proper dataset handling\n",
    "            # print(\"  (Cannot tune threshold on empty data)\")\n",
    "            current_f1_score = 0.0 # Or NaN\n",
    "    \n",
    "    # Calculate all metrics using the final_threshold_used (either fixed 0.5 or tuned)\n",
    "    y_pred_final = (y_probs_positive_class_np >= final_threshold_used).astype(int)\n",
    "    \n",
    "    acc = accuracy_score(y_true_np, y_pred_final) if len(y_true_np) > 0 else 0.0\n",
    "    prec, rec, f1_final_official, _ = precision_recall_fscore_support(\n",
    "        y_true_np, y_pred_final, average=\"binary\", pos_label=1, zero_division=0\n",
    "    ) if len(y_true_np) > 0 else (0.0,0.0,0.0,None)\n",
    "    \n",
    "    # AUC is independent of threshold\n",
    "    auc = roc_auc_score(y_true_np, y_probs_positive_class_np) if len(np.unique(y_true_np)) > 1 else float(\"nan\")\n",
    "    \n",
    "    return {\n",
    "        \"loss\": avg_eval_loss, \"accuracy\": acc, \"precision\": prec, \n",
    "        \"recall\": rec, \"f1\": f1_final_official, \"auc\": auc,\n",
    "        \"tuned_threshold_if_any\": final_threshold_used if tune_threshold_on_this_data else None,\n",
    "        \"f1_after_tuning_if_any\": current_f1_score if tune_threshold_on_this_data else None,\n",
    "        \"true_labels\": y_true_np, # For external CM plotting or further analysis\n",
    "        \"positive_class_probs\": y_probs_positive_class_np # For external threshold tuning\n",
    "    }\n",
    "\n",
    "\n",
    "# --- Global variables for Optuna objective function ---\n",
    "# These are set before calling Optuna study.\n",
    "# pie_database_global, scalers_global, balanced_train_data_global\n",
    "# train_loader_global, val_loader_for_hpo_global\n",
    "# current_input_sizes_global (derived from ACTIVE_STREAMS)\n",
    "\n",
    "pie_database_global = None\n",
    "scalers_global = None\n",
    "balanced_train_data_global = None\n",
    "train_loader_global = None\n",
    "val_loader_for_hpo_global = None\n",
    "current_input_sizes_global = None\n",
    "\n",
    "\n",
    "def objective_for_optuna(trial: optuna.Trial):\n",
    "    # Hyperparameters to tune\n",
    "    lstm_hidden_s = trial.suggest_categorical('lstm_hidden_size', [128, 256, 384]) # Adjusted choices\n",
    "    num_lstm_l = trial.suggest_int('num_lstm_layers', 1, 2) # Max 2 to keep model smaller\n",
    "    dropout_r = trial.suggest_float('dropout_rate', 0.2, 0.5, step=0.1)\n",
    "    learning_r = trial.suggest_float('learning_rate', 5e-5, 5e-4, log=True) # Adjusted range\n",
    "    attention_d = trial.suggest_categorical('attention_dim', [64, 128]) # Adjusted choices\n",
    "\n",
    "    # Create model with suggested HPs\n",
    "    model_trial = MultiStreamWeightedAvgLSTM(\n",
    "        input_sizes_dict=current_input_sizes_global, # From global scope\n",
    "        lstm_hidden_size=lstm_hidden_s,\n",
    "        num_lstm_layers=num_lstm_l,\n",
    "        num_classes=NUM_CLASSES, # Fixed\n",
    "        attention_dim=attention_d,\n",
    "        dropout_rate=dropout_r,\n",
    "        active_stream_names_list=ACTIVE_STREAMS, # Fixed for this run\n",
    "    ).to(DEVICE)\n",
    "\n",
    "    # Class weights (recalculate in case, though train_loader_global uses balanced data)\n",
    "    train_labels_list = train_loader_global.dataset.labels.tolist()\n",
    "    n_class0, n_class1 = train_labels_list.count(0), train_labels_list.count(1)\n",
    "    total_samples = len(train_labels_list)\n",
    "    \n",
    "    weight_c0, weight_c1 = (1.0,1.0)\n",
    "    if total_samples > 0 and n_class0 > 0 and n_class1 > 0 :\n",
    "        weight_c0 = total_samples / (2. * n_class0)\n",
    "        weight_c1 = total_samples / (2. * n_class1)\n",
    "    \n",
    "    criterion_trial = nn.CrossEntropyLoss(weight=torch.tensor([weight_c0, weight_c1], dtype=torch.float32).to(DEVICE))\n",
    "    optimizer_trial = optim.Adam(model_trial.parameters(), lr=learning_r)\n",
    "\n",
    "    # Training loop for this trial\n",
    "    for epoch_num in range(NUM_EPOCHS_TUNING):\n",
    "        _ = train_epoch(model_trial, train_loader_global, optimizer_trial, criterion_trial, DEVICE)\n",
    "        # No intermediate evaluation during tuning epochs to speed up, F1 on val set after all tuning epochs\n",
    "\n",
    "    # Evaluate on HPO validation set\n",
    "    # The `evaluate_model_performance` can do threshold tuning internally if requested\n",
    "    if len(val_loader_for_hpo_global.dataset) == 0:\n",
    "        print(f\"Optuna trial {trial.number}: HPO Validation dataset is empty. Returning F1=0.\")\n",
    "        return 0.0 # Or handle as Optuna pruner would\n",
    "\n",
    "    eval_results_trial = evaluate_model_performance(\n",
    "        model_trial, val_loader_for_hpo_global, criterion_trial, DEVICE, \n",
    "        tune_threshold_on_this_data=True # This will find optimal F1 on val set for HPO\n",
    "    )\n",
    "    \n",
    "    f1_for_this_trial = eval_results_trial[\"f1_after_tuning_if_any\"] if eval_results_trial[\"f1_after_tuning_if_any\"] is not None else 0.0\n",
    "\n",
    "    # Optuna pruner hook (optional, for early stopping of unpromising trials)\n",
    "    trial.report(f1_for_this_trial, step=NUM_EPOCHS_TUNING -1) # Report at the end of all tuning epochs\n",
    "    if trial.should_prune():\n",
    "        raise optuna.exceptions.TrialPruned()\n",
    "\n",
    "    return f1_for_this_trial # Optuna maximizes this\n",
    "\n",
    "# -----------------------------------------------------------------------------#\n",
    "#                            Main execution block                              #\n",
    "# -----------------------------------------------------------------------------\n",
    "\n",
    "if __name__ == \"__main__\": # Ensures this runs only when script is executed directly\n",
    "    print(\"--- CELL 2: Model Training, HPO, and Evaluation on Set03 ---\")\n",
    "    print(f\"Active Streams: {ACTIVE_STREAMS}\")\n",
    "\n",
    "    # --- 1. Load pre-processed data (from Cell 1) and PIE DB ---\n",
    "    print(\"\\nLoading balanced training data, scalers, and PIE database …\")\n",
    "    try:\n",
    "        with open(BALANCED_DATA_PKL_PATH, \"rb\") as f: balanced_train_data_global = pickle.load(f)\n",
    "        with open(SCALERS_PKL_PATH, \"rb\") as f: scalers_global = pickle.load(f)\n",
    "        if not os.path.exists(PIE_DATABASE_CACHE_PATH_CELL2): \n",
    "            raise FileNotFoundError(f\"PIE db cache not found at {PIE_DATABASE_CACHE_PATH_CELL2}\")\n",
    "        with open(PIE_DATABASE_CACHE_PATH_CELL2, \"rb\") as f: pie_database_global = pickle.load(f)\n",
    "        print(\"   ✓ Pre-processed data and PIE database loaded.\")\n",
    "    except FileNotFoundError as e: \n",
    "        print(f\"ERROR: {e}. Ensure Cell 1 has run successfully and paths are correct.\"); sys.exit(1)\n",
    "    except Exception as e: \n",
    "        print(f\"Error loading data: {e}\"); sys.exit(1)\n",
    "\n",
    "    # --- 2. Prepare Datasets and DataLoaders for HPO and Final Training ---\n",
    "    print(\"\\nCreating Datasets and DataLoaders …\")\n",
    "    try:\n",
    "        # Training dataset (from balanced pickle)\n",
    "        train_dataset_obj = BalancedDataset(\n",
    "            balanced_train_data_global, \n",
    "            ACTIVE_STREAMS, # Model will use these streams\n",
    "            label_key=\"label\"\n",
    "        )\n",
    "        # Validation dataset for HPO (uses VAL_SETS_STR)\n",
    "        # PIEDataset_Cell2 needs all possible streams it *might* be asked for by any model variant.\n",
    "        # Model then picks ACTIVE_STREAMS.\n",
    "        val_dataset_for_hpo_obj = PIEDataset_Cell2(\n",
    "            pie_database_global, VAL_SETS_STR, POSE_DATA_DIR_CELL2, SEQ_LEN, PRED_LEN,\n",
    "            scalers_global, streams_to_extract=ALL_POSSIBLE_STREAMS_CELL2, \n",
    "        )\n",
    "        if len(train_dataset_obj) == 0 : raise ValueError(\"Train dataset (BalancedDataset) is empty!\")\n",
    "        if len(val_dataset_for_hpo_obj) == 0 : print(f\"Warning: HPO Validation dataset ({VAL_SETS_STR}) is empty! Check set names and PIE data.\")\n",
    "\n",
    "        train_loader_global = DataLoader(train_dataset_obj, batch_size=BATCH_SIZE, shuffle=True, num_workers=2, pin_memory=True)\n",
    "        val_loader_for_hpo_global = DataLoader(val_dataset_for_hpo_obj, batch_size=BATCH_SIZE, shuffle=False, num_workers=2, pin_memory=True)\n",
    "        print(f\"   ✓ Train DataLoader ready ({len(train_dataset_obj)} samples).\")\n",
    "        print(f\"   ✓ HPO Validation DataLoader ready ({len(val_dataset_for_hpo_obj)} samples for {VAL_SETS_STR}).\")\n",
    "\n",
    "    except Exception as e: \n",
    "        print(f\"Error creating datasets/dataloaders: {e}\"); raise\n",
    "\n",
    "    # Determine input sizes for active streams (used by model constructor)\n",
    "    current_input_sizes_global = {}\n",
    "    SPECIAL_MAP_CELL2 = { # To map stream names to global INPUT_SIZE constants\n",
    "        \"TRAFFIC_LIGHT\": \"TL_STATE\", \"STATIC_CONTEXT\": \"STATIC\", \"EGO_SPEED\": \"EGO_SPEED\",\n",
    "        \"EGO_ACC\": \"EGO_ACC\", \"EGO_GYRO\": \"EGO_GYRO\", \"PED_ACTION\": \"PED_ACTION\",\n",
    "        \"PED_LOOK\": \"PED_LOOK\", \"PED_OCCLUSION\": \"PED_OCC\",\n",
    "    }\n",
    "    for s_name in ACTIVE_STREAMS:\n",
    "        const_suffix = SPECIAL_MAP_CELL2.get(s_name.upper(), s_name.upper())\n",
    "        if s_name == \"bbox\": const_suffix = \"BBOX\"\n",
    "        elif s_name == \"pose\": const_suffix = \"POSE\"\n",
    "        size_const_name = f\"INPUT_SIZE_{const_suffix}\"\n",
    "        if size_const_name not in globals(): # Check Cell 1 globals\n",
    "            raise ValueError(f\"Input-size constant {size_const_name} for stream '{s_name}' not found in globals.\")\n",
    "        current_input_sizes_global[s_name] = globals()[size_const_name]\n",
    "    \n",
    "    # --- 3. Hyperparameter Optimization with Optuna ---\n",
    "    print(f\"\\n--- Starting Hyperparameter Optimization ({N_OPTUNA_TRIALS} trials, {NUM_EPOCHS_TUNING} epochs/trial) ---\")\n",
    "    # optuna.logging.set_verbosity(optuna.logging.WARNING) # Reduce Optuna's own logging\n",
    "    study = optuna.create_study(\n",
    "        direction=\"maximize\", # We want to maximize F1 score\n",
    "        sampler=optuna.samplers.TPESampler(seed=SEED)\n",
    "    )\n",
    "    \n",
    "    # Pass global vars by assignment before study, objective function will access them\n",
    "    # This is done above where they are defined with _global suffix\n",
    "\n",
    "    start_hpo_time = time.time()\n",
    "    study.optimize(objective_for_optuna, n_trials=N_OPTUNA_TRIALS, show_progress_bar=True)\n",
    "    hpo_duration = time.time() - start_hpo_time\n",
    "    \n",
    "    print(f\"\\n--- Hyperparameter Optimization Finished ({hpo_duration:.2f}s) ---\")\n",
    "    print(f\"Best HPO F1 score on validation set ({VAL_SETS_STR}): {study.best_value:.4f}\")\n",
    "    print(\"Best hyperparameters found:\")\n",
    "    for key, value in study.best_params.items():\n",
    "        print(f\"  {key}: {value}\")\n",
    "    \n",
    "    best_hps = study.best_params\n",
    "\n",
    "    # --- 4. Train Final Model with Best Hyperparameters ---\n",
    "    print(\"\\n--- Training Final Model with Best Hyperparameters ---\")\n",
    "    final_model = MultiStreamWeightedAvgLSTM(\n",
    "        input_sizes_dict=current_input_sizes_global,\n",
    "        lstm_hidden_size=best_hps['lstm_hidden_size'],\n",
    "        num_lstm_layers=best_hps['num_lstm_layers'],\n",
    "        num_classes=NUM_CLASSES,\n",
    "        attention_dim=best_hps['attention_dim'],\n",
    "        dropout_rate=best_hps['dropout_rate'],\n",
    "        active_stream_names_list=ACTIVE_STREAMS,\n",
    "    ).to(DEVICE)\n",
    "\n",
    "    # Print model summary\n",
    "    print(\"\\n--- Final Model Architecture ---\")\n",
    "    # print(final_model) # Can be very verbose\n",
    "    total_params_final = sum(p.numel() for p in final_model.parameters() if p.requires_grad)\n",
    "    print(f\"Trainable parameters in final model: {total_params_final:,}\")\n",
    "\n",
    "    # Optimizer and Criterion for final model\n",
    "    train_labels_final = train_loader_global.dataset.labels.tolist() # From the global loader\n",
    "    n0_final, n1_final = train_labels_final.count(0), train_labels_final.count(1)\n",
    "    total_final = len(train_labels_final)\n",
    "    w0_final, w1_final = (1.0,1.0)\n",
    "    if total_final > 0 and n0_final > 0 and n1_final > 0:\n",
    "        w0_final = total_final / (2. * n0_final)\n",
    "        w1_final = total_final / (2. * n1_final)\n",
    "    \n",
    "    class_weights_final = torch.tensor([w0_final, w1_final], dtype=torch.float32).to(DEVICE)\n",
    "    criterion_final = nn.CrossEntropyLoss(weight=class_weights_final)\n",
    "    optimizer_final = optim.Adam(final_model.parameters(), lr=best_hps['learning_rate'])\n",
    "\n",
    "    print(f\"\\nTraining final model for {NUM_EPOCHS_FINAL_TRAINING} epochs with LR={best_hps['learning_rate']:.2e}...\")\n",
    "    history_final_model = {\"train_loss\": [], \"val_loss_on_hpo_set\": [], \"val_f1_on_hpo_set\": []} # Track basic metrics\n",
    "\n",
    "    for epoch in range(NUM_EPOCHS_FINAL_TRAINING):\n",
    "        t_epoch_start = time.time()\n",
    "        final_train_loss = train_epoch(final_model, train_loader_global, optimizer_final, criterion_final, DEVICE)\n",
    "        \n",
    "        # Optional: evaluate on HPO val set during final training to monitor\n",
    "        # Using fixed 0.5 threshold for this interim check, not tuning threshold every epoch here\n",
    "        val_metrics_interim = evaluate_model_performance(\n",
    "            final_model, val_loader_for_hpo_global, criterion_final, DEVICE, threshold_to_apply=0.5 \n",
    "        )\n",
    "        \n",
    "        history_final_model[\"train_loss\"].append(final_train_loss)\n",
    "        history_final_model[\"val_loss_on_hpo_set\"].append(val_metrics_interim[\"loss\"])\n",
    "        history_final_model[\"val_f1_on_hpo_set\"].append(val_metrics_interim[\"f1\"]) # F1 at 0.5 on HPO val set\n",
    "\n",
    "        print(f\"  Epoch {epoch + 1:02d}/{NUM_EPOCHS_FINAL_TRAINING} – {time.time() - t_epoch_start:.1f}s \"\n",
    "              f\"| Train Loss: {final_train_loss:.4f} \"\n",
    "              f\"| Val HPO Loss: {val_metrics_interim['loss']:.4f} \"\n",
    "              f\"| Val HPO F1@0.5: {val_metrics_interim['f1']:.4f}\")\n",
    "\n",
    "    # --- 5. Evaluate Final Model on the Test Set (set03) ---\n",
    "    print(f\"\\n--- Final Evaluation on Test Set ({TEST_SET_STR}) ---\")\n",
    "    # Create Test DataLoader for set03\n",
    "    test_dataset_obj = PIEDataset_Cell2(\n",
    "        pie_database_global, TEST_SET_STR, POSE_DATA_DIR_CELL2, SEQ_LEN, PRED_LEN,\n",
    "        scalers_global, streams_to_extract=ALL_POSSIBLE_STREAMS_CELL2,\n",
    "    )\n",
    "    if len(test_dataset_obj) == 0:\n",
    "        print(f\"ERROR: Test dataset ({TEST_SET_STR}) is empty. Cannot perform final evaluation.\")\n",
    "    else:\n",
    "        test_loader = DataLoader(test_dataset_obj, batch_size=BATCH_SIZE, shuffle=False, num_workers=2, pin_memory=True)\n",
    "        print(f\"   ✓ Test DataLoader ready ({len(test_dataset_obj)} samples for {TEST_SET_STR}).\")\n",
    "\n",
    "        # Get probabilities and true labels from the test set (set03)\n",
    "        # The criterion_final is just for calculating loss if needed, not strictly for metrics here\n",
    "        test_eval_results = evaluate_model_performance(\n",
    "            final_model, test_loader, criterion_final, DEVICE, \n",
    "            tune_threshold_on_this_data=True # CRUCIAL: Tune threshold on set03 data to get best F1\n",
    "        )\n",
    "        \n",
    "        final_optimal_threshold_set03 = test_eval_results[\"tuned_threshold_if_any\"]\n",
    "        final_f1_set03 = test_eval_results[\"f1_after_tuning_if_any\"] # This is the F1 after tuning on set03\n",
    "        \n",
    "        # Re-calculate metrics with the tuned threshold for consistent reporting\n",
    "        y_true_set03 = test_eval_results[\"true_labels\"]\n",
    "        y_probs_pos_set03 = test_eval_results[\"positive_class_probs\"]\n",
    "        y_pred_set03_tuned = (y_probs_pos_set03 >= final_optimal_threshold_set03).astype(int)\n",
    "\n",
    "        final_accuracy_set03 = accuracy_score(y_true_set03, y_pred_set03_tuned)\n",
    "        final_precision_set03, final_recall_set03, _, = \\\n",
    "            precision_recall_fscore_support(y_true_set03, y_pred_set03_tuned, average='binary', pos_label=1, zero_division=0)[0:3]\n",
    "        final_auc_set03 = roc_auc_score(y_true_set03, y_probs_pos_set03) if len(np.unique(y_true_set03)) > 1 else float('nan')\n",
    "        \n",
    "        cm_set03_tuned = confusion_matrix(y_true_set03, y_pred_set03_tuned, labels=[0, 1])\n",
    "\n",
    "        print(\"\\n--- Final Metrics on Test Set (set03) with Tuned Threshold ---\")\n",
    "        print(f\"{'Optimal Threshold on Set03':<30}: {final_optimal_threshold_set03:.4f}\")\n",
    "        print(f\"{'F1-score (Maximized on Set03)':<30}: {final_f1_set03:.4f}\")\n",
    "        print(f\"{'Accuracy':<30}: {final_accuracy_set03:.4f}\")\n",
    "        print(f\"{'Precision':<30}: {final_precision_set03:.4f}\")\n",
    "        print(f\"{'Recall':<30}: {final_recall_set03:.4f}\")\n",
    "        print(f\"{'AUC':<30}: {final_auc_set03:.4f}\")\n",
    "\n",
    "        # Display Confusion Matrix for set03\n",
    "        ConfusionMatrixDisplay(cm_set03_tuned, display_labels=[\"Not Crossing\", \"Crossing\"]).plot(cmap=plt.cm.Blues)\n",
    "        plt.title(f\"Confusion Matrix - Test Set (set03)\\nOptimal Threshold: {final_optimal_threshold_set03:.2f}, F1: {final_f1_set03:.4f}\")\n",
    "        plt.show()\n",
    "\n",
    "        # Display learned fusion weights from the final model\n",
    "        if hasattr(final_model, \"fusion_weights\"):\n",
    "            f_weights = torch.softmax(final_model.fusion_weights, 0).detach().cpu().numpy()\n",
    "            print(\"\\n--- Learned Fusion Weights (Final Model) ---\")\n",
    "            for stream_name, weight_val in zip(final_model.active_stream_names, f_weights):\n",
    "                print(f\"{stream_name:<20}: {weight_val:.4f}\")\n",
    "            print(\"-\" * 30)\n",
    "\n",
    "    # --- 6. Plot training curves for the final model (optional) ---\n",
    "    if NUM_EPOCHS_FINAL_TRAINING > 0 :\n",
    "        fig_final, ax_final = plt.subplots(1, 2, figsize=(12, 4))\n",
    "        ax_final[0].plot(range(1, NUM_EPOCHS_FINAL_TRAINING + 1), history_final_model[\"train_loss\"], label=\"Final Model Train Loss\")\n",
    "        ax_final[0].plot(range(1, NUM_EPOCHS_FINAL_TRAINING + 1), history_final_model[\"val_loss_on_hpo_set\"], label=f\"Final Model Val Loss ({VAL_SETS_STR})\")\n",
    "        ax_final[0].set_xlabel(\"Epoch\"); ax_final[0].set_ylabel(\"Loss\"); ax_final[0].set_title(\"Final Model Loss\"); ax_final[0].legend(); ax_final[0].grid(True)\n",
    "        \n",
    "        ax_final[1].plot(range(1, NUM_EPOCHS_FINAL_TRAINING + 1), history_final_model[\"val_f1_on_hpo_set\"], label=f\"Final Model Val F1@0.5 ({VAL_SETS_STR})\")\n",
    "        ax_final[1].set_xlabel(\"Epoch\"); ax_final[1].set_ylabel(\"F1 Score @ 0.5\"); ax_final[1].set_title(f\"Final Model F1 on {VAL_SETS_STR}\"); ax_final[1].legend(); ax_final[1].grid(True)\n",
    "        plt.tight_layout(); plt.show()\n",
    "\n",
    "\n",
    "    # Clean up global variables if needed, though script end will do it\n",
    "    del pie_database_global, scalers_global, balanced_train_data_global\n",
    "    del train_loader_global, val_loader_for_hpo_global, current_input_sizes_global\n",
    "    gc.collect()\n",
    "\n",
    "    print(\"\\n--- CELL 2: Script complete ---\")"
   ]
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "gpu",
   "dataSources": [
    {
     "datasetId": 6993690,
     "sourceId": 11201333,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 6993708,
     "sourceId": 11201362,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 6993722,
     "sourceId": 11201388,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 6993740,
     "sourceId": 11201422,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 6993794,
     "sourceId": 11201506,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 6993809,
     "sourceId": 11201543,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 7034191,
     "sourceId": 11255589,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 7127490,
     "sourceId": 11382982,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 7142036,
     "sourceId": 11402679,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 7333398,
     "sourceId": 11684148,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 7357780,
     "sourceId": 11720877,
     "sourceType": "datasetVersion"
    },
    {
     "modelId": 279383,
     "modelInstanceId": 258142,
     "sourceId": 302300,
     "sourceType": "modelInstanceVersion"
    },
    {
     "modelId": 283333,
     "modelInstanceId": 262207,
     "sourceId": 307831,
     "sourceType": "modelInstanceVersion"
    },
    {
     "modelId": 288527,
     "modelInstanceId": 267476,
     "sourceId": 316944,
     "sourceType": "modelInstanceVersion"
    },
    {
     "modelId": 297682,
     "modelInstanceId": 276781,
     "sourceId": 329886,
     "sourceType": "modelInstanceVersion"
    },
    {
     "modelId": 297702,
     "modelInstanceId": 276800,
     "sourceId": 329908,
     "sourceType": "modelInstanceVersion"
    },
    {
     "isSourceIdPinned": true,
     "modelId": 314775,
     "modelInstanceId": 294156,
     "sourceId": 352620,
     "sourceType": "modelInstanceVersion"
    }
   ],
   "dockerImageVersionId": 30918,
   "isGpuEnabled": true,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 17050.59527,
   "end_time": "2025-05-13T21:23:36.924132",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-05-13T16:39:26.328862",
   "version": "2.6.0"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {
     "01bbc1f085d84971a1c2c2b0ade38318": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "0403e8118ca843188ae99abe9106395d": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "06cc19314a13444f9dc5487f8baeca42": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "20px"
      }
     },
     "0a9ed6f4956e442a9789a44b6749596f": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_ed731b2a4af74dc1a1e81bd6fad414dc",
        "IPY_MODEL_0b35a34fb78d4b27b272000fae63d4da",
        "IPY_MODEL_399eb1f9156c4e53a6e2b2537c8c3fe0"
       ],
       "layout": "IPY_MODEL_df44d5810ef34301b46d9bd8b0cf9706",
       "tabbable": null,
       "tooltip": null
      }
     },
     "0b35a34fb78d4b27b272000fae63d4da": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "success",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_8897d94de1b742249a931593c07aaa7e",
       "max": 15.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_5b95cb3572e748cd96cd0d9408a19173",
       "tabbable": null,
       "tooltip": null,
       "value": 15.0
      }
     },
     "14985063ee9a4e539b572c73cf0b7814": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_4d4d144976504cc9872d37d82eed0edd",
        "IPY_MODEL_200d3121b1d94b2e98d0b898e122f17c",
        "IPY_MODEL_c434f3bac3c040cb962d608965318599"
       ],
       "layout": "IPY_MODEL_282c04bdda9341008f48d8dbabb133d7",
       "tabbable": null,
       "tooltip": null
      }
     },
     "1577f3336e9f41dcb69ca1adb2881d4a": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_15f73b68f6154ca3acb5b62060962ca9",
       "placeholder": "​",
       "style": "IPY_MODEL_34e099a5bd314148873908cfb59a22e9",
       "tabbable": null,
       "tooltip": null,
       "value": ""
      }
     },
     "15f73b68f6154ca3acb5b62060962ca9": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "16fb77dd3c0a48debf4fc669760e2472": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": "hidden",
       "width": null
      }
     },
     "18998074198d4300b61ed473fdf9254c": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "1c74a72f1301467685bdfd7ffb50344d": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "info",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_06cc19314a13444f9dc5487f8baeca42",
       "max": 1.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_fd98a9a819f740128eb8f67fa459ad29",
       "tabbable": null,
       "tooltip": null,
       "value": 1.0
      }
     },
     "200d3121b1d94b2e98d0b898e122f17c": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "info",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_b8609f8f06f541e8abe09064f1458245",
       "max": 1.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_8b44fda09b40476fa206189e16071656",
       "tabbable": null,
       "tooltip": null,
       "value": 1.0
      }
     },
     "24a8936086ce4d908873ed3ad8896f8b": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_c91ffb87f2e64bb0814146f37a21b950",
       "placeholder": "​",
       "style": "IPY_MODEL_7f6960cbdd954b17b94dd0c6c3344e9a",
       "tabbable": null,
       "tooltip": null,
       "value": " 1/? [00:00&lt;00:00,  9.63it/s]"
      }
     },
     "253bca0d41e44c75b8683ef988f77dff": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "282c04bdda9341008f48d8dbabb133d7": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": "hidden",
       "width": null
      }
     },
     "2c32c79904ff454d97b8704ee3eaf03d": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "31533ee0a7594a5a94d84fc0439efe29": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "34e099a5bd314148873908cfb59a22e9": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "37421c9760b741c7b0b44c947965ab83": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_5d7775ff8aa443418c76851f587a3a4c",
       "placeholder": "​",
       "style": "IPY_MODEL_bed00f2f30a84799bdea6fdd5a5aa900",
       "tabbable": null,
       "tooltip": null,
       "value": ""
      }
     },
     "399eb1f9156c4e53a6e2b2537c8c3fe0": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_507b0869a0dc49fea8bd4a4fa4b75e7b",
       "placeholder": "​",
       "style": "IPY_MODEL_a5561a1195fc4e7faa1469670998ab52",
       "tabbable": null,
       "tooltip": null,
       "value": " 15/15 [3:31:39&lt;00:00, 844.37s/it]"
      }
     },
     "4130a25b7bd44f06bfbcec23951011ff": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "4aecd82fc8ec438c94eca23a7d0992a8": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_aaf9f8290be24a6380ce049e6ca1c373",
       "placeholder": "​",
       "style": "IPY_MODEL_4d0a13ddfe8b40719fc548cca9841927",
       "tabbable": null,
       "tooltip": null,
       "value": ""
      }
     },
     "4d0a13ddfe8b40719fc548cca9841927": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "4d4d144976504cc9872d37d82eed0edd": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_4130a25b7bd44f06bfbcec23951011ff",
       "placeholder": "​",
       "style": "IPY_MODEL_700e237c9a8846e8b23533672e3bdf20",
       "tabbable": null,
       "tooltip": null,
       "value": ""
      }
     },
     "507b0869a0dc49fea8bd4a4fa4b75e7b": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "570878046a074cf5b7fa6b5f7e28d5eb": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_1577f3336e9f41dcb69ca1adb2881d4a",
        "IPY_MODEL_c86b069421274a3aa3453a9a346aba84",
        "IPY_MODEL_fa43fcfef39b4455b8ab47fc6d93d2b0"
       ],
       "layout": "IPY_MODEL_16fb77dd3c0a48debf4fc669760e2472",
       "tabbable": null,
       "tooltip": null
      }
     },
     "5b7ac241632c45ef831d6f693b36b459": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "success",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_253bca0d41e44c75b8683ef988f77dff",
       "max": 176593.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_a2c2c4b5a1a14ccb9d607fc85c7107b9",
       "tabbable": null,
       "tooltip": null,
       "value": 176593.0
      }
     },
     "5b95cb3572e748cd96cd0d9408a19173": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     },
     "5c76430f88e74d158edeccb027808f4a": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "5d7775ff8aa443418c76851f587a3a4c": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "5ea9f7e92d03455fb831abf14ae343b4": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_4aecd82fc8ec438c94eca23a7d0992a8",
        "IPY_MODEL_1c74a72f1301467685bdfd7ffb50344d",
        "IPY_MODEL_24a8936086ce4d908873ed3ad8896f8b"
       ],
       "layout": "IPY_MODEL_b0dc8c241e174044910dba0016940245",
       "tabbable": null,
       "tooltip": null
      }
     },
     "6a16f6136d914460a9397d37bb0786c0": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     },
     "700e237c9a8846e8b23533672e3bdf20": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "7718ef37a6084d55a143e25fc22a5e19": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "7b3b1fbfc24f488cbc6305d8d2bb9779": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "20px"
      }
     },
     "7b704c59c27d4317aebeb54fb8783c59": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_31533ee0a7594a5a94d84fc0439efe29",
       "placeholder": "​",
       "style": "IPY_MODEL_18998074198d4300b61ed473fdf9254c",
       "tabbable": null,
       "tooltip": null,
       "value": " 176593/176593 [06:18&lt;00:00, 244.78it/s]"
      }
     },
     "7f6960cbdd954b17b94dd0c6c3344e9a": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "805a952c9f4e48ed86a10c42e5d76805": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "20px"
      }
     },
     "8897d94de1b742249a931593c07aaa7e": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "8b44fda09b40476fa206189e16071656": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     },
     "a2c2c4b5a1a14ccb9d607fc85c7107b9": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     },
     "a5561a1195fc4e7faa1469670998ab52": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "a6c7435402ad4f95a8b3f20584ddccb6": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_d1eb69f378ec4221adf97173a5826687",
       "placeholder": "​",
       "style": "IPY_MODEL_01bbc1f085d84971a1c2c2b0ade38318",
       "tabbable": null,
       "tooltip": null,
       "value": "seq: 100%"
      }
     },
     "aaf9f8290be24a6380ce049e6ca1c373": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "b0dc8c241e174044910dba0016940245": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": "hidden",
       "width": null
      }
     },
     "b60f34e423344aa2a8bdd98caa1e1eec": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "b8609f8f06f541e8abe09064f1458245": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "20px"
      }
     },
     "b902ff6536a04fb8b0649c8e549d739a": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": "hidden",
       "width": null
      }
     },
     "bed00f2f30a84799bdea6fdd5a5aa900": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "bf16bc8c04c34cc2abf0a6ddac2d25aa": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "info",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_805a952c9f4e48ed86a10c42e5d76805",
       "max": 1.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_df9ce6801399499fa53cd7bbd2966851",
       "tabbable": null,
       "tooltip": null,
       "value": 1.0
      }
     },
     "c434f3bac3c040cb962d608965318599": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_d20fe7afdcbd4829ba4d295f62ca7c86",
       "placeholder": "​",
       "style": "IPY_MODEL_5c76430f88e74d158edeccb027808f4a",
       "tabbable": null,
       "tooltip": null,
       "value": " 0/? [00:00&lt;?, ?it/s]"
      }
     },
     "c86b069421274a3aa3453a9a346aba84": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "info",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_7b3b1fbfc24f488cbc6305d8d2bb9779",
       "max": 1.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_6a16f6136d914460a9397d37bb0786c0",
       "tabbable": null,
       "tooltip": null,
       "value": 1.0
      }
     },
     "c91ffb87f2e64bb0814146f37a21b950": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "d1eb69f378ec4221adf97173a5826687": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "d20fe7afdcbd4829ba4d295f62ca7c86": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "da43f7f7f985452daa2d7ec21cc79d93": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_a6c7435402ad4f95a8b3f20584ddccb6",
        "IPY_MODEL_5b7ac241632c45ef831d6f693b36b459",
        "IPY_MODEL_7b704c59c27d4317aebeb54fb8783c59"
       ],
       "layout": "IPY_MODEL_b60f34e423344aa2a8bdd98caa1e1eec",
       "tabbable": null,
       "tooltip": null
      }
     },
     "dcb10684f8f7455a9ced15c354c55e58": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_2c32c79904ff454d97b8704ee3eaf03d",
       "placeholder": "​",
       "style": "IPY_MODEL_f3b5b144fb5c45b281bcaf59c559cc2a",
       "tabbable": null,
       "tooltip": null,
       "value": " 9/? [00:00&lt;00:00, 35.13it/s]"
      }
     },
     "df44d5810ef34301b46d9bd8b0cf9706": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "df9ce6801399499fa53cd7bbd2966851": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     },
     "e7744bc0243d4c6aad916289b4877577": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "e801650a7692496183fac3466130ac12": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "ed731b2a4af74dc1a1e81bd6fad414dc": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_0403e8118ca843188ae99abe9106395d",
       "placeholder": "​",
       "style": "IPY_MODEL_e7744bc0243d4c6aad916289b4877577",
       "tabbable": null,
       "tooltip": null,
       "value": "Best trial: 12. Best value: 0.742207: 100%"
      }
     },
     "f3b5b144fb5c45b281bcaf59c559cc2a": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "f500830f328645e291d4e02ec26d42f6": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_37421c9760b741c7b0b44c947965ab83",
        "IPY_MODEL_bf16bc8c04c34cc2abf0a6ddac2d25aa",
        "IPY_MODEL_dcb10684f8f7455a9ced15c354c55e58"
       ],
       "layout": "IPY_MODEL_b902ff6536a04fb8b0649c8e549d739a",
       "tabbable": null,
       "tooltip": null
      }
     },
     "fa43fcfef39b4455b8ab47fc6d93d2b0": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_7718ef37a6084d55a143e25fc22a5e19",
       "placeholder": "​",
       "style": "IPY_MODEL_e801650a7692496183fac3466130ac12",
       "tabbable": null,
       "tooltip": null,
       "value": " 4/? [00:00&lt;00:00, 18.17it/s]"
      }
     },
     "fd98a9a819f740128eb8f67fa459ad29": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     }
    },
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
